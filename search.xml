<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dev_mem的mmap分析</title>
    <url>/2017/04/15/2aae43af7467/</url>
    <content><![CDATA[<p>当用户空间需要实现驱动程序时, 需要操作底层的寄存器. 使用<code>/dev/mem</code>映射io内存空间就是一种常用的方式. <code>/dev/mem</code> 一般都是使用其 <code>mmap</code> 函数. 将底层的寄存器映射到用户空间地址. 下面对 <code>/dev/mem</code>的<code>mmap</code>函数进行一下简单的分析.<br><code>/dev/mem</code>设备文件是由<code>drivers/char/mem.c</code>驱动创建. 该设备文件的<code>file_operations</code>为</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> __<span class="title">maybe_unused</span> <span class="title">mem_fops</span> =</span> &#123;</span><br><span class="line">	.llseek		= memory_lseek,</span><br><span class="line">	.read		= read_mem,</span><br><span class="line">	.write		= write_mem,</span><br><span class="line">	.mmap		= mmap_mem,</span><br><span class="line">	.open		= open_mem,</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	.get_unmapped_area = get_unmapped_area_mem,</span><br><span class="line">	.mmap_capabilities = memory_mmap_capabilities,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>mmap_mem</code>定义为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mmap_mem</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!valid_mmap_phys_addr_range(vma-&gt;vm_pgoff, size))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!private_mapping_ok(vma))</span><br><span class="line">		<span class="keyword">return</span> -ENOSYS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!range_is_allowed(vma-&gt;vm_pgoff, size))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!phys_mem_access_prot_allowed(file, vma-&gt;vm_pgoff, size,</span><br><span class="line">						&amp;vma-&gt;vm_page_prot))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	vma-&gt;vm_page_prot = phys_mem_access_prot(file, vma-&gt;vm_pgoff,</span><br><span class="line">						 size,</span><br><span class="line">						 vma-&gt;vm_page_prot);</span><br><span class="line"></span><br><span class="line">	vma-&gt;vm_ops = &amp;mmap_mem_ops;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remap-pfn-range will mark the range VM_IO */</span></span><br><span class="line">	<span class="keyword">if</span> (remap_pfn_range(vma,</span><br><span class="line">			    vma-&gt;vm_start,</span><br><span class="line">			    vma-&gt;vm_pgoff,</span><br><span class="line">			    size,</span><br><span class="line">			    vma-&gt;vm_page_prot)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>valid_mmap_phys_addr_range</code>函数始终返回1.<br><code>private_mapping_ok</code>函数在由MMU的情况下始终返回1.<br><code>range_is_allowed</code>函数不配置<code>CONFIG_STRICT_DEVMEM</code>时始终返回1, 在配置<code>CONFIG_STRICT_DEVMEM</code>时, 齐定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">range_is_allowed</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> pfn, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 from = ((u64)pfn) &lt;&lt; PAGE_SHIFT;</span><br><span class="line">	u64 to = from + size;</span><br><span class="line">	u64 cursor = from;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cursor &lt; to) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!devmem_is_allowed(pfn))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		cursor += PAGE_SIZE;</span><br><span class="line">		pfn++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中, 会对需要映射的地址段进行检查, 在x86平台上, <code>devmem_is_allowed</code>定义为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">devmem_is_allowed</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> pagenr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pagenr &lt; <span class="number">256</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (iomem_is_exclusive(pagenr &lt;&lt; PAGE_SHIFT))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!page_is_ram(pagenr))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在arm平台上, <code>dev_mem_allowed</code>定义为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">devmem_is_allowed</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (iomem_is_exclusive(pfn &lt;&lt; PAGE_SHIFT))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!page_is_ram(pfn))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在x86上, 前1M空间是预留给BIOS和一些其他X等应用使用的空间, 这段空间是允许映射的.<br><code>iomem_is_exclusive</code>定义为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * check if an address is reserved in the iomem resource tree</span></span><br><span class="line"><span class="comment"> * returns 1 if reserved, 0 if not reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">iomem_is_exclusive</span><span class="params">(u64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">p</span> =</span> &amp;iomem_resource;</span><br><span class="line">	<span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">	<span class="type">loff_t</span> l;</span><br><span class="line">	<span class="type">int</span> size = PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!strict_iomem_checks)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	addr = addr &amp; PAGE_MASK;</span><br><span class="line"></span><br><span class="line">	read_lock(&amp;resource_lock);</span><br><span class="line">	<span class="keyword">for</span> (p = p-&gt;child; p ; p = r_next(<span class="literal">NULL</span>, p, &amp;l)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We can probably skip the resources without</span></span><br><span class="line"><span class="comment">		 * IORESOURCE_IO attribute?</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;start &gt;= addr + size)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;end &lt; addr)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * A resource is exclusive if IORESOURCE_EXCLUSIVE is set</span></span><br><span class="line"><span class="comment">		 * or CONFIG_IO_STRICT_DEVMEM is enabled and the</span></span><br><span class="line"><span class="comment">		 * resource is busy.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((p-&gt;flags &amp; IORESOURCE_BUSY) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (IS_ENABLED(CONFIG_IO_STRICT_DEVMEM)</span><br><span class="line">				|| p-&gt;flags &amp; IORESOURCE_EXCLUSIVE) &#123;</span><br><span class="line">			err = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	read_unlock(&amp;resource_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这段地址对应的resource标记为<code>IORESOURCE_BUSY</code>, 那么将映射失败.<br>如果这段地址在ram中, 同样不允许映射.<br>可以看出在不配置<code>CONFIG_STRICT_DEVMEM</code>时, &#x2F;dev&#x2F;mem的限制是最小的.<br><code>phys_mem_access_prot_allowed</code>函数返回1<br>检查各种限制条件通过后, 接着调用<code>phys_mem_access_prot(file, vma-&gt;vm_pgoff, size, vma-&gt;vm_page_prot);</code>来改变被映射的内存区的的页面属性.<br>对于arm64, 定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pgprot_t</span> <span class="title function_">phys_mem_access_prot</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> pfn,</span></span><br><span class="line"><span class="params">			      <span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">pgprot_t</span> vma_prot)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!pfn_valid(pfn))</span><br><span class="line">		<span class="keyword">return</span> pgprot_noncached(vma_prot);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (file-&gt;f_flags &amp; O_SYNC)</span><br><span class="line">		<span class="keyword">return</span> pgprot_writecombine(vma_prot);</span><br><span class="line">	<span class="keyword">return</span> vma_prot;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(phys_mem_access_prot);</span><br></pre></td></tr></table></figure>
<p>对于非内存空间, 使用<code>nocached</code>, 对于内存空间如果file打开了<code>O_SYNC</code>标志就使用<code>write_combine</code>.<br>最后调用<code>remap_pfn_range</code>来分配页表, 讲用户空间的一段线性地址空间指向映射的区域.<br>!</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>mmap</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel中的IS_ENABLED</title>
    <url>/2017/04/15/82864c500e55/</url>
    <content><![CDATA[<p>在kernel的代码中, 有时候会看见<code>IS_ENABLED(CONFIG_XXXX)</code>来测试某个Kconfig选项是否开启(即选中为<code>y</code>或者<code>m</code>). 如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_TIME_LOW_RES) &amp;&amp; timer-&gt;is_rel)</span><br><span class="line">	rem -= hrtimer_resolution;</span><br></pre></td></tr></table></figure>
<p>这里当TIME_LOW_RES这个Kconfig选项配置为<code>y</code>或<code>m</code>, 并且<code>timer-&gt;is_rel</code>不为0时调用<code>rem -= hrtimer_resolution</code>.<br>那么这个是怎样实现的呢?</p>
<span id="more"></span>
<p>首先在Kconfig中选中某个选项为<code>y</code>或<code>m</code>时, 在<code>.config</code>文件中就会由一个<code>CONFIG_XXXXX=y</code>或<code>CONFIG_XXXXX=m</code>, 并且会自动生成一个头文件<code>autoconfig.h</code>. 当选中为<code>y</code>时, 头文件中包含<code>#define CONFIG_XXXXX 1</code>, 当选中为<code>m</code>时, 头文件中包含<code>#define CONFIG_XXXXX_MODULE 1</code>, 当不选中是, 头文件中不包含相关语句.<br><code>IS_ENABLED</code>定义为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ENABLED(option) __or(IS_BUILTIN(option), IS_MODULE(option))</span></span><br></pre></td></tr></table></figure>
<p><code>IS_BUILTIN</code>, <code>IS_MODULE</code>和<code>__or</code>分别定义为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_BUILTIN(option) __is_defined(option)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MODULE(option) __is_defined(option##_MODULE)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __or(x, y)			___or(x, y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___or(x, y)			____or(__ARG_PLACEHOLDER_##x, y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ____or(arg1_or_junk, y)		__take_second_arg(arg1_or_junk 1, y)</span></span><br></pre></td></tr></table></figure>
<p><code>__is_defined</code>定义为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __is_defined(x)			___is_defined(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___is_defined(val)		____is_defined(__ARG_PLACEHOLDER_##val)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ____is_defined(arg1_or_junk)	__take_second_arg(arg1_or_junk 1, 0)</span></span><br></pre></td></tr></table></figure>
<p>在这之前定义了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __ARG_PLACEHOLDER_1 0,</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __take_second_arg(__ignored, val, ...) val</span></span><br></pre></td></tr></table></figure>
<p>当<code>#define CONFIG_XXXXX 1</code>时<code>__is_defined(1)</code>展开为<code>____is_defined(0,)</code>, 即<code>__take_second_arg(0, 1, 0)</code>, 最终为<code>1</code><br>当<code>CONFIG_XXXXX</code>没有定义时<code>__is_defined()</code>展开为<code>____is_defined()</code>(因为没有定义__ARG_PLACEHOLDER_), 即<code>__take_second_arg(1, 0)</code>, 最终为<code>0</code><br>同样的方法可以理解<code>__or</code>.<br>因此<code>IS_ENABLED</code>主要是将没有定义的<code>CONFIG_XXXXX</code>映射到0.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>driver</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mmap读写寄存器应注意不要越界</title>
    <url>/2017/04/15/1110205abd52/</url>
    <content><![CDATA[<p>前两天使用&#x2F;dev&#x2F;mem来修改寄存器时遇到了一个问题. 当时的情况是这样的:<br>我有8K的寄存器空间需要访问, 但是当时我将mmap的空间大小写小了, 只写了1K, 相当于只映射了4K的空间. 但是当我操作到4K-8K的空间的时候, 读写看起来都没有问题, 读回来的数据和写入的数据是一致的. 但是实际寄存器上好像没有感受到一样(没有写入寄存器应有的现象), 刚开始一致怀疑是fpga的bitfile有问题. 后来无意发现了mmap指定的size不对, 改好了就可以了.<br>那么这里有一个问题, 为什么访问4K-8K的空间没有发生segment fault呢?</p>
<span id="more"></span>
<p>我做了一个实验, 下面有两个程序:<br>program 0 - have mmap:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR | O_DSYNC);</span><br><span class="line">	<span class="type">void</span> *ptr = mmap(<span class="number">0</span>, <span class="number">1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%016lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)ptr);</span><br><span class="line">	pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>program 1 - don’t have mmap:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先将程序运行起来, 然后通过&#x2F;proc&#x2F;[pid]&#x2F;maps查看他们的线性地址分布情况:<br>对于program 0:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00400000-00401000 r-xp 00000000 fd:02 1051271                            /home/gngshn/b</span><br><span class="line">00600000-00601000 r--p 00000000 fd:02 1051271                            /home/gngshn/b</span><br><span class="line">00601000-00602000 rw-p 00001000 fd:02 1051271                            /home/gngshn/b</span><br><span class="line">02293000-022b4000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7f17bd677000-7f17bd834000 r-xp 00000000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7f17bd834000-7f17bda33000 ---p 001bd000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7f17bda33000-7f17bda37000 r--p 001bc000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7f17bda37000-7f17bda39000 rw-p 001c0000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7f17bda39000-7f17bda3d000 rw-p 00000000 00:00 0</span><br><span class="line">7f17bda3d000-7f17bda62000 r-xp 00000000 fd:00 924461                     /usr/lib64/ld-2.24.so</span><br><span class="line">7f17bdc3f000-7f17bdc41000 rw-p 00000000 00:00 0</span><br><span class="line">7f17bdc5f000-7f17bdc60000 rw-s 00000000 fd:02 1066614                    /home/gngshn/a.txt</span><br><span class="line">7f17bdc60000-7f17bdc62000 rw-p 00000000 00:00 0</span><br><span class="line">7f17bdc62000-7f17bdc63000 r--p 00025000 fd:00 924461                     /usr/lib64/ld-2.24.so</span><br><span class="line">7f17bdc63000-7f17bdc64000 rw-p 00026000 fd:00 924461                     /usr/lib64/ld-2.24.so</span><br><span class="line">7f17bdc64000-7f17bdc65000 rw-p 00000000 00:00 0</span><br><span class="line">7fff75117000-7fff75138000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7fff75151000-7fff75153000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7fff75153000-7fff75155000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure>
<p>对于program 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00400000-00401000 r-xp 00000000 fd:02 1051230                            /home/gngshn/a</span><br><span class="line">00600000-00601000 r--p 00000000 fd:02 1051230                            /home/gngshn/a</span><br><span class="line">00601000-00602000 rw-p 00001000 fd:02 1051230                            /home/gngshn/a</span><br><span class="line">7fb99a57a000-7fb99a737000 r-xp 00000000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7fb99a737000-7fb99a936000 ---p 001bd000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7fb99a936000-7fb99a93a000 r--p 001bc000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7fb99a93a000-7fb99a93c000 rw-p 001c0000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7fb99a93c000-7fb99a940000 rw-p 00000000 00:00 0</span><br><span class="line">7fb99a940000-7fb99a965000 r-xp 00000000 fd:00 924461                     /usr/lib64/ld-2.24.so</span><br><span class="line">7fb99ab42000-7fb99ab44000 rw-p 00000000 00:00 0</span><br><span class="line">7fb99ab63000-7fb99ab65000 rw-p 00000000 00:00 0</span><br><span class="line">7fb99ab65000-7fb99ab66000 r--p 00025000 fd:00 924461                     /usr/lib64/ld-2.24.so</span><br><span class="line">7fb99ab66000-7fb99ab67000 rw-p 00026000 fd:00 924461                     /usr/lib64/ld-2.24.so</span><br><span class="line">7fb99ab67000-7fb99ab68000 rw-p 00000000 00:00 0</span><br><span class="line">7ffdbcd07000-7ffdbcd28000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffdbcd31000-7ffdbcd33000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffdbcd33000-7ffdbcd35000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure>
<p>可以看到program 0比program 1多了两段地址空间</p>
<ol>
<li>heap空间</li>
<li>a.txt的mmap空间<br>heap空间是引入标准io时, 内部使用引入的; a.txt的mmap空间是程序里面调用mmap产生的.<br>这里可以看见mmap访问后面的地址没有出错的原因了, 在mmap后面刚好有一段mmap空间<code>7f17bdc60000-7f17bdc62000 rw-p 00000000 00:00 0</code>, size为8K, 权限为读写, 这段空间是匿名映射空间, 当时我的读写都操作到这里了.<br>因此在使用mmap操作的时候, 一定要注意操作内存不要过界, 程序很可能不会因为你的操作过界而发生segment fault, 但是却会和你期望的相差甚远.</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>mmap</tag>
        <tag>driver</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker来构建嵌入式开发环境</title>
    <url>/2017/04/15/220446e73c89/</url>
    <content><![CDATA[<p>我目前使用的一套嵌入式开发SDK是在ubuntu 14.04上构建的, 对于较新的ubuntu发行版或其他linux发行版是不能兼容的.<br>比如目前我使用的是Fedora 25作为自己的系统, 那么要编译SDK会发生错误. 主要是libtools, autoconf等工具的兼容性问题. 为了解决这个问题可以使用docker来构建一套基于ubuntu14.04文件系统的编译系统, 从而实现在Fedora 25上编译SDK.</p>
<span id="more"></span>
<p>首先贴上自己的Dockerfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rsdk builder docker</span><br><span class="line"># creater by gngshn</span><br><span class="line"># Jan 20 2017</span><br><span class="line">FROM ubuntu:14.04</span><br><span class="line">ENV TERM=xterm</span><br><span class="line">RUN echo &quot;dash dash/sh boolean false&quot; | debconf-set-selections \</span><br><span class="line">    &amp;&amp; dpkg-reconfigure -p critical dash \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y bc python dpkg lzma pkg-config libncurses5-dev \</span><br><span class="line">       autoconf automake cmake libtool gettext texinfo gawk \</span><br><span class="line">    &amp;&amp; dpkg --add-architecture i386 \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y gcc-multilib lib32z1-dev lib32ncurses5-dev \</span><br><span class="line">    &amp;&amp; apt-get clean \</span><br><span class="line">    &amp;&amp; groupadd -g 1000 gngshn \</span><br><span class="line">    &amp;&amp; useradd -u 1000 -g 1000 -G sudo -m gngshn \</span><br><span class="line">    &amp;&amp; mkdir /home/gngshn/ipcam \</span><br><span class="line">    &amp;&amp; chown gngshn:gngshn /home/gngshn/ipcam \</span><br><span class="line">    &amp;&amp; echo &quot;root:xx&quot; | chpasswd \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</span><br><span class="line">USER gngshn</span><br><span class="line">WORKDIR /home/gngshn</span><br><span class="line">ENV TERM=xterm-256color \</span><br><span class="line">    TERMINFO=/lib/terminfo</span><br></pre></td></tr></table></figure>
<p>在Dockerfile中需要安装的包都是在ubuntu 14.04 docker中根据需要一步一步安装, 并最终确定需要的安装的所有的包.<br>在上面的Dockerfile目录下执行<code>sudo docker build -t ipcam_build .</code>, docker就会从docker.io上下载ubuntu 14.04(也可以配置一些国内的docker加速器加速), 然后开始一层一层构建整个开发环境<br>等<code>ipcam_build</code>构建完成后, 执行<code>sudo docker run -it --name ipcam_build -v ~/ipcam:/home/gngshn/ipcam ipcam_build</code>, 就可以进入到本开发环境的命令行了, 同时在docker 用户目录的ipcam下挂载了宿主机上的SDK(宿主机SDK的目录在~&#x2F;ipcam).<br>后续就可以在docker中直接编译SDK了.<br>在docker命令行下按<code>Ctrl+D</code>就退出docker了, 当需要再次进入SDK编译环境时执行<code>sudo docker start -ai ipcam_build</code>就可以了.<br>对于其他的嵌入式开发环境配置也是类似的. 这里就是一个简单的引导.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>正式开始书写自己的博客</title>
    <url>/2017/04/15/090c3684bdb9/</url>
    <content><![CDATA[<p>之前一直不喜欢类似csdn一类的网站来写博客, 自己搭wordpress有太麻烦, 现在使用github page正式开启自己的博客之旅.<br>这里主要会记录一些自己遇到的坑和一些学习的见解, 希望自己能坚持下去.</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>libuv 源码分析(1) - event loop的初始化</title>
    <url>/2017/09/01/0aa91256124a/</url>
    <content><![CDATA[<p>by gngshn <a href="mailto:&#103;&#x6e;&#x67;&#x73;&#x68;&#x6e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;">&#103;&#x6e;&#x67;&#x73;&#x68;&#x6e;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;</a></p>
<p>从这里开始我将从linux的角度来看看libuv的工作原理, 如果您希望看到libuv跨平台的实现方式, 那你可能要失望了. 因为这一系列文章都将从linux的角度来写.</p>
<p>我们知道如果需要使用libuv的event loop需要通过<code>uv_default_loop</code>或者<code>uv_loop_init</code>来获得一个loop, 前者也是会调用后者的. 所以我们来看看<code>uv_loop_init</code>到底做了些什么, 我将在source code中进行直接写注释来描述相关字段的含义.</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_loop_init</span><span class="params">(<span class="type">uv_loop_t</span>* loop)</span> &#123;</span><br><span class="line">  <span class="type">void</span>* saved_data;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建一ipe, 往其中一端写能解锁读端, 这与信号处理有关 */</span></span><br><span class="line">  uv__signal_global_once_init();</span><br><span class="line"></span><br><span class="line">  saved_data = loop-&gt;data;</span><br><span class="line">  <span class="built_in">memset</span>(loop, <span class="number">0</span>, <span class="keyword">sizeof</span>(*loop));</span><br><span class="line">  loop-&gt;data = saved_data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 保存libuv中timer的堆, 用来计算下次poll的超时时间 */</span></span><br><span class="line">  heap_init((<span class="keyword">struct</span> heap*) &amp;loop-&gt;timer_heap);</span><br><span class="line">  <span class="comment">/* libuv线程池完成工作以后, 会把相关的request(uv_work_t)放在这个链表上, 从而libuv可以通过他来调用after_work_done回调 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;wq);</span><br><span class="line">  <span class="comment">/* event loop中的所有的request */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;active_reqs);</span><br><span class="line">  <span class="comment">/* event loop中的idle handles, 这个handle每次loop都会调用一次 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;idle_handles);</span><br><span class="line">  <span class="comment">/* event loop中的async_handles, 这个handle主要用来管理多线程的异步通知, 如libuv的工作队列的完成通知 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;async_handles);</span><br><span class="line">  <span class="comment">/* event loop中的prepare handles, 这个handle每次loop都会调用一次 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;check_handles);</span><br><span class="line">  <span class="comment">/* event loop中的check handles, 这个handle每次loop都会调用一次, 和prepare是一对, 分别在poll前后调用 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;prepare_handles);</span><br><span class="line">  <span class="comment">/* event loop中所有的handle */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;handle_queue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* event loop监听的描述符数量 */</span></span><br><span class="line">  loop-&gt;nfds = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* event loop监听的事件的表(数组, 但不一定充满, 用fd来索引), 最后两个元素是特殊的 */</span></span><br><span class="line">  loop-&gt;watchers = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">/* watchers数组的大小 - 2 */</span></span><br><span class="line">  loop-&gt;nwatchers = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* TODO */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;pending_queue);</span><br><span class="line">  <span class="comment">/* 所有待加入poll的事ueue, libuv通过它来确定需要往epoll中加入哪些描述符和事件 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;watcher_queue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 需要关闭的handles链表 */</span></span><br><span class="line">  loop-&gt;closing_handles = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">/* 更新时间 */</span></span><br><span class="line">  uv__update_time(loop);</span><br><span class="line">  <span class="comment">/* 这里存放异步通知所用的eventfd或者pipe的描述符 */</span></span><br><span class="line">  loop-&gt;async_io_watcher.fd = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* 和上面一样, 存放pipe对的另一个描述符, 如果是eventfd, 就是-1 */</span></span><br><span class="line">  loop-&gt;async_wfd = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* uv信号处理回调所用的pipe, 信号处理函数往[1]写, event loop poll [0], 从而获取msg来处理信号 */</span></span><br><span class="line">  loop-&gt;signal_pipefd[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  loop-&gt;signal_pipefd[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* event loop的epoll描述符 */</span></span><br><span class="line">  loop-&gt;backend_fd = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* TODO */</span></span><br><span class="line">  loop-&gt;emfile_fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* timer id的counter, 为了给timer一个唯一的id, 每次创建timer, 这个值都加1 */</span></span><br><span class="line">  loop-&gt;timer_counter = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* event loop的停止标志*/</span></span><br><span class="line">  loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将backend_fd设为创建的epoll的描述符, 并初始化了inotify为-1 */</span></span><br><span class="line">  err = uv__platform_loop_init(loop);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  <span class="comment">/* 这里会初始化前面的signal_pipefd为一对pipe并将signal_pipefd[0]的POLLIN事件加入监听列表, 用来处理信号 */</span></span><br><span class="line">  <span class="comment">/* 这里的child_watcher是用来处理子进程的退出的, 会在创建进程(uv_spam)时添加SIG_CHILD的处理 */</span></span><br><span class="line">  err = uv_signal_init(loop, &amp;loop-&gt;child_watcher);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> fail_signal_init;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* unref是为了不让event loop停不下来, 也就是event loop判定alive的条件去除这个handle, 后面文章会说 */</span></span><br><span class="line">  uv__handle_unref(&amp;loop-&gt;child_watcher);</span><br><span class="line">  <span class="comment">/* 标记为UV__HANDLE_INTERNAL, 从而handle不会被关闭, 也不会被uv_walk影响 */</span></span><br><span class="line">  loop-&gt;child_watcher.flags |= UV__HANDLE_INTERNAL;</span><br><span class="line">  <span class="comment">/* 所有子进程的队列 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;process_handles);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* TODO */</span></span><br><span class="line">  err = uv_rwlock_init(&amp;loop-&gt;cloexec_lock);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> fail_rwlock_init;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 用来保护loop-&gt;wq的保护锁 */</span></span><br><span class="line">  err = uv_mutex_init(&amp;loop-&gt;wq_mutex);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> fail_mutex_init;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建eventfd放在async_io_watcher.fd(前面说过), 并把其POLLIN加入到监听事件中, 用来处理进程发来的异步通知 */</span></span><br><span class="line">  err = uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> fail_async_init;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 前面讲过 */</span></span><br><span class="line">  uv__handle_unref(&amp;loop-&gt;wq_async);</span><br><span class="line">  loop-&gt;wq_async.flags |= UV__HANDLE_INTERNAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_async_init:</span><br><span class="line">  uv_mutex_destroy(&amp;loop-&gt;wq_mutex);</span><br><span class="line"></span><br><span class="line">fail_mutex_init:</span><br><span class="line">  uv_rwlock_destroy(&amp;loop-&gt;cloexec_lock);</span><br><span class="line"></span><br><span class="line">fail_rwlock_init:</span><br><span class="line">  uv__signal_loop_cleanup(loop);</span><br><span class="line"></span><br><span class="line">fail_signal_init:</span><br><span class="line">  uv__platform_loop_delete(loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是libuv的event loop的初始化流程, 后续我将分模块来讲解libuv各个功能模块的实现原理.</p>
]]></content>
      <categories>
        <category>libuv</category>
      </categories>
      <tags>
        <tag>libuv</tag>
      </tags>
  </entry>
  <entry>
    <title>libuv 源码分析(2) - event loop的运转</title>
    <url>/2017/09/01/b607a607ddf8/</url>
    <content><![CDATA[<p>by gngshn <a href="mailto:&#x67;&#110;&#x67;&#115;&#104;&#110;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;">&#x67;&#110;&#x67;&#115;&#104;&#110;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;</a></p>
<p>上一篇文章我们讲到了 libuv的初始化, 现在乘热打铁, 我们接着看看 libuv的 event loop是如何运转的.<br>对于 event loop的运转在其官方的文档中有详细的描述<br><br><a href="http://docs.libuv.org/en/v1.x/design.html">libuv design overview</a><br>event loop的流程图如下</p>
<span id="more"></span>
<p><img src="http://docs.libuv.org/en/v1.x/_images/loop_iteration.png" alt="libuv event loop"><br>下面我们就从源码的角度来看看整个过程.<br>先看看一个最简单的 libuv程序:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uv_loop_t</span> *loop = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">uv_loop_t</span>));</span><br><span class="line">    uv_loop_init(loop);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now quitting.\n&quot;</span>);</span><br><span class="line">    uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line"></span><br><span class="line">    uv_loop_close(loop);</span><br><span class="line">    <span class="built_in">free</span>(loop);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 libuv的 event loop过程在 <code>uv_run</code>中实现的. 我们下面来看看其过程.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_run</span><span class="params">(<span class="type">uv_loop_t</span>* loop, uv_run_mode mode)</span> &#123;</span><br><span class="line">  <span class="type">int</span> timeout;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  <span class="type">int</span> ran_pending;</span><br><span class="line"></span><br><span class="line">  r = uv__loop_alive(loop);</span><br><span class="line">  <span class="keyword">if</span> (!r)</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line">    uv__run_timers(loop);</span><br><span class="line">    ran_pending = uv__run_pending(loop);</span><br><span class="line">    uv__run_idle(loop);</span><br><span class="line">    uv__run_prepare(loop);</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br><span class="line"></span><br><span class="line">    uv__io_poll(loop, timeout);</span><br><span class="line">    uv__run_check(loop);</span><br><span class="line">    uv__run_closing_handles(loop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      <span class="comment">/* UV_RUN_ONCE implies forward progress: at least one callback must have</span></span><br><span class="line"><span class="comment">       * been invoked when it returns. uv__io_poll() can return without doing</span></span><br><span class="line"><span class="comment">       * I/O (meaning: no callbacks) when its timeout expires - which means we</span></span><br><span class="line"><span class="comment">       * have pending timers that satisfy the forward progress constraint.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * UV_RUN_NOWAIT makes no guarantees about progress so it&#x27;s omitted from</span></span><br><span class="line"><span class="comment">       * the check.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The if statement lets gcc compile it to a conditional store. Avoids</span></span><br><span class="line"><span class="comment">   * dirtying a cache line.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数首先判断 event loop是否是 alive的, 如果不是, 更新 loop时间然后就退出了. 这里判断 alive的函数为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uv__loop_alive</span><span class="params">(<span class="type">const</span> <span class="type">uv_loop_t</span>* loop)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> uv__has_active_handles(loop) ||</span><br><span class="line">         uv__has_active_reqs(loop) ||</span><br><span class="line">         loop-&gt;closing_handles != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到, libuv判定 event loop存活(继续循环)的逻辑为有活动的 handle, request或者待关闭的 handle.<br>当 <code>uv__loop_alive</code>返回 false时, 就不进行循环, 直接退出. 如果返回 true, 就进行循环.<br>下面我们来分析一下这个循环的过程.</p>
<h3 id="uv-update-time-loop"><a href="#uv-update-time-loop" class="headerlink" title="uv__update_time(loop)"></a><code>uv__update_time(loop)</code></h3><p>细心的你们在阅读代码时, 可能会发现, libuv为了性能(效率)尽可能的再优化每一个细节, 比如 time更新这个地方</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">uv__hrtime</span><span class="params">(<span class="type">uv_clocktype_t</span> type)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">clock_t</span> fast_clock_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span></span><br><span class="line">  <span class="type">clock_t</span> clock_id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Prefer CLOCK_MONOTONIC_COARSE if available but only when it has</span></span><br><span class="line"><span class="comment">   * millisecond granularity or better.  CLOCK_MONOTONIC_COARSE is</span></span><br><span class="line"><span class="comment">   * serviced entirely from the vDSO, whereas CLOCK_MONOTONIC may</span></span><br><span class="line"><span class="comment">   * decide to make a costly system call.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/* TODO(bnoordhuis) Use CLOCK_MONOTONIC_COARSE for UV_CLOCK_PRECISE</span></span><br><span class="line"><span class="comment">   * when it has microsecond granularity or better (unlikely).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (type == UV_CLOCK_FAST &amp;&amp; fast_clock_id == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clock_getres(CLOCK_MONOTONIC_COARSE, &amp;t) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        t.tv_nsec &lt;= <span class="number">1</span> * <span class="number">1000</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">      fast_clock_id = CLOCK_MONOTONIC_COARSE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fast_clock_id = CLOCK_MONOTONIC;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clock_id = CLOCK_MONOTONIC;</span><br><span class="line">  <span class="keyword">if</span> (type == UV_CLOCK_FAST)</span><br><span class="line">    clock_id = fast_clock_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (clock_gettime(clock_id, &amp;t))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* Not really possible. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> t.tv_sec * (<span class="type">uint64_t</span>) <span class="number">1e9</span> + t.tv_nsec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CLOCK_MONOTONIC_COARSE</code>这种类型的 clock精度足够就会用这种类型, 因为这种类型的 clock使用 vDSO, 可以降低系统调用的开销.</p>
<h3 id="uv-run-timers-loop"><a href="#uv-run-timers-loop" class="headerlink" title="uv__run_timers(loop)"></a><code>uv__run_timers(loop)</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uv__run_timers</span><span class="params">(<span class="type">uv_loop_t</span>* loop)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">heap_node</span>* <span class="title">heap_node</span>;</span></span><br><span class="line">  <span class="type">uv_timer_t</span>* handle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    heap_node = heap_min((<span class="keyword">struct</span> heap*) &amp;loop-&gt;timer_heap);</span><br><span class="line">    <span class="keyword">if</span> (heap_node == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    handle = container_of(heap_node, <span class="type">uv_timer_t</span>, heap_node);</span><br><span class="line">    <span class="keyword">if</span> (handle-&gt;timeout &gt; loop-&gt;time)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    uv_timer_stop(handle);</span><br><span class="line">    uv_timer_again(handle);</span><br><span class="line">    handle-&gt;timer_cb(handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的timer handles都是用 <code>uv_timer_start</code>调用来注册生效的. <code>uv__run_timers</code>就是把注册的 timers中到期的 timer去掉并注册回调, 具体过程为:<br><br>具体流程为, 从 <code>timer_heap</code>(最小堆)取 timer, 这是最小的 timer, 如果 timer比现在的时间大, 表明没超时, 就可以退出了, 如果比现在的时间小, 表明已经超时, 就将 timer从 heap中删除, 然后调用 <code>uv__handle_stop</code>停止 handle. 再调用 <code>uv_timer_again</code>(会调用<code>uv_timer_start</code>)再次开启有 repeat值的 timer, 这次 timer的时间是按照 timer的 repeat时间来设定, 也就是 timer可以周期性触发. 最后调用 timer的 <code>timer_cb</code>回调.<br><br>回到开启继续处理后面的 timer.</p>
<p>这里刚好遇到了 handle的操作, 之前没细说, 这里细说下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> uv__handle_start(h)                                                   \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                        \</span></span><br><span class="line"><span class="meta">    assert(((h)-&gt;flags &amp; UV__HANDLE_CLOSING) == 0);                           \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_ACTIVE) != 0) break;                         \</span></span><br><span class="line"><span class="meta">    (h)-&gt;flags |= UV__HANDLE_ACTIVE;                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_REF) != 0) uv__active_handle_add(h);         \</span></span><br><span class="line"><span class="meta">  &#125;                                                                           \</span></span><br><span class="line"><span class="meta">  while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uv__handle_stop(h)                                                    \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                        \</span></span><br><span class="line"><span class="meta">    assert(((h)-&gt;flags &amp; UV__HANDLE_CLOSING) == 0);                           \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_ACTIVE) == 0) break;                         \</span></span><br><span class="line"><span class="meta">    (h)-&gt;flags &amp;= ~UV__HANDLE_ACTIVE;                                         \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_REF) != 0) uv__active_handle_rm(h);          \</span></span><br><span class="line"><span class="meta">  &#125;                                                                           \</span></span><br><span class="line"><span class="meta">  while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uv__handle_ref(h)                                                     \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                        \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_REF) != 0) break;                            \</span></span><br><span class="line"><span class="meta">    (h)-&gt;flags |= UV__HANDLE_REF;                                             \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_CLOSING) != 0) break;                        \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_ACTIVE) != 0) uv__active_handle_add(h);      \</span></span><br><span class="line"><span class="meta">  &#125;                                                                           \</span></span><br><span class="line"><span class="meta">  while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uv__handle_unref(h)                                                   \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                        \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_REF) == 0) break;                            \</span></span><br><span class="line"><span class="meta">    (h)-&gt;flags &amp;= ~UV__HANDLE_REF;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_CLOSING) != 0) break;                        \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_ACTIVE) != 0) uv__active_handle_rm(h);       \</span></span><br><span class="line"><span class="meta">  &#125;                                                                           \</span></span><br><span class="line"><span class="meta">  while (0)</span></span><br></pre></td></tr></table></figure>
<p>上面这四个宏用来开启, 关闭, 引用, 解除引用handle, 这里要注意到几点:</p>
<ol>
<li>在开启 handle时, 当 <code>UV__HANDLE_ACTIVE</code>已经置起来时(handle已经开启了), 就不进行后面的操作了, 所以可以重复调用 <code>uv__handle_start</code>不会产生问题. 关闭 handle时同理.</li>
<li>在引用 handle时, 当 <code>UV__HANDLE_REF</code>已经置起来时(handle已经引用过了), 就不再增加引用计数了, 所以重复调用, handle也只会增加一次引用计数, 解除引用 handle时同理.</li>
<li><code>uv__active_handle_add</code>和<code>uv__active_handle_rm</code>增加&#x2F;减少的引用计数是loop的(而不是handle本身)引用计数, 字段为<code>active_handles</code>, 因此一个handle可以通过ref或unref来让一个handle是否影响到loop的active, 比如libuv的async_handle就通过<code>uv__handle_unref</code>来防止event loop无法退出.</li>
</ol>
<h3 id="uv-run-pending"><a href="#uv-run-pending" class="headerlink" title="uv__run_pending"></a>uv__run_pending</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uv__run_pending</span><span class="params">(<span class="type">uv_loop_t</span>* loop)</span> &#123;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE pq;</span><br><span class="line">  <span class="type">uv__io_t</span>* w;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;pq)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;pq);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line">    w = QUEUE_DATA(q, <span class="type">uv__io_t</span>, pending_queue);</span><br><span class="line">    w-&gt;cb(loop, w, POLLOUT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单, 就是把<code>pending_queue</code>所有io事件取出来, 并调用相关回调. pending queue的加入等以后再说.</p>
<h3 id="uv-run-idle-uv-run-prepare以及后面的uv-run-check"><a href="#uv-run-idle-uv-run-prepare以及后面的uv-run-check" class="headerlink" title="uv__run_idle,  uv__run_prepare以及后面的uv__run_check"></a>uv__run_idle,  uv__run_prepare以及后面的uv__run_check</h3><p>这三个调用分别操作idle_handles, prepare_handles以及check_handles. 这三种handle都是用下面的宏来操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> uv_#<span class="meta">#name##_start(uv_##name##_t* handle, uv_##name##_cb cb) &#123;           \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (uv__is_active(handle)) return 0;                                      \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (cb == NULL) return -EINVAL;                                           \</span></span><br><span class="line"><span class="meta">  QUEUE_INSERT_HEAD(&amp;handle-&gt;loop-&gt;name##_handles, &amp;handle-&gt;queue);         \</span></span><br><span class="line"><span class="meta">  handle-&gt;name##_cb = cb;                                                   \</span></span><br><span class="line"><span class="meta">  uv__handle_start(handle);                                                 \</span></span><br><span class="line"><span class="meta">  return 0;                                                                 \</span></span><br><span class="line"><span class="meta">&#125;                                                                           \</span></span><br><span class="line"><span class="meta">                                                                            \</span></span><br><span class="line"><span class="meta">int uv_##name##_stop(uv_##name##_t* handle) &#123;                               \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (!uv__is_active(handle)) return 0;                                     \</span></span><br><span class="line"><span class="meta">  QUEUE_REMOVE(&amp;handle-&gt;queue);                                             \</span></span><br><span class="line"><span class="meta">  uv__handle_stop(handle);                                                  \</span></span><br><span class="line"><span class="meta">  return 0;                                                                 \</span></span><br><span class="line"><span class="meta">&#125;                                                                           \</span></span><br><span class="line"><span class="meta">                                                                            \</span></span><br><span class="line"><span class="meta">void uv__run_##name(uv_loop_t* loop) &#123;                                      \</span></span><br><span class="line"><span class="meta">  uv_##name##_t* h;                                                         \</span></span><br><span class="line"><span class="meta">  QUEUE queue;                                                              \</span></span><br><span class="line"><span class="meta">  QUEUE* q;                                                                 \</span></span><br><span class="line"><span class="meta">  QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;queue);                                \</span></span><br><span class="line"><span class="meta">  while (!QUEUE_EMPTY(&amp;queue)) &#123;                                            \</span></span><br><span class="line"><span class="meta">    q = QUEUE_HEAD(&amp;queue);                                                 \</span></span><br><span class="line"><span class="meta">    h = QUEUE_DATA(q, uv_##name##_t, queue);                                \</span></span><br><span class="line"><span class="meta">    QUEUE_REMOVE(q);                                                        \</span></span><br><span class="line"><span class="meta">    QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q);                            \</span></span><br><span class="line"><span class="meta">    h-&gt;name##_cb(h);                                                        \</span></span><br><span class="line"><span class="meta">  &#125;                                                                         \</span></span><br><span class="line"><span class="meta">&#125;                                                                           \</span></span><br><span class="line"><span class="meta">                                                                            \</span></span><br><span class="line"><span class="meta">void uv__##name##_close(uv_##name##_t* handle) &#123;                            \</span></span><br><span class="line"><span class="meta">  uv_##name##_stop(handle);                                                 \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看出这三种操作很简单.start就是把 handle加入到相应的queue, 然后调用<code>uv__handle_start</code>, stop就是将handle移动出来然后调用<code>uv__handle_stop</code>, run就是就是依次执行queue上面所有handle的回调.</p>
<h3 id="uv-backend-timeout"><a href="#uv-backend-timeout" class="headerlink" title="uv_backend_timeout"></a>uv_backend_timeout</h3><p>这个函数比较简单, 就是计算下一次poll的超时时间. 当然, 这个函数只在pending队列被执行前是空的(这样就保证</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_backend_timeout</span><span class="params">(<span class="type">const</span> <span class="type">uv_loop_t</span>* loop)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!uv__has_active_handles(loop) &amp;&amp; !uv__has_active_reqs(loop))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;loop-&gt;idle_handles))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;closing_handles)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uv__next_timeout(loop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到, 当 event loop确认自己还有事情要做的时候, 就会返回0, 表示下次poll是非阻塞的.<br><code>uv__next_timeout</code>比较简单, 就是从 <code>timer_heap</code>中得到最小超时的时间, 从而计算出下一次的超时时间, 如果 <code>timer_heap</code>是空, 表示下一次poll可以无限制的等待.</p>
<h3 id="uv-io-poll"><a href="#uv-io-poll" class="headerlink" title="uv__io_poll"></a>uv__io_poll</h3><p><code>uv__io_poll</code>是整个 event loop中的最关键, 这部份内容较多, 我们下一篇来讲.</p>
<h3 id="uv-run-closing-handles"><a href="#uv-run-closing-handles" class="headerlink" title="uv__run_closing_handles"></a>uv__run_closing_handles</h3><p>这个函数用来关闭所有的待关闭的 handles, 通过调用 <code>uv__finish_close</code>来实现. 这个函数会关闭 handle并调用对应的回调函数, 这部份比较杂, 如果后面有机会再讲讲.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">uv__run_closing_handles</span><span class="params">(<span class="type">uv_loop_t</span>* loop)</span> &#123;</span><br><span class="line">  <span class="type">uv_handle_t</span>* p;</span><br><span class="line">  <span class="type">uv_handle_t</span>* q;</span><br><span class="line"></span><br><span class="line">  p = loop-&gt;closing_handles;</span><br><span class="line">  loop-&gt;closing_handles = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p) &#123;</span><br><span class="line">    q = p-&gt;next_closing;</span><br><span class="line">    uv__finish_close(p);</span><br><span class="line">    p = q;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个 event loop后续部分就比较简单了, 就不再说了. 至此我们就看完了. 如果你把代码和官方的文档中的流程图对应一下, 就会发现是一致的.<br>下一篇, 我们会来看看 libuv是如何进行 poll操作的.</p>
]]></content>
      <categories>
        <category>libuv</category>
      </categories>
      <tags>
        <tag>libuv</tag>
      </tags>
  </entry>
  <entry>
    <title>libuv 源码阅读(3) - poll过程</title>
    <url>/2017/09/01/0ca8e8961f7e/</url>
    <content><![CDATA[<p>by gngshn <a href="mailto:&#x67;&#110;&#x67;&#x73;&#x68;&#110;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;">&#x67;&#110;&#x67;&#x73;&#x68;&#110;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;</a></p>
<p>上一篇, 我们将到libuv的event loop过程, 其中留了个悬念, 下面我们来解除这个悬念, 直接上函数, 这个函数特别长, 我们依旧直接在函数里面写注释把~</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uv__io_poll</span><span class="params">(<span class="type">uv_loop_t</span>* loop, <span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">  <span class="comment">/* A bug in kernels &lt; 2.6.37 makes timeouts larger than ~30 minutes</span></span><br><span class="line"><span class="comment">   * effectively infinite on 32 bits architectures.  To avoid blocking</span></span><br><span class="line"><span class="comment">   * indefinitely, we cap the timeout and poll again if necessary.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Note that &quot;30 minutes&quot; is a simplification because it depends on</span></span><br><span class="line"><span class="comment">   * the value of CONFIG_HZ.  The magic constant assumes CONFIG_HZ=1200,</span></span><br><span class="line"><span class="comment">   * that being the largest value I have seen in the wild (and only once.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> max_safe_timeout = <span class="number">1789569</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> no_epoll_pwait;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> no_epoll_wait;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__epoll_event</span> <span class="title">events</span>[1024];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__epoll_event</span>* <span class="title">pe</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__epoll_event</span> <span class="title">e</span>;</span></span><br><span class="line">  <span class="type">int</span> real_timeout;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  <span class="type">uv__io_t</span>* w;</span><br><span class="line">  <span class="type">sigset_t</span> sigset;</span><br><span class="line">  <span class="type">uint64_t</span> sigmask;</span><br><span class="line">  <span class="type">uint64_t</span> base;</span><br><span class="line">  <span class="type">int</span> have_signals;</span><br><span class="line">  <span class="type">int</span> nevents;</span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">  <span class="type">int</span> nfds;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">int</span> op;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果watcher_queue是空, 表明没有时间要等待, 可以直接返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;nfds == <span class="number">0</span>) &#123;</span><br><span class="line">    assert(QUEUE_EMPTY(&amp;loop-&gt;watcher_queue));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 以此在`watcher_queue`中取出事件 */</span></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;loop-&gt;watcher_queue)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;loop-&gt;watcher_queue);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line"></span><br><span class="line">    w = QUEUE_DATA(q, <span class="type">uv__io_t</span>, watcher_queue);</span><br><span class="line">    assert(w-&gt;pevents != <span class="number">0</span>);</span><br><span class="line">    assert(w-&gt;fd &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(w-&gt;fd &lt; (<span class="type">int</span>) loop-&gt;nwatchers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把需要监听的文件的事件加入/修改到epoll中 */</span></span><br><span class="line">    e.events = w-&gt;pevents;</span><br><span class="line">    e.data = w-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w-&gt;events == <span class="number">0</span>)</span><br><span class="line">      op = UV__EPOLL_CTL_ADD;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      op = UV__EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX Future optimization: do EPOLL_CTL_MOD lazily if we stop watching</span></span><br><span class="line"><span class="comment">     * events, skip the syscall and squelch the events after epoll_wait().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (uv__epoll_ctl(loop-&gt;backend_fd, op, w-&gt;fd, &amp;e)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno != EEXIST)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">      assert(op == UV__EPOLL_CTL_ADD);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We&#x27;ve reactivated a file descriptor that&#x27;s been watched before. */</span></span><br><span class="line">      <span class="keyword">if</span> (uv__epoll_ctl(loop-&gt;backend_fd, UV__EPOLL_CTL_MOD, w-&gt;fd, &amp;e))</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w-&gt;events = w-&gt;pevents;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 对SIGPROF的屏蔽处理, 注意这里用到了两种方式, 取决于系统的支持程度epoll_pwait/pthread_sigmask */</span></span><br><span class="line">  sigmask = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;flags &amp; UV_LOOP_BLOCK_SIGPROF) &#123;</span><br><span class="line">    sigemptyset(&amp;sigset);</span><br><span class="line">    sigaddset(&amp;sigset, SIGPROF);</span><br><span class="line">    sigmask |= <span class="number">1</span> &lt;&lt; (SIGPROF - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(timeout &gt;= <span class="number">-1</span>);</span><br><span class="line">  base = loop-&gt;time;</span><br><span class="line">  count = <span class="number">48</span>; <span class="comment">/* Benchmarks suggest this gives the best throughput. */</span></span><br><span class="line">  real_timeout = timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">/* See the comment for max_safe_timeout for an explanation of why</span></span><br><span class="line"><span class="comment">     * this is necessary.  Executive summary: kernel bug workaround.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 见上面的英文注释 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="type">int32_t</span>) == <span class="keyword">sizeof</span>(<span class="type">long</span>) &amp;&amp; timeout &gt;= max_safe_timeout)</span><br><span class="line">      timeout = max_safe_timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigmask != <span class="number">0</span> &amp;&amp; no_epoll_pwait != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> (pthread_sigmask(SIG_BLOCK, &amp;sigset, <span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进行epoll调用, 等待事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (no_epoll_wait != <span class="number">0</span> || (sigmask != <span class="number">0</span> &amp;&amp; no_epoll_pwait == <span class="number">0</span>)) &#123;</span><br><span class="line">      nfds = uv__epoll_pwait(loop-&gt;backend_fd,</span><br><span class="line">                             events,</span><br><span class="line">                             ARRAY_SIZE(events),</span><br><span class="line">                             timeout,</span><br><span class="line">                             sigmask);</span><br><span class="line">      <span class="keyword">if</span> (nfds == <span class="number">-1</span> &amp;&amp; errno == ENOSYS)</span><br><span class="line">        no_epoll_pwait = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nfds = uv__epoll_wait(loop-&gt;backend_fd,</span><br><span class="line">                            events,</span><br><span class="line">                            ARRAY_SIZE(events),</span><br><span class="line">                            timeout);</span><br><span class="line">      <span class="keyword">if</span> (nfds == <span class="number">-1</span> &amp;&amp; errno == ENOSYS)</span><br><span class="line">        no_epoll_wait = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigmask != <span class="number">0</span> &amp;&amp; no_epoll_pwait != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> (pthread_sigmask(SIG_UNBLOCK, &amp;sigset, <span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update loop-&gt;time unconditionally. It&#x27;s tempting to skip the update when</span></span><br><span class="line"><span class="comment">     * timeout == 0 (i.e. non-blocking poll) but there is no guarantee that the</span></span><br><span class="line"><span class="comment">     * operating system didn&#x27;t reschedule our process while in the syscall.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 见上面英文注释 */</span></span><br><span class="line">    SAVE_ERRNO(uv__update_time(loop));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">0</span>) &#123;</span><br><span class="line">      assert(timeout != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We may have been inside the system call for longer than |timeout|</span></span><br><span class="line"><span class="comment">       * milliseconds so we need to update the timestamp to avoid drift.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">goto</span> update_timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == ENOSYS) &#123;</span><br><span class="line">        <span class="comment">/* epoll_wait() or epoll_pwait() failed, try the other system call. */</span></span><br><span class="line">        assert(no_epoll_wait == <span class="number">0</span> || no_epoll_pwait == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeout == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Interrupted by a signal. Update timeout and poll again. */</span></span><br><span class="line">      <span class="keyword">goto</span> update_timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    have_signals = <span class="number">0</span>;</span><br><span class="line">    nevents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把所有poll到的事件描述信息放在数组的最后两个元素 */</span></span><br><span class="line">    assert(loop-&gt;watchers != <span class="literal">NULL</span>);</span><br><span class="line">    loop-&gt;watchers[loop-&gt;nwatchers] = (<span class="type">void</span>*) events;</span><br><span class="line">    loop-&gt;watchers[loop-&gt;nwatchers + <span class="number">1</span>] = (<span class="type">void</span>*) (<span class="type">uintptr_t</span>) nfds;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">      pe = events + i;</span><br><span class="line">      fd = pe-&gt;data;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip invalidated events, see uv__platform_invalidate_fd */</span></span><br><span class="line">      <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      assert(fd &gt;= <span class="number">0</span>);</span><br><span class="line">      assert((<span class="type">unsigned</span>) fd &lt; loop-&gt;nwatchers);</span><br><span class="line"></span><br><span class="line">      w = loop-&gt;watchers[fd];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (w == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* File descriptor that we&#x27;ve stopped watching, disarm it.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Ignore all errors because we may be racing with another thread</span></span><br><span class="line"><span class="comment">         * when the file descriptor is closed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        uv__epoll_ctl(loop-&gt;backend_fd, UV__EPOLL_CTL_DEL, fd, pe);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Give users only events they&#x27;re interested in. Prevents spurious</span></span><br><span class="line"><span class="comment">       * callbacks when previous callback invocation in this loop has stopped</span></span><br><span class="line"><span class="comment">       * the current watcher. Also, filters out events that users has not</span></span><br><span class="line"><span class="comment">       * requested us to watch.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      pe-&gt;events &amp;= w-&gt;pevents | POLLERR | POLLHUP;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Work around an epoll quirk where it sometimes reports just the</span></span><br><span class="line"><span class="comment">       * EPOLLERR or EPOLLHUP event.  In order to force the event loop to</span></span><br><span class="line"><span class="comment">       * move forward, we merge in the read/write events that the watcher</span></span><br><span class="line"><span class="comment">       * is interested in; uv__read() and uv__write() will then deal with</span></span><br><span class="line"><span class="comment">       * the error or hangup in the usual fashion.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * Note to self: happens when epoll reports EPOLLIN|EPOLLHUP, the user</span></span><br><span class="line"><span class="comment">       * reads the available data, calls uv_read_stop(), then sometime later</span></span><br><span class="line"><span class="comment">       * calls uv_read_start() again.  By then, libuv has forgotten about the</span></span><br><span class="line"><span class="comment">       * hangup and the kernel won&#x27;t report EPOLLIN again because there&#x27;s</span></span><br><span class="line"><span class="comment">       * nothing left to read.  If anything, libuv is to blame here.  The</span></span><br><span class="line"><span class="comment">       * current hack is just a quick bandaid; to properly fix it, libuv</span></span><br><span class="line"><span class="comment">       * needs to remember the error/hangup event.  We should get that for</span></span><br><span class="line"><span class="comment">       * free when we switch over to edge-triggered I/O.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (pe-&gt;events == POLLERR || pe-&gt;events == POLLHUP)</span><br><span class="line">        pe-&gt;events |= w-&gt;pevents &amp; (POLLIN | POLLOUT | UV__POLLPRI);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pe-&gt;events != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Run signal watchers last.  This also affects child process watchers</span></span><br><span class="line"><span class="comment">         * because those are implemented in terms of signal watchers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/* 调用回调, 对于信号处理放在后面统一执行 */</span></span><br><span class="line">        <span class="keyword">if</span> (w == &amp;loop-&gt;signal_io_watcher)</span><br><span class="line">          have_signals = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          w-&gt;cb(loop, w, pe-&gt;events);</span><br><span class="line"></span><br><span class="line">        nevents++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行信号处理程序 根据uv_loop_init看出, 这个程序是uv__signal_event, 由uv__io_init(&amp;loop-&gt;signal_io_watcher, uv__signal_event, loop-&gt;signal_pipefd[0]) 指定, 后面我们再来看这个函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (have_signals != <span class="number">0</span>)</span><br><span class="line">      loop-&gt;signal_io_watcher.cb(loop, &amp;loop-&gt;signal_io_watcher, POLLIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除两个描述符 */</span></span><br><span class="line">    loop-&gt;watchers[loop-&gt;nwatchers] = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;watchers[loop-&gt;nwatchers + <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_signals != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;  <span class="comment">/* Event loop should cycle now so don&#x27;t poll again. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nevents != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nfds == ARRAY_SIZE(events) &amp;&amp; --count != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Poll for more events but don&#x27;t block this time. */</span></span><br><span class="line">        timeout = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">update_timeout:</span><br><span class="line">    assert(timeout &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    real_timeout -= (loop-&gt;time - base);</span><br><span class="line">    <span class="keyword">if</span> (real_timeout &lt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    timeout = real_timeout;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过看libuv source code中的注释, 可以很快的理解这段代码到底做了写什么. 主要是加入待处理的事件到epoll, 然后poll, 发生事件就调用相关的回调函数. 另外, 为了规避BUG, 引入<code>max_safe_timeout</code>, 为了吞吐量, 引入poll的count.<br><br>我们最后来看看信号处理函数干了写啥:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">uv__signal_event</span><span class="params">(<span class="type">uv_loop_t</span>* loop,</span></span><br><span class="line"><span class="params">                             <span class="type">uv__io_t</span>* w,</span></span><br><span class="line"><span class="params">                             <span class="type">unsigned</span> <span class="type">int</span> events)</span> &#123;</span><br><span class="line">  <span class="type">uv__signal_msg_t</span>* msg;</span><br><span class="line">  <span class="type">uv_signal_t</span>* handle;</span><br><span class="line">  <span class="type">char</span> buf[<span class="keyword">sizeof</span>(<span class="type">uv__signal_msg_t</span>) * <span class="number">32</span>];</span><br><span class="line">  <span class="type">size_t</span> bytes, end, i;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">  bytes = <span class="number">0</span>;</span><br><span class="line">  end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    r = read(loop-&gt;signal_pipefd[<span class="number">0</span>], buf + bytes, <span class="keyword">sizeof</span>(buf) - bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">-1</span> &amp;&amp; errno == EINTR)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">-1</span> &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)) &#123;</span><br><span class="line">      <span class="comment">/* If there are bytes in the buffer already (which really is extremely</span></span><br><span class="line"><span class="comment">       * unlikely if possible at all) we can&#x27;t exit the function here. We&#x27;ll</span></span><br><span class="line"><span class="comment">       * spin until more bytes are read instead.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (bytes &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Otherwise, there was nothing there. */</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Other errors really should never happen. */</span></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">-1</span>)</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    bytes += r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* `end` is rounded down to a multiple of sizeof(uv__signal_msg_t). */</span></span><br><span class="line">    end = (bytes / <span class="keyword">sizeof</span>(<span class="type">uv__signal_msg_t</span>)) * <span class="keyword">sizeof</span>(<span class="type">uv__signal_msg_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; end; i += <span class="keyword">sizeof</span>(<span class="type">uv__signal_msg_t</span>)) &#123;</span><br><span class="line">      msg = (<span class="type">uv__signal_msg_t</span>*) (buf + i);</span><br><span class="line">      handle = msg-&gt;handle;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (msg-&gt;signum == handle-&gt;signum) &#123;</span><br><span class="line">        assert(!(handle-&gt;flags &amp; UV_CLOSING));</span><br><span class="line">        handle-&gt;signal_cb(handle, handle-&gt;signum);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      handle-&gt;dispatched_signals++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (handle-&gt;flags &amp; UV__SIGNAL_ONE_SHOT)</span><br><span class="line">        uv__signal_stop(handle);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If uv_close was called while there were caught signals that were not</span></span><br><span class="line"><span class="comment">       * yet dispatched, the uv__finish_close was deferred. Make close pending</span></span><br><span class="line"><span class="comment">       * now if this has happened.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> ((handle-&gt;flags &amp; UV_CLOSING) &amp;&amp;</span><br><span class="line">          (handle-&gt;caught_signals == handle-&gt;dispatched_signals)) &#123;</span><br><span class="line">        uv__make_close_pending((<span class="type">uv_handle_t</span>*) handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes -= end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If there are any &quot;partial&quot; messages left, move them to the start of the</span></span><br><span class="line"><span class="comment">     * the buffer, and spin. This should not happen.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (bytes) &#123;</span><br><span class="line">      memmove(buf, buf + end, bytes);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (end == <span class="keyword">sizeof</span> buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数从之前讲过的的<code>signal_pipefd[0]</code>读取异常处理程序(<code>uv__signal_handler</code>)发送过来的消息(<code>uv__signal_msg_t</code>), 这个消息包括相应的handle的signum, 调用handle的回调函数, 并进行一些回收的处理. 具体细节可以追踪函数来看, 这里就不去细说了.<br><br>到此我们就看完了libuv的event loop.</p>
]]></content>
      <categories>
        <category>libuv</category>
      </categories>
      <tags>
        <tag>libuv</tag>
      </tags>
  </entry>
  <entry>
    <title>libuv 源码分析(4) - libuv的工作队列(线程池)</title>
    <url>/2017/09/01/3f20ec24f2fd/</url>
    <content><![CDATA[<p>by gngshn <a href="mailto:&#103;&#x6e;&#103;&#115;&#x68;&#110;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;">&#103;&#x6e;&#103;&#115;&#x68;&#110;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;</a></p>
<p>libuv通过<code>uv_work_queue</code>来交付任务给工作队列的, 这个api也是libuv实现文件异步操作的基础:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UV_EXTERN <span class="type">int</span> <span class="title function_">uv_queue_work</span><span class="params">(<span class="type">uv_loop_t</span>* loop,</span></span><br><span class="line"><span class="params">                            <span class="type">uv_work_t</span>* req,</span></span><br><span class="line"><span class="params">                            uv_work_cb work_cb,</span></span><br><span class="line"><span class="params">                            uv_after_work_cb after_work_cb)</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>这个工作队列实现方式就是把任务(work_cb)交给线程池来处理, 并且任务完成后, 调用相应的回调函数(after_work_cb).<br><br>我们先来看看这个函数的实现:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_queue_work</span><span class="params">(<span class="type">uv_loop_t</span>* loop,</span></span><br><span class="line"><span class="params">                  <span class="type">uv_work_t</span>* req,</span></span><br><span class="line"><span class="params">                  uv_work_cb work_cb,</span></span><br><span class="line"><span class="params">                  uv_after_work_cb after_work_cb)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (work_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  uv__req_init(loop, req, UV_WORK);</span><br><span class="line">  req-&gt;loop = loop;</span><br><span class="line">  req-&gt;work_cb = work_cb;</span><br><span class="line">  req-&gt;after_work_cb = after_work_cb;</span><br><span class="line">  uv__work_submit(loop, &amp;req-&gt;work_req, uv__queue_work, uv__queue_done);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到函数首先初始化这个请求(req), 然后就调用<code>uv__work_submit</code>完成剩余的工作.<br><br>下面我们主要就来分析一下<code>uv__work_submit</code>的操作过程. 看看libuv是如何调用<code>work_cb</code>来完成任务并调用到<code>after_work_cb</code>回调函数的.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uv__work_submit</span><span class="params">(<span class="type">uv_loop_t</span>* loop,</span></span><br><span class="line"><span class="params">                     <span class="keyword">struct</span> uv__work* w,</span></span><br><span class="line"><span class="params">                     <span class="type">void</span> (*work)(<span class="keyword">struct</span> uv__work* w),</span></span><br><span class="line"><span class="params">                     <span class="type">void</span> (*done)(<span class="keyword">struct</span> uv__work* w, <span class="type">int</span> status))</span> &#123;</span><br><span class="line">  uv_once(&amp;once, init_once);</span><br><span class="line">  w-&gt;loop = loop;</span><br><span class="line">  w-&gt;work = work;</span><br><span class="line">  w-&gt;done = done;</span><br><span class="line">  post(&amp;w-&gt;wq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uv_once(&amp;once, init_once);</code>用来初始化libuv的线程池, 只会被调用一次. 线程池中的线程都是执行这样一个函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__work</span>* <span class="title">w</span>;</span></span><br><span class="line">  QUEUE* q;</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>) arg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    uv_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (QUEUE_EMPTY(&amp;wq)) &#123;</span><br><span class="line">      idle_threads += <span class="number">1</span>;</span><br><span class="line">      uv_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">      idle_threads -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到每个线程都是等待在<code>uv_cond_wait(&amp;cond, &amp;mutex);</code>.<br><br>初始化完成后, 会调用<code>post(&amp;w-&gt;wq)</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">post</span><span class="params">(QUEUE* q)</span> &#123;</span><br><span class="line">  uv_mutex_lock(&amp;mutex);</span><br><span class="line">  QUEUE_INSERT_TAIL(&amp;wq, q);</span><br><span class="line">  <span class="keyword">if</span> (idle_threads &gt; <span class="number">0</span>)</span><br><span class="line">    uv_cond_signal(&amp;cond);</span><br><span class="line">  uv_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>post(&amp;w-&gt;wq)</code>就是把<code>w</code>挂到全局的<code>wq</code>上面, 然后调用<code>uv_cond_signal</code>, 这就会唤醒一个前面的正在等待的线程来处理这个任务, 一个线程唤醒后, 就会执行work函数的后续部分.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__work</span>* <span class="title">w</span>;</span></span><br><span class="line">  QUEUE* q;</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>) arg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    uv_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (QUEUE_EMPTY(&amp;wq)) &#123;</span><br><span class="line">      idle_threads += <span class="number">1</span>;</span><br><span class="line">      uv_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">      idle_threads -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q = QUEUE_HEAD(&amp;wq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q == &amp;exit_message)</span><br><span class="line">      uv_cond_signal(&amp;cond);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      QUEUE_REMOVE(q);</span><br><span class="line">      QUEUE_INIT(q);  <span class="comment">/* Signal uv_cancel() that the work req is</span></span><br><span class="line"><span class="comment">                             executing. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uv_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q == &amp;exit_message)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    w = QUEUE_DATA(q, <span class="keyword">struct</span> uv__work, wq);</span><br><span class="line">    w-&gt;work(w);</span><br><span class="line"></span><br><span class="line">    uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br><span class="line">    w-&gt;work = <span class="literal">NULL</span>;  <span class="comment">/* Signal uv_cancel() that the work req is done</span></span><br><span class="line"><span class="comment">                        executing. */</span></span><br><span class="line">    QUEUE_INSERT_TAIL(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq);</span><br><span class="line">    uv_async_send(&amp;w-&gt;loop-&gt;wq_async);</span><br><span class="line">    uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程先取出一个链表的元素q.<br><br><code>exit_message</code>相关的操作是用来退出所有线程的, 在libuv退出时, <code>post(&amp;exit_message);</code>被调用, 这会让libuv的所有线程都退出.<br><br>如果没有<code>exit_message</code>, 线程正常往后执行. 先把<code>q</code>从<code>wq</code>链表中删除, 然后调用<code>w-&gt;work</code>(就是最开始的<code>work_cb</code>, 相当于执行工作), 然后把w放到<code>loop-&gt;wq</code>中并调用<code>uv_async_send</code>向event loop发送信号. event loop会注意这个信号并作出相应的处理.<br><br>为了弄清楚event loop是如何注意到这个信号的, 我们先来看看<code>uv_async_send</code>都干了什么</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_async_send</span><span class="params">(<span class="type">uv_async_t</span>* handle)</span> &#123;</span><br><span class="line">  <span class="comment">/* Do a cheap read first. */</span></span><br><span class="line">  <span class="keyword">if</span> (ACCESS_ONCE(<span class="type">int</span>, handle-&gt;pending) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cmpxchgi(&amp;handle-&gt;pending, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    uv__async_send(handle-&gt;loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里async事件在还没有被处理时(penging&#x3D;1)多次发送也只有一次生效<br><br>判断<code>handle-&gt;pending</code>如果是1, 表示已经发送过并且还没处理, 所以直接返回.<br><br>如果是0就表明没有pending事件, 原子的设置<code>pending</code>为1, 并调用<code>uv__async_send</code>, 这个函数会往<code>loop-&gt;async_io_watcher.fd</code>(一个eventfd)里面写入’\n’, 从而event_loop会在epoll中发现. 发现后会调用相应的回调函数, 那么回调函数是什么呢?<br><br>在<code>uv_loop_init</code>中会调用<code>uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done)</code>来指定回调函数是<code>uv__work_done</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_async_init</span><span class="params">(<span class="type">uv_loop_t</span>* loop, <span class="type">uv_async_t</span>* handle, uv_async_cb async_cb)</span> &#123;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  err = uv__async_start(loop);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  uv__handle_init(loop, (<span class="type">uv_handle_t</span>*)handle, UV_ASYNC);</span><br><span class="line">  handle-&gt;async_cb = async_cb;</span><br><span class="line">  handle-&gt;pending = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, &amp;handle-&gt;<span class="built_in">queue</span>);</span><br><span class="line">  uv__handle_start(handle);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uv__async_start</code>中创建eventfd, 并将其POLLIN事件加入event loop, 事件发生时会调用<code>uv__async_io</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uv__io_init(&amp;loop-&gt;async_io_watcher, uv__async_io, pipefd[<span class="number">0</span>]);</span><br><span class="line">uv__io_start(loop, &amp;loop-&gt;async_io_watcher, POLLIN);</span><br></pre></td></tr></table></figure>
<p>然后把handle初始化并配置async_cb和pending加入到event loop的async_handles中, 并启动handle.<br><br>事件发生后调用<code>uv__async_io</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">uv__async_io</span><span class="params">(<span class="type">uv_loop_t</span>* loop, <span class="type">uv__io_t</span>* w, <span class="type">unsigned</span> <span class="type">int</span> events)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">  <span class="type">ssize_t</span> r;</span><br><span class="line">  QUEUE <span class="built_in">queue</span>;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  <span class="type">uv_async_t</span>* h;</span><br><span class="line"></span><br><span class="line">  assert(w == &amp;loop-&gt;async_io_watcher);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    r = read(w-&gt;fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">sizeof</span>(buf))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;async_handles, &amp;<span class="built_in">queue</span>);</span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;<span class="built_in">queue</span>)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    h = QUEUE_DATA(q, <span class="type">uv_async_t</span>, <span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmpxchgi(&amp;h-&gt;pending, <span class="number">1</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;async_cb == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    h-&gt;async_cb(h);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个函数先把eventfd的内容读空, 然后一次对async_handles中的元素判断其pending, 如果为1就原子的将其至0, 这也表示handle有待处理的异步通知, 因此就会调用<code>h-&gt;async_cb(h)</code><br><br>前面说过(<code>uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done)</code>)对于我们的线程池来说这个回调是<code>uv__work_done</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uv__work_done</span><span class="params">(<span class="type">uv_async_t</span>* handle)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__work</span>* <span class="title">w</span>;</span></span><br><span class="line">  <span class="type">uv_loop_t</span>* loop;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE wq;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  loop = container_of(handle, <span class="type">uv_loop_t</span>, wq_async);</span><br><span class="line">  uv_mutex_lock(&amp;loop-&gt;wq_mutex);</span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;wq, &amp;wq);</span><br><span class="line">  uv_mutex_unlock(&amp;loop-&gt;wq_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;wq)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;wq);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line"></span><br><span class="line">    w = container_of(q, <span class="keyword">struct</span> uv__work, wq);</span><br><span class="line">    err = (w-&gt;work == uv__cancelled) ? UV_ECANCELED : <span class="number">0</span>;</span><br><span class="line">    w-&gt;done(w, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数把<code>loop-&gt;wq</code>的元素挨个删除并调用<code>done</code>回调函数. 这个<code>done</code>回调函数就是我们前面说的<code>after_work_cb</code>回调.<br>至此, libuv的工作队列的实现就说完了.</p>
]]></content>
      <categories>
        <category>libuv</category>
      </categories>
      <tags>
        <tag>libuv</tag>
      </tags>
  </entry>
  <entry>
    <title>libuv 源码分析(5) - 文件操作流程</title>
    <url>/2017/09/01/b196adf5da31/</url>
    <content><![CDATA[<p>by gngshn <a href="mailto:&#x67;&#x6e;&#103;&#x73;&#x68;&#110;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#x6e;&#103;&#x73;&#x68;&#110;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a></p>
<p>上一篇, 我们讲到了libuv的工作队列, 这一篇我们讲到的文件操作刚好就用到了工作队列. 刚好复习一下.<br>先来看一段libuv文件操作的代码</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">on_read</span><span class="params">(<span class="type">uv_fs_t</span> *req)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uv_fs_t</span> open_req;</span><br><span class="line"><span class="type">uv_fs_t</span> read_req;</span><br><span class="line"><span class="type">uv_fs_t</span> write_req;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uv_buf_t</span> iov;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">on_write</span><span class="params">(<span class="type">uv_fs_t</span> *req)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Write error: %s\n&quot;</span>, uv_strerror((<span class="type">int</span>)req-&gt;result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        uv_fs_read(uv_default_loop(), &amp;read_req, open_req.result, &amp;iov, <span class="number">1</span>, <span class="number">-1</span>, on_read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">on_read</span><span class="params">(<span class="type">uv_fs_t</span> *req)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Read error: %s\n&quot;</span>, uv_strerror(req-&gt;result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req-&gt;result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">uv_fs_t</span> close_req;</span><br><span class="line">        <span class="comment">// synchronous</span></span><br><span class="line">        uv_fs_close(uv_default_loop(), &amp;close_req, open_req.result, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req-&gt;result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        iov.len = req-&gt;result;</span><br><span class="line">        uv_fs_write(uv_default_loop(), &amp;write_req, <span class="number">1</span>, &amp;iov, <span class="number">1</span>, <span class="number">-1</span>, on_write);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">on_open</span><span class="params">(<span class="type">uv_fs_t</span> *req)</span> &#123;</span><br><span class="line">    <span class="comment">// The request passed to the callback is the same as the one the call setup</span></span><br><span class="line">    <span class="comment">// function was passed.</span></span><br><span class="line">    assert(req == &amp;open_req);</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        iov = uv_buf_init(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        uv_fs_read(uv_default_loop(), &amp;read_req, req-&gt;result,</span><br><span class="line">                   &amp;iov, <span class="number">1</span>, <span class="number">-1</span>, on_read);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error opening file: %s\n&quot;</span>, uv_strerror((<span class="type">int</span>)req-&gt;result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    uv_fs_open(uv_default_loop(), &amp;open_req, argv[<span class="number">1</span>], O_RDONLY, <span class="number">0</span>, on_open);</span><br><span class="line">    uv_run(uv_default_loop(), UV_RUN_DEFAULT);</span><br><span class="line"></span><br><span class="line">    uv_fs_req_cleanup(&amp;open_req);</span><br><span class="line">    uv_fs_req_cleanup(&amp;read_req);</span><br><span class="line">    uv_fs_req_cleanup(&amp;write_req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到, 首先调用<code>uv_fs_open</code>, 然后在open的回调函数<code>on_open</code>中调用<code>uv_fs_read</code>读取文件, 之后在read的回调函数<code>on_read</code>中调用<code>uv_fs_close</code>(同步)或<code>uv_fs_write</code>(异步), 在write的回调函数中继续调用<code>uv_fs_read</code>从事时间将文件全部都出来然后写入到标准输出(1)中.</p>
<p>下面我们就一步一步跟踪libuv的api来看看libuv是如何处理文件操作的.</p>
<h3 id="uv-fs-open"><a href="#uv-fs-open" class="headerlink" title="uv_fs_open"></a>uv_fs_open</h3><p><code>uv_fs_open</code>的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_fs_open</span><span class="params">(<span class="type">uv_loop_t</span>* loop,</span></span><br><span class="line"><span class="params">               <span class="type">uv_fs_t</span>* req,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">char</span>* path,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">               uv_fs_cb cb)</span> &#123;</span><br><span class="line">  INIT(OPEN);</span><br><span class="line">  PATH;</span><br><span class="line">  req-&gt;flags = flags;</span><br><span class="line">  req-&gt;mode = mode;</span><br><span class="line">  POST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>INIT</code>, <code>PATH</code>, <code>POST</code>宏是为了减少重复代码, 后面将看见它在多个地方都有用到<br>先来看看<code>INIT</code>宏:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT(subtype)                                                         \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                        \</span></span><br><span class="line"><span class="meta">    req-&gt;type = UV_FS;                                                        \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (cb != NULL)                                                           \</span></span><br><span class="line"><span class="meta">      uv__req_init(loop, req, UV_FS);                                         \</span></span><br><span class="line"><span class="meta">    req-&gt;fs_type = UV_FS_ ## subtype;                                         \</span></span><br><span class="line"><span class="meta">    req-&gt;result = 0;                                                          \</span></span><br><span class="line"><span class="meta">    req-&gt;ptr = NULL;                                                          \</span></span><br><span class="line"><span class="meta">    req-&gt;loop = loop;                                                         \</span></span><br><span class="line"><span class="meta">    req-&gt;path = NULL;                                                         \</span></span><br><span class="line"><span class="meta">    req-&gt;new_path = NULL;                                                     \</span></span><br><span class="line"><span class="meta">    req-&gt;cb = cb;                                                             \</span></span><br><span class="line"><span class="meta">  &#125;                                                                           \</span></span><br><span class="line"><span class="meta">  while (0)</span></span><br></pre></td></tr></table></figure>
<p>初始化req的属性, 值得注意的是, 当cb不为NULL(表示异步操作时), 需要调用<code>uv__req_init</code>把req注册到loop中.<br><code>PATH</code>宏主要是处理<code>path</code>变量是否需要复制一份, 因为如果在异步回调时, path是否在存在都不知道了.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PATH                                                                  \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                        \</span></span><br><span class="line"><span class="meta">    assert(path != NULL);                                                     \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (cb == NULL) &#123;                                                         \</span></span><br><span class="line"><span class="meta">      req-&gt;path = path;                                                       \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> &#123;                                                                  \</span></span><br><span class="line"><span class="meta">      req-&gt;path = uv__strdup(path);                                           \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (req-&gt;path == NULL) &#123;                                                \</span></span><br><span class="line"><span class="meta">        uv__req_unregister(loop, req);                                        \</span></span><br><span class="line"><span class="meta">        return -ENOMEM;                                                       \</span></span><br><span class="line"><span class="meta">      &#125;                                                                       \</span></span><br><span class="line"><span class="meta">    &#125;                                                                         \</span></span><br><span class="line"><span class="meta">  &#125;                                                                           \</span></span><br><span class="line"><span class="meta">  while (0)</span></span><br></pre></td></tr></table></figure>
<p>POST宏也是根据同步和异步操作来进行不同的处理, 如果是同步操作, 直接调用<code>uv__fs_work</code>并返回结果. 如果是异步操作, 那么调用<code>uv__work_submit</code>将任务<code>uv__fs_work</code>交给工作队列(线程池)来做. 根据上一篇所讲, 工作队列完成工作后, 最终会调用<code>uv__fs_done</code>回调.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POST                                                                  \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                        \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (cb != NULL) &#123;                                                         \</span></span><br><span class="line"><span class="meta">      uv__work_submit(loop, &amp;req-&gt;work_req, uv__fs_work, uv__fs_done);        \</span></span><br><span class="line"><span class="meta">      return 0;                                                               \</span></span><br><span class="line"><span class="meta">    &#125;                                                                         \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;                                                                    \</span></span><br><span class="line"><span class="meta">      uv__fs_work(&amp;req-&gt;work_req);                                            \</span></span><br><span class="line"><span class="meta">      return req-&gt;result;                                                     \</span></span><br><span class="line"><span class="meta">    &#125;                                                                         \</span></span><br><span class="line"><span class="meta">  &#125;                                                                           \</span></span><br><span class="line"><span class="meta">  while (0)</span></span><br></pre></td></tr></table></figure>
<p><code>uv_fs_open</code>就是上面的这些操作.<br>我们再来看看<code>uv_fs_read</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_fs_read</span><span class="params">(<span class="type">uv_loop_t</span>* loop, <span class="type">uv_fs_t</span>* req,</span></span><br><span class="line"><span class="params">               uv_file file,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">uv_buf_t</span> bufs[],</span></span><br><span class="line"><span class="params">               <span class="type">unsigned</span> <span class="type">int</span> nbufs,</span></span><br><span class="line"><span class="params">               <span class="type">int64_t</span> off,</span></span><br><span class="line"><span class="params">               uv_fs_cb cb)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (bufs == <span class="literal">NULL</span> || nbufs == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  INIT(READ);</span><br><span class="line">  req-&gt;file = file;</span><br><span class="line"></span><br><span class="line">  req-&gt;nbufs = nbufs;</span><br><span class="line">  req-&gt;bufs = req-&gt;bufsml;</span><br><span class="line">  <span class="keyword">if</span> (nbufs &gt; ARRAY_SIZE(req-&gt;bufsml))</span><br><span class="line">    req-&gt;bufs = uv__malloc(nbufs * <span class="keyword">sizeof</span>(*bufs));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (req-&gt;bufs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">NULL</span>)</span><br><span class="line">      uv__req_unregister(loop, req);</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(req-&gt;bufs, bufs, nbufs * <span class="keyword">sizeof</span>(*bufs));</span><br><span class="line"></span><br><span class="line">  req-&gt;off = off;</span><br><span class="line">  POST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到, 又一次用到了<code>INIT</code>和<code>POST</code>宏, 我们关注一下中间的部分. 这段代码就是调整一下bufs的大小并将bufs描述信息复制到req中. 如果调整失败就取消这个read请求. 后面的操作就跟open类似了, 根据是否有回调来决定用线程或同步的调用read相关的系统调用来处理以此read请求.<br><br>对于write跟read类似, 我们就不说了<br><br>除了用直接的request来处理文件的操作, 我们还可以用stream来处理, 接下来, 我们就来讲讲这部份.</p>
<p>先来直接看一段使用stream的代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uv_write_t</span> req;</span><br><span class="line">    <span class="type">uv_buf_t</span> buf;</span><br><span class="line">&#125; <span class="type">write_req_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uv_loop_t</span> *loop;</span><br><span class="line"><span class="type">uv_pipe_t</span> stdin_pipe;</span><br><span class="line"><span class="type">uv_pipe_t</span> stdout_pipe;</span><br><span class="line"><span class="type">uv_pipe_t</span> file_pipe;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc_buffer</span><span class="params">(<span class="type">uv_handle_t</span> *handle, <span class="type">size_t</span> suggested_size, <span class="type">uv_buf_t</span> *buf)</span> &#123;</span><br><span class="line">    *buf = uv_buf_init((<span class="type">char</span>*) <span class="built_in">malloc</span>(suggested_size), suggested_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_write_req</span><span class="params">(<span class="type">uv_write_t</span> *req)</span> &#123;</span><br><span class="line">    <span class="type">write_req_t</span> *wr = (<span class="type">write_req_t</span>*) req;</span><br><span class="line">    <span class="built_in">free</span>(wr-&gt;buf.base);</span><br><span class="line">    <span class="built_in">free</span>(wr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">on_stdout_write</span><span class="params">(<span class="type">uv_write_t</span> *req, <span class="type">int</span> status)</span> &#123;</span><br><span class="line">    free_write_req(req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">on_file_write</span><span class="params">(<span class="type">uv_write_t</span> *req, <span class="type">int</span> status)</span> &#123;</span><br><span class="line">    free_write_req(req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_data</span><span class="params">(<span class="type">uv_stream_t</span> *dest, <span class="type">size_t</span> size, <span class="type">uv_buf_t</span> buf, uv_write_cb cb)</span> &#123;</span><br><span class="line">    <span class="type">write_req_t</span> *req = (<span class="type">write_req_t</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">write_req_t</span>));</span><br><span class="line">    req-&gt;buf = uv_buf_init((<span class="type">char</span>*) <span class="built_in">malloc</span>(size), size);</span><br><span class="line">    <span class="built_in">memcpy</span>(req-&gt;buf.base, buf.base, size);</span><br><span class="line">    uv_write((<span class="type">uv_write_t</span>*) req, (<span class="type">uv_stream_t</span>*)dest, &amp;req-&gt;buf, <span class="number">1</span>, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_stdin</span><span class="params">(<span class="type">uv_stream_t</span> *stream, <span class="type">ssize_t</span> nread, <span class="type">const</span> <span class="type">uv_buf_t</span> *buf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nread &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nread == UV_EOF)&#123;</span><br><span class="line">            <span class="comment">// end of file</span></span><br><span class="line">            uv_close((<span class="type">uv_handle_t</span> *)&amp;stdin_pipe, <span class="literal">NULL</span>);</span><br><span class="line">            uv_close((<span class="type">uv_handle_t</span> *)&amp;stdout_pipe, <span class="literal">NULL</span>);</span><br><span class="line">            uv_close((<span class="type">uv_handle_t</span> *)&amp;file_pipe, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write_data((<span class="type">uv_stream_t</span> *)&amp;stdout_pipe, nread, *buf, on_stdout_write);</span><br><span class="line">        write_data((<span class="type">uv_stream_t</span> *)&amp;file_pipe, nread, *buf, on_file_write);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OK to free buffer as write_data copies it.</span></span><br><span class="line">    <span class="keyword">if</span> (buf-&gt;base)</span><br><span class="line">        <span class="built_in">free</span>(buf-&gt;base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    loop = uv_default_loop();</span><br><span class="line"></span><br><span class="line">    uv_pipe_init(loop, &amp;stdin_pipe, <span class="number">0</span>);</span><br><span class="line">    uv_pipe_open(&amp;stdin_pipe, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    uv_pipe_init(loop, &amp;stdout_pipe, <span class="number">0</span>);</span><br><span class="line">    uv_pipe_open(&amp;stdout_pipe, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">uv_fs_t</span> file_req;</span><br><span class="line">    <span class="type">int</span> fd = uv_fs_open(loop, &amp;file_req, argv[<span class="number">1</span>], O_CREAT | O_RDWR, <span class="number">0644</span>, <span class="literal">NULL</span>);</span><br><span class="line">    uv_pipe_init(loop, &amp;file_pipe, <span class="number">0</span>);</span><br><span class="line">    uv_pipe_open(&amp;file_pipe, fd);</span><br><span class="line"></span><br><span class="line">    uv_read_start((<span class="type">uv_stream_t</span>*)&amp;stdin_pipe, alloc_buffer, read_stdin);</span><br><span class="line"></span><br><span class="line">    uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到程序首先初始化三个uv pipe, 分别打开标准输入, 标准输出和参数表中的文件. 然后调用<code>uv_read_start</code>注册读事件, 会有两个回调函数: <code>alloc_buffer</code>(从而允许用户自己进行内存管理)和<code>read_stdin</code>(读完成后的回调). 然后调用<code>uv_run</code>启动event loop, 后面会在<code>read_stdin</code>中注册其他事件来完成输入的显示和保存.<br>我们先来看看<code>uv_pipe_init</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_pipe_init</span><span class="params">(<span class="type">uv_loop_t</span>* loop, <span class="type">uv_pipe_t</span>* handle, <span class="type">int</span> ipc)</span> &#123;</span><br><span class="line">  uv__stream_init(loop, (<span class="type">uv_stream_t</span>*)handle, UV_NAMED_PIPE);</span><br><span class="line">  handle-&gt;shutdown_req = <span class="literal">NULL</span>;</span><br><span class="line">  handle-&gt;connect_req = <span class="literal">NULL</span>;</span><br><span class="line">  handle-&gt;pipe_fname = <span class="literal">NULL</span>;</span><br><span class="line">  handle-&gt;ipc = ipc;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uv__stream_init</span><span class="params">(<span class="type">uv_loop_t</span>* loop,</span></span><br><span class="line"><span class="params">                     <span class="type">uv_stream_t</span>* stream,</span></span><br><span class="line"><span class="params">                     uv_handle_type type)</span> &#123;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  uv__handle_init(loop, (<span class="type">uv_handle_t</span>*)stream, type);</span><br><span class="line">  stream-&gt;read_cb = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;alloc_cb = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;close_cb = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;connection_cb = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;connect_req = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;shutdown_req = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;accepted_fd = <span class="number">-1</span>;</span><br><span class="line">  stream-&gt;queued_fds = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;delayed_error = <span class="number">0</span>;</span><br><span class="line">  QUEUE_INIT(&amp;stream-&gt;write_queue);</span><br><span class="line">  QUEUE_INIT(&amp;stream-&gt;write_completed_queue);</span><br><span class="line">  stream-&gt;write_queue_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;emfile_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    err = uv__open_cloexec(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">/* In the rare case that &quot;/dev/null&quot; isn&#x27;t mounted open &quot;/&quot;</span></span><br><span class="line"><span class="comment">         * instead.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        err = uv__open_cloexec(<span class="string">&quot;/&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (err &gt;= <span class="number">0</span>)</span><br><span class="line">      loop-&gt;emfile_fd = err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__APPLE__)</span></span><br><span class="line">  stream-&gt;select = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* defined(__APPLE_) */</span></span></span><br><span class="line"></span><br><span class="line">  uv__io_init(&amp;stream-&gt;io_watcher, uv__stream_io, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init部分还是比较简单的, 主要有<code>uv__handle_init</code>和<code>uv__io_init</code>. 前面说过了<br>然后<code>uv_pipe_open</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_pipe_open</span><span class="params">(<span class="type">uv_pipe_t</span>* handle, uv_file fd)</span> &#123;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">  err = uv__nonblock(fd, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__APPLE__)</span></span><br><span class="line">  err = uv__stream_try_select((<span class="type">uv_stream_t</span>*) handle, &amp;fd);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* defined(__APPLE__) */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uv__stream_open((<span class="type">uv_stream_t</span>*)handle,</span><br><span class="line">                         fd,</span><br><span class="line">                         UV_STREAM_READABLE | UV_STREAM_WRITABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv__stream_open</span><span class="params">(<span class="type">uv_stream_t</span>* stream, <span class="type">int</span> fd, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__APPLE__)</span></span><br><span class="line">  <span class="type">int</span> enable;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(stream-&gt;io_watcher.fd == <span class="number">-1</span> || stream-&gt;io_watcher.fd == fd))</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">  assert(fd &gt;= <span class="number">0</span>);</span><br><span class="line">  stream-&gt;flags |= flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stream-&gt;type == UV_TCP) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((stream-&gt;flags &amp; UV_TCP_NODELAY) &amp;&amp; uv__tcp_nodelay(fd, <span class="number">1</span>))</span><br><span class="line">      <span class="keyword">return</span> -errno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TODO Use delay the user passed in. */</span></span><br><span class="line">    <span class="keyword">if</span> ((stream-&gt;flags &amp; UV_TCP_KEEPALIVE) &amp;&amp; uv__tcp_keepalive(fd, <span class="number">1</span>, <span class="number">60</span>))</span><br><span class="line">      <span class="keyword">return</span> -errno;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__APPLE__)</span></span><br><span class="line">  enable = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_OOBINLINE, &amp;enable, <span class="keyword">sizeof</span>(enable)) &amp;&amp;</span><br><span class="line">      errno != ENOTSOCK &amp;&amp;</span><br><span class="line">      errno != EINVAL) &#123;</span><br><span class="line">    <span class="keyword">return</span> -errno;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  stream-&gt;io_watcher.fd = fd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简单, 除了对TCP进行特殊处理就是把fd保存到io_watcher中.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_read_start</span><span class="params">(<span class="type">uv_stream_t</span>* stream,</span></span><br><span class="line"><span class="params">                  uv_alloc_cb alloc_cb,</span></span><br><span class="line"><span class="params">                  uv_read_cb read_cb)</span> &#123;</span><br><span class="line">  assert(stream-&gt;type == UV_TCP || stream-&gt;type == UV_NAMED_PIPE ||</span><br><span class="line">      stream-&gt;type == UV_TTY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stream-&gt;flags &amp; UV_CLOSING)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The UV_STREAM_READING flag is irrelevant of the state of the tcp - it just</span></span><br><span class="line"><span class="comment">   * expresses the desired state of the user.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  stream-&gt;flags |= UV_STREAM_READING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> try to do the read inline? */</span></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> keep track of tcp state. If we&#x27;ve gotten a EOF then we should</span></span><br><span class="line"><span class="comment">   * not start the IO watcher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  assert(uv__stream_fd(stream) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(alloc_cb);</span><br><span class="line"></span><br><span class="line">  stream-&gt;read_cb = read_cb;</span><br><span class="line">  stream-&gt;alloc_cb = alloc_cb;</span><br><span class="line"></span><br><span class="line">  uv__io_start(stream-&gt;loop, &amp;stream-&gt;io_watcher, POLLIN);</span><br><span class="line">  uv__handle_start(stream);</span><br><span class="line">  uv__stream_osx_interrupt_select(stream);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是<code>uv__io_start</code>和<code>uv__handle_start</code>, 前者把事件放到watcher_queue, 这里要注意event是先放在pevents中的, 后面poll的时候才放到events中, 后者启动handle(stream)</p>
<p>那么<code>alloc_cb</code>和<code>read_cb</code>是如何调用到的呢?<br>在<code>uv__pipe_init</code>被调用时, 调用了<code>uv__stream_init</code>, 进而调用<code>uv__io_init(&amp;stream-&gt;io_watcher, uv__stream_io, -1)</code>, 这里设定了poll事件的回调为<code>io__stream_io</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">uv__stream_io</span><span class="params">(<span class="type">uv_loop_t</span>* loop, <span class="type">uv__io_t</span>* w, <span class="type">unsigned</span> <span class="type">int</span> events)</span> &#123;</span><br><span class="line">  <span class="type">uv_stream_t</span>* stream;</span><br><span class="line"></span><br><span class="line">  stream = container_of(w, <span class="type">uv_stream_t</span>, io_watcher);</span><br><span class="line"></span><br><span class="line">  assert(stream-&gt;type == UV_TCP ||</span><br><span class="line">         stream-&gt;type == UV_NAMED_PIPE ||</span><br><span class="line">         stream-&gt;type == UV_TTY);</span><br><span class="line">  assert(!(stream-&gt;flags &amp; UV_CLOSING));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stream-&gt;connect_req) &#123;</span><br><span class="line">    uv__stream_connect(stream);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(uv__stream_fd(stream) &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ignore POLLHUP here. Even it it&#x27;s set, there may still be data to read. */</span></span><br><span class="line">  <span class="keyword">if</span> (events &amp; (POLLIN | POLLERR | POLLHUP))</span><br><span class="line">    uv__read(stream);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uv__stream_fd(stream) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">/* read_cb closed stream. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Short-circuit iff POLLHUP is set, the user is still interested in read</span></span><br><span class="line"><span class="comment">   * events and uv__read() reported a partial read but not EOF. If the EOF</span></span><br><span class="line"><span class="comment">   * flag is set, uv__read() called read_cb with err=UV_EOF and we don&#x27;t</span></span><br><span class="line"><span class="comment">   * have to do anything. If the partial read flag is not set, we can&#x27;t</span></span><br><span class="line"><span class="comment">   * report the EOF yet because there is still data to read.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ((events &amp; POLLHUP) &amp;&amp;</span><br><span class="line">      (stream-&gt;flags &amp; UV_STREAM_READING) &amp;&amp;</span><br><span class="line">      (stream-&gt;flags &amp; UV_STREAM_READ_PARTIAL) &amp;&amp;</span><br><span class="line">      !(stream-&gt;flags &amp; UV_STREAM_READ_EOF)) &#123;</span><br><span class="line">    <span class="type">uv_buf_t</span> buf = &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    uv__stream_eof(stream, &amp;buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uv__stream_fd(stream) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">/* read_cb closed stream. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (events &amp; (POLLOUT | POLLERR | POLLHUP)) &#123;</span><br><span class="line">    uv__write(stream);</span><br><span class="line">    uv__write_callbacks(stream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write queue drained. */</span></span><br><span class="line">    <span class="keyword">if</span> (QUEUE_EMPTY(&amp;stream-&gt;write_queue))</span><br><span class="line">      uv__drain(stream);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>connect_req等到tcp再说. 这里会调用<code>uv__read</code>, 在这里面会调用<code>alloc_cb</code>分配内存, 对于ipc用<code>uv__recvmsg</code>读数据, 否则用<code>read</code>来读数据.可以看到stream根据不同的结果(如需要重读, 读出错, 读完成, 正常读)来用不同的方式处理并调用<code>read_cb</code>, 对于数据没有读到要求那么多是会置起<code>UV_STREAM_READ_PARTIAL</code>.</p>
<p>write部分我就不分析了, 其实也比较类似.</p>
<p>后面就会进入libuv网络部分的分析了.</p>
]]></content>
      <categories>
        <category>libuv</category>
      </categories>
      <tags>
        <tag>libuv</tag>
      </tags>
  </entry>
  <entry>
    <title>arm64_linux启动流程分析01_内核的入口</title>
    <url>/2017/11/30/5b2ebc5168b6/</url>
    <content><![CDATA[<p>本次分析使用的linux内核的版本时 4.14.2, 读者可以自己下载了对照分析</p>
<p>首先看链接文件如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ENTRY(_text)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	.....省略部分无关内容....</span><br><span class="line"></span><br><span class="line">	. = KIMAGE_VADDR + TEXT_OFFSET;</span><br><span class="line"></span><br><span class="line">	.head.text : &#123;</span><br><span class="line">		_text = .;</span><br><span class="line">		HEAD_TEXT</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>可以看到入口点在<code>_text</code>. 而<code>_text</code>是指向<code>.head.text</code>段的起始位置. 所以内核是从<code>.head.text</code>开始运行的. 那么这个段是写什么内容呢?</p>
<p><code>HEAD_TEXT</code>是一个宏<code>#define HEAD_TEXT  *(.head.text)</code></p>
<p>在<code>arch/arm64/kernel/head.S</code>中有</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	__HEAD</span><br><span class="line">_head:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * DO NOT MODIFY. Image header expected by Linux boot-loaders.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EFI</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This add instruction has no meaningful effect except that</span></span><br><span class="line"><span class="comment">	 * its opcode forms the magic &quot;MZ&quot; signature required by UEFI.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	add	x13, x18, #<span class="number">0x16</span></span><br><span class="line">	b	stext</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	b	stext				<span class="comment">// branch to kernel start, magic</span></span><br><span class="line">	.<span class="type">long</span>	<span class="number">0</span>				<span class="comment">// reserved</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	...省略后面的内容...</span><br></pre></td></tr></table></figure>

<p>所以对应到code, 内核是从<code>_head</code>开始运行的. 这个开始点放置了一个arm64 linux的header:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u32 code0;			<span class="comment">/* Executable code */</span></span><br><span class="line">u32 code1;			<span class="comment">/* Executable code */</span></span><br><span class="line">u64 text_offset;		<span class="comment">/* Image load offset, little endian */</span></span><br><span class="line">u64 image_size;		<span class="comment">/* Effective Image size, little endian */</span></span><br><span class="line">u64 flags;			<span class="comment">/* kernel flags, little endian */</span></span><br><span class="line">u64 res2	= <span class="number">0</span>;		<span class="comment">/* reserved */</span></span><br><span class="line">u64 res3	= <span class="number">0</span>;		<span class="comment">/* reserved */</span></span><br><span class="line">u64 res4	= <span class="number">0</span>;		<span class="comment">/* reserved */</span></span><br><span class="line">u32 magic	= <span class="number">0x644d5241</span>;	<span class="comment">/* Magic number, little endian, &quot;ARM\x64&quot; */</span></span><br><span class="line">u32 res5;			<span class="comment">/* reserved (used for PE COFF offset) */</span></span><br></pre></td></tr></table></figure>

<p>这个头的前两个位置放置的是可执行code</p>
<p>在开启UEFI支持时, <code>add	x13, x18, #0x16</code>这个code实际上是为了满足EFI格式的”MZ”头. 如果使用UEFI来启动kernel, 会识别出来并走UEFI启动的流程, 如果是普通的启动过程如使用uboot的booti进行引导, 那么第一条指令就是一条dummy指令. 第二条就跳转到<code>stext</code>运行了.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ENTRY(stext)</span><br><span class="line">	bl	preserve_boot_args</span><br><span class="line">	bl	el2_setup			<span class="comment">// Drop to EL1, w0=cpu_boot_mode</span></span><br><span class="line">	adrp	x23, __PHYS_OFFSET</span><br><span class="line">	and	x23, x23, MIN_KIMG_ALIGN - <span class="number">1</span>	<span class="comment">// KASLR offset, defaults to 0</span></span><br><span class="line">	bl	set_cpu_boot_mode_flag</span><br><span class="line">	bl	__create_page_tables</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The following calls CPU setup code, see arch/arm64/mm/proc.S for</span></span><br><span class="line"><span class="comment">	 * details.</span></span><br><span class="line"><span class="comment">	 * On return, the CPU will be ready for the MMU to be turned on and</span></span><br><span class="line"><span class="comment">	 * the TCR will have been set.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bl	__cpu_setup			<span class="comment">// initialise processor</span></span><br><span class="line">	b	__primary_switch</span><br><span class="line"><span class="title function_">ENDPROC</span><span class="params">(stext)</span></span><br></pre></td></tr></table></figure>

<p>这段代码就是内核启动是运行的初始化代码. 后面会分章节来详细描述.</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>arm64_linux启动流程分析02_保存启动信息</title>
    <url>/2017/11/30/0d5175e7e831/</url>
    <content><![CDATA[<p>解上节, 我们先来看看<code>bl    preserve_boot_args</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preserve_boot_args:</span><br><span class="line">	mov	x21, x0				// x21=FDT</span><br><span class="line"></span><br><span class="line">	adr_l	x0, boot_args			// record the contents of</span><br><span class="line">	stp	x21, x1, [x0]			// x0 .. x3 at kernel entry</span><br><span class="line">	stp	x2, x3, [x0, #16]</span><br><span class="line"></span><br><span class="line">	dmb	sy				// needed before dc ivac with</span><br><span class="line">						// MMU off</span><br><span class="line"></span><br><span class="line">	mov	x1, #0x20			// 4 x 8 bytes</span><br><span class="line">	b	__inval_dcache_area		// tail call</span><br><span class="line">ENDPROC(preserve_boot_args)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>代码的含义一目了然, 把存fdt内存地址的x0保存到x21寄存器. 然后把启动参数x0, x1, x2, x3全部保存到boot_args数组中.</p>
<p>arm64 linux规定:</p>
<blockquote>
<p> Primary CPU general-purpose register settings</p>
</blockquote>
<blockquote>
<p> x0 &#x3D; physical address of device tree blob (dtb) in system RAM.</p>
</blockquote>
<blockquote>
<p> x1 &#x3D; 0 (reserved for future use)</p>
</blockquote>
<blockquote>
<p> x2 &#x3D; 0 (reserved for future use)</p>
</blockquote>
<blockquote>
<p> x3 &#x3D; 0 (reserved for future use)</p>
</blockquote>
<p>这里值得注意的有几点</p>
<ol>
<li>这里有用到<code>adr_l</code>, arm64并没有这个指令, 这是一个宏</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	.macro	adr_l, dst, sym</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MODULE</span></span><br><span class="line">	adrp	\dst, \sym</span><br><span class="line">	add	\dst, \dst, :lo12:\sym</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	movz	\dst, #:abs_g3:\sym</span><br><span class="line">	movk	\dst, #:abs_g2_nc:\sym</span><br><span class="line">	movk	\dst, #:abs_g1_nc:\sym</span><br><span class="line">	movk	\dst, #:abs_g0_nc:\sym</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<p>可以看到, 这里的<code>adr_l</code>拆分成了两条指令, adrp + add, adrp指令最大寻址空间时+-4GB, 但是所寻址的地址是4KB对齐的. 所以这里在加了一个add指令来修正地址的低12bit, 从而实现了这个加载+-4GB任意位置的运行时地址的宏.</p>
<ol start="2">
<li><code>__inval_dcache_area</code>函数用来invalidate指定区域的dcache, 具体如下</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ENTRY(__inval_dcache_area)</span><br><span class="line">	<span class="comment">/* FALLTHROUGH */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	__dma_inv_area(start, size)</span></span><br><span class="line"><span class="comment"> *	- start   - virtual start address of region</span></span><br><span class="line"><span class="comment"> *	- size    - size in question</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__dma_inv_area:</span><br><span class="line">	add	x1, x1, x0</span><br><span class="line">	dcache_line_size x2, x3</span><br><span class="line">	sub	x3, x2, #<span class="number">1</span></span><br><span class="line">	tst	x1, x3				<span class="comment">// end cache line aligned?</span></span><br><span class="line">	bic	x1, x1, x3</span><br><span class="line">	b.eq	<span class="number">1f</span></span><br><span class="line">	dc	civac, x1			<span class="comment">// clean &amp; invalidate D / U line</span></span><br><span class="line"><span class="number">1</span>:	tst	x0, x3				<span class="comment">// start cache line aligned?</span></span><br><span class="line">	bic	x0, x0, x3</span><br><span class="line">	b.eq	<span class="number">2f</span></span><br><span class="line">	dc	civac, x0			<span class="comment">// clean &amp; invalidate D / U line</span></span><br><span class="line">	b	<span class="number">3f</span></span><br><span class="line"><span class="number">2</span>:	dc	ivac, x0			<span class="comment">// invalidate D / U line</span></span><br><span class="line"><span class="number">3</span>:	add	x0, x0, x2</span><br><span class="line">	cmp	x0, x1</span><br><span class="line">	b.lo	<span class="number">2b</span></span><br><span class="line">	dsb	sy</span><br><span class="line">	ret</span><br><span class="line"><span class="title function_">ENDPIPROC</span><span class="params">(__inval_dcache_area)</span></span><br></pre></td></tr></table></figure>

<p>可以看到如果指定内存区域有跨越cacheline, 那么对两边跨越了cacheline的地址使用的clean + invalidate, 对于中间区域可以直接invalidate不用写回内存, 从而加快invalidate速度.</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>arm64_linux启动流程分析03_设定当前core的启动状态</title>
    <url>/2017/11/30/d07d299ed015/</url>
    <content><![CDATA[<p>接下来看<code>el2_setup</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ENTRY(el2_setup)</span><br><span class="line">	msr	SPsel, #<span class="number">1</span>			<span class="comment">// We want to use SP_EL&#123;1,2&#125;</span></span><br><span class="line">	mrs	x0, CurrentEL</span><br><span class="line">	cmp	x0, #CurrentEL_EL2</span><br><span class="line">	b.eq	<span class="number">1f</span></span><br><span class="line">	mrs	x0, sctlr_el1</span><br><span class="line"><span class="title function_">CPU_BE</span><span class="params">(	orr	x0, x0, #(<span class="number">3</span> &lt;&lt; <span class="number">24</span>)	)</span>	<span class="comment">// Set the EE and E0E bits for EL1</span></span><br><span class="line"><span class="title function_">CPU_LE</span><span class="params">(	bic	x0, x0, #(<span class="number">3</span> &lt;&lt; <span class="number">24</span>)	)</span>	<span class="comment">// Clear the EE and E0E bits for EL1</span></span><br><span class="line">	msr	sctlr_el1, x0</span><br><span class="line">	mov	w0, #BOOT_CPU_MODE_EL1		<span class="comment">// This cpu booted in EL1</span></span><br><span class="line">	isb</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">1:	mrs	x0, sctlr_el2</span><br><span class="line">......省略......</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>判断当前core的EL, 如果是EL1, 就设定使用little endian, <code>CPU_BE</code>和<code>CPU_LE</code>只有一条会编译进code. 之后返回<code>BOOT_CPU_MODE_EL1</code>, 如果EL2, 会初始化虚拟化相关的东西, 比较复杂, 先搁着.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">adrp	x23, __PHYS_OFFSET</span><br><span class="line">and	x23, x23, MIN_KIMG_ALIGN - <span class="number">1</span>	<span class="comment">// KASLR offset, defaults to 0</span></span><br></pre></td></tr></table></figure>
<p>这段code跟kaslr有关, 我们下篇文章来着重讲这个. 先接着往下看<code>set_cpu_boot_mode_flag</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_cpu_boot_mode_flag:</span><br><span class="line">	adr_l	x1, __boot_cpu_mode</span><br><span class="line">	cmp	w0, #BOOT_CPU_MODE_EL2</span><br><span class="line">	b.ne	<span class="number">1f</span></span><br><span class="line">	add	x1, x1, #<span class="number">4</span></span><br><span class="line"><span class="number">1</span>:	str	w0, [x1]			<span class="comment">// This CPU has booted in EL1</span></span><br><span class="line">	dmb	sy</span><br><span class="line">	dc	ivac, x1			<span class="comment">// Invalidate potentially stale cache line</span></span><br><span class="line">	ret</span><br><span class="line"><span class="title function_">ENDPROC</span><span class="params">(set_cpu_boot_mode_flag)</span></span><br></pre></td></tr></table></figure>

<p>在<code>__boot_cpu_mode</code>标签下保存了两个值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ENTRY(__boot_cpu_mode)</span><br><span class="line">	.<span class="type">long</span>	BOOT_CPU_MODE_EL2</span><br><span class="line">	.<span class="type">long</span>	BOOT_CPU_MODE_EL1</span><br></pre></td></tr></table></figure>

<p>这段code的作用就是把保存的这两个值修改为一致, 且为当前CORE的启动EL, 其他CORE启动时也会运行这段code, 这样如果后面的CORE启动到了不同的EL就又会把这两个值修改为不一致, 从而可以判断出CPU的启动状态时不对的.</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>arm64_linux启动流程分析04_KASLR</title>
    <url>/2017/11/30/fe273d09ca75/</url>
    <content><![CDATA[<p>这篇内容主要是说一下KASLR</p>
<p>KASLR是让内核在一个随机的地址上运行的技术, 就是说内核的运行时地址是随机的, 每次启动会变化. 这样内核的符号对应的地址会变化并不是链接地址从而加强安全性. 这里画一个图</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+---------------+-------+-------------+----------------------</span><br><span class="line">|               |       |             |</span><br><span class="line">| <span class="number">2</span>M align resv | KASLR | TEXT_OFFSET | KERNEL IMAGE</span><br><span class="line">|               |       |             |</span><br><span class="line">+---------------+-------+-------------+----------------------</span><br><span class="line">|                       |             |</span><br><span class="line">|                       |             +----内核在DDR中的位置.</span><br><span class="line">|                       +----------------- ARM64规定的KERNEL运行前必须放在 <span class="number">2</span>M对齐地址+TEXT_OFFSET 的地方</span><br><span class="line">|                                          这里是经过KASLR技术relocate之后的位置.</span><br><span class="line">+----------------------------------------- DDR起始地址.</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>目前开启KASLR的内核启动有两种办法:</p>
<ol>
<li><p>bootloader在设备树中添加一个<code>kaslr-seed</code>的节点. 并赋予一个随机的偏移, 将KERNEL放在ARM64规定的2M对齐地址+TEXT_OFFSET的地方, 然后启动内核, 之后内核会将自己relocate到2M对齐地址+KASLR offset+TEXT_OFFSET的地方运行</p>
</li>
<li><p>bootloader把将KERNEL放在2M对齐地址+KASLR offset+TEXT_OFFSET的地方(KASLR offset小于2M), 然后启动内核, 之后内核会修复symbol, 然后在原地运行.</p>
</li>
</ol>
<p>在上一篇文章中, 我们放了一段code没说</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">adrp	x23, __PHYS_OFFSET</span><br><span class="line">and	x23, x23, MIN_KIMG_ALIGN - <span class="number">1</span>	<span class="comment">// KASLR offset, defaults to 0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __PHYS_OFFSET	(KERNEL_START - TEXT_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_START      _text</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_KIMG_ALIGN		SZ_2M</span></span><br></pre></td></tr></table></figure>

<p>我们假设使用第二种启动办法, 那么<code>__PHYS_OFFSET</code>指向KASLR区域的最后面所在的物理地址. 第二条汇编就会计算出KASLR区域的大小然后保存在x23寄存器中. 对这个寄存器多加留意, 在调用<code>start_kernel</code>之前还会再用到.</p>
<p>对于KASLR的BOOT后面还需继续降到, 这里先放放, 我们先在下篇接着往下说.</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>arm64_linux启动流程分析05_配置内核启动的临时页表</title>
    <url>/2017/11/30/bc1f4d0c8f91/</url>
    <content><![CDATA[<p>这篇内容讲讲页表的配置, 为了kernel运行速度加快, 我们需要启动cache, 启动cache需要先启动MMU让CPU运行到虚拟地址上, 那么我们就需要启动一个能覆盖KERNEL内存区域的页表.</p>
<p>本篇内容假设在您对MMU有一定的了解的基础上来讲述的.</p>
<p>我们假设使用4K页来管理内存, 同时虚拟地址使用48位地址</p>
<span id="more"></span>

<p>我们将<code>__create_page_tables</code>函数分成几段来讲解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__create_page_tables:</span><br><span class="line">	mov	x28, lr</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Invalidate the idmap and swapper page tables to avoid potential</span></span><br><span class="line"><span class="comment">	 * dirty cache lines being evicted.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	adrp	x0, idmap_pg_dir</span><br><span class="line">	ldr	x1, =(IDMAP_DIR_SIZE + SWAPPER_DIR_SIZE + RESERVED_TTBR0_SIZE)</span><br><span class="line">	bl	__inval_dcache_area</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear the idmap and swapper page tables.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	adrp	x0, idmap_pg_dir</span><br><span class="line">	ldr	x1, =(IDMAP_DIR_SIZE + SWAPPER_DIR_SIZE + RESERVED_TTBR0_SIZE)</span><br><span class="line"><span class="number">1</span>:	stp	xzr, xzr, [x0], #<span class="number">16</span></span><br><span class="line">	stp	xzr, xzr, [x0], #<span class="number">16</span></span><br><span class="line">	stp	xzr, xzr, [x0], #<span class="number">16</span></span><br><span class="line">	stp	xzr, xzr, [x0], #<span class="number">16</span></span><br><span class="line">	subs	x1, x1, #<span class="number">64</span></span><br><span class="line">	b.ne	<span class="number">1b</span></span><br></pre></td></tr></table></figure>

<p>在vmlinux.lds.S中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">. = ALIGN(PAGE_SIZE);</span><br><span class="line">idmap_pg_dir = .;</span><br><span class="line">. += IDMAP_DIR_SIZE;</span><br><span class="line">swapper_pg_dir = .;</span><br><span class="line">. += SWAPPER_DIR_SIZE;</span><br></pre></td></tr></table></figure>

<p>所以<code>idmap_pg_dir</code>是在bss段后面且是<code>PAGE_SIZE</code>对齐的. x0保存<code>idmap_pg_dir</code>当前所在的物理地址. x1保存<code>idmap_pg_dir</code>和<code>swapper_pg_dir</code>的大小.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPPER_DIR_SIZE	(SWAPPER_PGTABLE_LEVELS * PAGE_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDMAP_DIR_SIZE		(IDMAP_PGTABLE_LEVELS * PAGE_SIZE)</span></span><br></pre></td></tr></table></figure>

<p>通过对宏的观察, 我们了解到<code>idmap_pg_dir</code>和<code>swapper_pg_dir</code>都是3个PAGE_SIZE(12K), 我们知道使用4K页加48bit虚拟地址需要4级页表才能满足, 每级页表都是一个PAGE</p>
<ul>
<li><p>level0 [47:39] 512个entry, 每个8byte, 一共4K</p>
</li>
<li><p>level1 [38:30] 512个entry, 每个8byte, 一共4K</p>
</li>
<li><p>level2 [29:21] 512个entry, 每个8byte, 一共4K</p>
</li>
<li><p>level3 [20:13] 512个entry, 每个8byte, 一共4K</p>
</li>
</ul>
<p>剩下的11:0地址用level3的内容拼接得到最终的物理地址.</p>
<p>而这里<code>idmap_pg_dir</code>和<code>swapper_pg_dir</code>都只有3个PAGE是如何来映射的呢? 其实这里KERNEL在早期的临时页表为了节省内存, 并没有使用标准的4级映射, 而是使用的MMU中的block来直接描述2M(使用低21bit)内存区, 而不是用entry来描述4K页, 从而节省了level3的页表.</p>
<p>也就是说上面的level2页表中, 每条entry指向的不是level3页表, 而是一个2M的内存区.</p>
<p>上面的代码把这里的6个page全部清零, 因此所有的entry都成了invalid.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * x7保存level3页表的entry的flags, 表明是普通内存,</span></span><br><span class="line"><span class="comment"> * 是一个block的entry, 后面细说</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mov	x7, SWAPPER_MM_MMUFLAGS</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create the identity mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">adrp	x0, idmap_pg_dir</span><br><span class="line">adrp	x3, __idmap_text_start		<span class="comment">// __pa(__idmap_text_start)</span></span><br><span class="line"></span><br><span class="line">create_pgd_entry x0, x3, x5, x6</span><br><span class="line">mov	x5, x3				<span class="comment">// __pa(__idmap_text_start)</span></span><br><span class="line">adr_l	x6, __idmap_text_end		<span class="comment">// __pa(__idmap_text_end)</span></span><br><span class="line">create_block_map x0, x7, x3, x5, x6</span><br></pre></td></tr></table></figure>

<p>x0保存<code>idmap_pg_dir</code>的物理地址. x3保存<code>__idmap_text_start</code>的物理地址.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">. = ALIGN(SZ_4K);				\</span><br><span class="line">VMLINUX_SYMBOL(__idmap_text_start) = .;		\</span><br><span class="line">*(.idmap.text)					\</span><br><span class="line">VMLINUX_SYMBOL(__idmap_text_end) = .;</span><br></pre></td></tr></table></figure>

<p>所以x3保存的是<code>.idmap.text</code>段所在的物理地址. 这个段是head.S文件的后半部分, 这部份code是CPU和MMU从关闭到开启的过程中执行的code, 说道这里你应该明白了, <code>idmap_pg_dir</code>对应的页表是用来将与KERNEL所在物理地址相等的虚拟地址映射到相同的物理地址. 从而保证开启MMU时, 不会发生无法获取页表的情况. 而<code>swapper_pg_dir</code>如其名是swapper进程运行所需的页表, 是内核初始化过程所用的页表.</p>
<p>另外ARM64有TTBR0, TTBR1(Translation Table Base Register)分别用来指示内核空间和用户空间页表所在的物理地址, 而在这个时候, TTBR0不是用来指示用户空间地址, 而是用来指示与物理地址相等的虚拟地址所用的页表. 所以TTBR0里面是<code>.idmap.text</code>的物理地址, TTBR1里面是<code>swapper_pg_dir</code>的物理地址.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	.macro	create_pgd_entry, tbl, virt, tmp1, tmp2</span><br><span class="line">	<span class="comment">/* 这里PGDIR_SHIFT是39, PTRS_PER_PGD是512 */</span></span><br><span class="line">	create_table_entry \tbl, \virt, PGDIR_SHIFT, PTRS_PER_PGD, \tmp1, \tmp2</span><br><span class="line">	<span class="comment">/* 使用4K页时SWAPPER_PGTABLE_LEVELS为3 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SWAPPER_PGTABLE_LEVELS &gt; 3</span></span><br><span class="line">	create_table_entry \tbl, \virt, PUD_SHIFT, PTRS_PER_PUD, \tmp1, \tmp2</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SWAPPER_PGTABLE_LEVELS &gt; 2</span></span><br><span class="line">	<span class="comment">/* SWAPPER_TABLE_SHIFT是30, PTRS_PER_PTE是512 */</span></span><br><span class="line">	create_table_entry \tbl, \virt, SWAPPER_TABLE_SHIFT, PTRS_PER_PTE, \tmp1, \tmp2</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<p><code>create_pgd_entry</code>宏用来创建level0和和level1的页表. 虚拟地址的[47:39]在level0页表中进行索引, 索引到的entry指向level1的页表, 这里level1的页表就是level0页表的下一个PAGE. 对应的[38:30]在level1页表中进行索引, 索引的entry指向level2的页表. 也就是再下一个PAGE. 这里来分析下<code>create_table_entry</code>宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.macro	create_table_entry, tbl, virt, shift, ptrs, tmp1, tmp2</span><br><span class="line"><span class="comment">/* 下面两条指令取出虚拟地址(virt)的[shift+9:shift], 作为index */</span></span><br><span class="line">lsr	\tmp1, \virt, #\shift</span><br><span class="line">and	\tmp1, \tmp1, #\ptrs - <span class="number">1</span>	<span class="comment">// table index</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 下面两条指令计算出这一级页表对应virt的entry的值, 第一条指令计算entry指向的下一级</span></span><br><span class="line"><span class="comment"> * 页表的物理地址, 第二条指令指定当前entry是PMD_TYPE_TABLE, 也就是表示当前entry</span></span><br><span class="line"><span class="comment"> * 指向的仍然是一个页目录, 具体看arm的architecture reference manual.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">add	\tmp2, \tbl, #PAGE_SIZE</span><br><span class="line">orr	\tmp2, \tmp2, #PMD_TYPE_TABLE	<span class="comment">// address of next table and entry type</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用之前计算的index来得到virt对应的entry的位置(tbl + index * 8byte), 然后把</span></span><br><span class="line"><span class="comment"> * 页表entry存到那个位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">str	\tmp2, [\tbl, \tmp1, lsl #<span class="number">3</span>]</span><br><span class="line"><span class="comment">/* tbl指向下一级页表, 方便下一次计算 */</span></span><br><span class="line">add	\tbl, \tbl, #PAGE_SIZE		<span class="comment">// next level table page</span></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<p>level2的页表由<code>create_block_map</code>来配置.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	.macro	create_block_map, tbl, flags, phys, start, end</span><br><span class="line">	<span class="comment">/* SWAPPER_BLOCK_SHIFT是21, 把物理地址右移21bit, 剩下的就是entry中的地址 */</span></span><br><span class="line">	lsr	\phys, \phys, #SWAPPER_BLOCK_SHIFT</span><br><span class="line">	<span class="comment">/* 这两条指令取出start的[29:21]作为level2页表的索引, 存在start中 */</span></span><br><span class="line">	lsr	\start, \start, #SWAPPER_BLOCK_SHIFT</span><br><span class="line">	and	\start, \start, #PTRS_PER_PTE - <span class="number">1</span>	<span class="comment">// table index</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * phys = flags | (phys &lt;&lt; 21), 很明显, 就是构建一条level2页表entry,</span></span><br><span class="line"><span class="comment">	 * entry将虚拟地址start(前面两条指令计算之前的值)转换成物理地址phys(计算前的值)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	orr	\phys, \flags, \phys, lsl #SWAPPER_BLOCK_SHIFT	<span class="comment">// table entry</span></span><br><span class="line">	<span class="comment">/* 将end也计算成一个index, 方便后面的循环建立页表 */</span></span><br><span class="line">	lsr	\end, \end, #SWAPPER_BLOCK_SHIFT</span><br><span class="line">	and	\end, \end, #PTRS_PER_PTE - <span class="number">1</span>		<span class="comment">// table end index</span></span><br><span class="line">	<span class="comment">/* 将之前构建的页表entry存到level2页表对应的位置(由[29:21]索引) */</span></span><br><span class="line"><span class="number">9999</span>:	str	\phys, [\tbl, \start, lsl #<span class="number">3</span>]		<span class="comment">// store the entry</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 索引每次加1, 页表entry的物理地址每次加2M, 这样就能计算出下一条entry的内容</span></span><br><span class="line"><span class="comment">	 * 和存放路径了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	add	\start, \start, #<span class="number">1</span>			<span class="comment">// next entry</span></span><br><span class="line">	add	\phys, \phys, #SWAPPER_BLOCK_SIZE		<span class="comment">// next block</span></span><br><span class="line">	<span class="comment">/* 循环创建参数中start到end的地址的映射 */</span></span><br><span class="line">	cmp	\start, \end</span><br><span class="line">	b.ls	<span class="number">9999b</span></span><br><span class="line">	.endm</span><br></pre></td></tr></table></figure>

<p>综合上面的注释, 这里就是按照armv8 MMU的block条目来创建从start到end虚拟地址空间的映射, 每一个条目映射2M的地址空间. 这里把前面提到的x7保存的flags细说一下.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPPER_MM_MMUFLAGS	(PMD_ATTRINDX(MT_NORMAL) | SWAPPER_PMD_FLAGS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT_NORMAL		4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_ATTRINDX(t)		(_AT(pmdval_t, (t)) &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPPER_PMD_FLAGS	(PMD_TYPE_SECT | PMD_SECT_AF | PMD_SECT_S)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_TYPE_SECT		(_AT(pmdval_t, 1) &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_SECT_AF		(_AT(pmdval_t, 1) &lt;&lt; 10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_SECT_S		(_AT(pmdval_t, 3) &lt;&lt; 8)</span></span><br><span class="line"><span class="keyword">typedef</span> u64 <span class="type">pmdval_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _AC(X,Y)	X</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _AT(T,X)	X</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __AC(X,Y)	(X##Y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _AC(X,Y)	__AC(X,Y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _AT(T,X)	((T)(X))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>具体每个字段的含义可以查询arm手册来看, 大致来说, 这个flags表明, 这条entry指向的是一个2M的block, 这个block是一段普通的内存(不是device memory, 下篇内容我们还会继续说), 是已经访问过的, 是inner sharable的. 另外一些没有设定的位置为0也有一些含义, 如表示code是可执行的, 访问权限是EL0 RO, EL1 RW, 具体看arm的architecture reference manual.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">adrp	x0, swapper_pg_dir</span><br><span class="line">mov_q	x5, KIMAGE_VADDR + TEXT_OFFSET	<span class="comment">// compile time __va(_text)</span></span><br><span class="line">add	x5, x5, x23			<span class="comment">// add KASLR displacement</span></span><br><span class="line">create_pgd_entry x0, x5, x3, x6</span><br><span class="line">adrp	x6, _end			<span class="comment">// runtime __pa(_end)</span></span><br><span class="line">adrp	x3, _text			<span class="comment">// runtime __pa(_text)</span></span><br><span class="line">sub	x6, x6, x3			<span class="comment">// _end - _text</span></span><br><span class="line">add	x6, x6, x5			<span class="comment">// runtime __va(_end)</span></span><br><span class="line">create_block_map x0, x7, x3, x5, x6</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Since the page tables have been populated with non-cacheable</span></span><br><span class="line"><span class="comment"> * accesses (MMU disabled), invalidate the idmap and swapper page</span></span><br><span class="line"><span class="comment"> * tables again to remove any speculatively loaded cache lines.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">adrp	x0, idmap_pg_dir</span><br><span class="line">ldr	x1, =(IDMAP_DIR_SIZE + SWAPPER_DIR_SIZE + RESERVED_TTBR0_SIZE)</span><br><span class="line">dmb	sy</span><br><span class="line">bl	__inval_dcache_area</span><br><span class="line"></span><br><span class="line">ret	x28</span><br></pre></td></tr></table></figure>

<p>后面的code参照前面的分析就很好理解了, 创建swapper的页表, 然后用<code>dmb sy</code>完成同步, 最后清空缓存.</p>
<p>这里由一个需要注意低地方, 跟之前说的KASLR有关. <code>add	x5, x5, x23</code>在x5中保存_text的虚拟地址之后, 又加了x23, 这个x23就是之前保存的kaslr区域的大小. 也就是说把KEREL运行的虚拟地址进行了随机化.</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>arm64_linux启动流程分析06_CPU的一些初始化</title>
    <url>/2017/11/30/4fe0890861ef/</url>
    <content><![CDATA[<p>接下来进入<code>__cpu_setup</code>函数</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ENTRY(__cpu_setup)</span><br><span class="line">	<span class="comment">/* 清空当前CORE所有的tlb, vm + all + el1, 这条指令需要对non-sharable区域加内存屏障 */</span></span><br><span class="line">	tlbi	vmalle1				<span class="comment">// Invalidate local TLB</span></span><br><span class="line">	dsb	nsh</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 开启CPU的FP/SIMD, debug功能, 关闭PMU等 */</span></span><br><span class="line">	mov	x0, #<span class="number">3</span> &lt;&lt; <span class="number">20</span></span><br><span class="line">	msr	cpacr_el1, x0			<span class="comment">// Enable FP/ASIMD</span></span><br><span class="line">	mov	x0, #<span class="number">1</span> &lt;&lt; <span class="number">12</span>			<span class="comment">// Reset mdscr_el1 and disable</span></span><br><span class="line">	msr	mdscr_el1, x0			<span class="comment">// access to the DCC from EL0</span></span><br><span class="line">	isb					<span class="comment">// Unmask debug exceptions now,</span></span><br><span class="line">	enable_dbg				<span class="comment">// since this is per-cpu</span></span><br><span class="line">	reset_pmuserenr_el0 x0			<span class="comment">// Disable PMU access from EL0</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 上面内容我们说到了, 页表entry表明内存是普通内存, 就是结合这里的初始化来指明的,</span></span><br><span class="line"><span class="comment">	 * PMD_ATTRINDX(MT_NORMAL)是4, 这其实是一个index, 指向MAIR寄存器的[4*8+7:4*8],</span></span><br><span class="line"><span class="comment">	 * MAIR寄存器一共有8组, KERNEL用了6组, 每组有8bit, 每个bit都有相应的含义.</span></span><br><span class="line"><span class="comment">	 * 具体参考手册, 这里就不细说了, 点到为止</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Memory region attributes for LPAE:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   n = AttrIndx[2:0]</span></span><br><span class="line"><span class="comment">	 *			n	MAIR</span></span><br><span class="line"><span class="comment">	 *   DEVICE_nGnRnE	000	00000000</span></span><br><span class="line"><span class="comment">	 *   DEVICE_nGnRE	001	00000100</span></span><br><span class="line"><span class="comment">	 *   DEVICE_GRE		010	00001100</span></span><br><span class="line"><span class="comment">	 *   NORMAL_NC		011	01000100</span></span><br><span class="line"><span class="comment">	 *   NORMAL		100	11111111</span></span><br><span class="line"><span class="comment">	 *   NORMAL_WT		101	10111011</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ldr	x5, =MAIR(<span class="number">0x00</span>, MT_DEVICE_nGnRnE) | \</span><br><span class="line">		     MAIR(<span class="number">0x04</span>, MT_DEVICE_nGnRE) | \</span><br><span class="line">		     MAIR(<span class="number">0x0c</span>, MT_DEVICE_GRE) | \</span><br><span class="line">		     MAIR(<span class="number">0x44</span>, MT_NORMAL_NC) | \</span><br><span class="line">		     MAIR(<span class="number">0xff</span>, MT_NORMAL) | \</span><br><span class="line">		     MAIR(<span class="number">0xbb</span>, MT_NORMAL_WT)</span><br><span class="line">	msr	mair_el1, x5</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Prepare SCTLR</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 从这里开始注意x0寄存器, 保存了后面开启MMU时需要写入sctlr_el1的值 */</span></span><br><span class="line">	adr	x5, crval</span><br><span class="line">	ldp	w5, w6, [x5]</span><br><span class="line">	mrs	x0, sctlr_el1</span><br><span class="line">	bic	x0, x0, x5			<span class="comment">// clear bits</span></span><br><span class="line">	orr	x0, x0, x6			<span class="comment">// set bits</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set/prepare TCR and TTBR. We use 512GB (39-bit) address range for</span></span><br><span class="line"><span class="comment">	 * both user and kernel.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ldr	x10, =TCR_TxSZ(VA_BITS) | TCR_CACHE_FLAGS | TCR_SMP_FLAGS | \</span><br><span class="line">			TCR_TG_FLAGS | TCR_ASID16 | TCR_TBI0</span><br><span class="line">	tcr_set_idmap_t0sz	x10, x9</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Read the PARange bits from ID_AA64MMFR0_EL1 and set the IPS bits in</span></span><br><span class="line"><span class="comment">	 * TCR_EL1.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mrs	x9, ID_AA64MMFR0_EL1</span><br><span class="line">	bfi	x10, x9, #<span class="number">32</span>, #<span class="number">3</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARM64_HW_AFDBM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Hardware update of the Access and Dirty bits.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mrs	x9, ID_AA64MMFR1_EL1</span><br><span class="line">	and	x9, x9, #<span class="number">0xf</span></span><br><span class="line">	cbz	x9, <span class="number">2f</span></span><br><span class="line">	cmp	x9, #<span class="number">2</span></span><br><span class="line">	b.lt	<span class="number">1f</span></span><br><span class="line">	orr	x10, x10, #TCR_HD		<span class="comment">// hardware Dirty flag update</span></span><br><span class="line"><span class="number">1</span>:	orr	x10, x10, #TCR_HA		<span class="comment">// hardware Access flag update</span></span><br><span class="line"><span class="number">2</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* CONFIG_ARM64_HW_AFDBM */</span></span></span><br><span class="line">	msr	tcr_el1, x10</span><br><span class="line">	ret					<span class="comment">// return to head.S</span></span><br><span class="line">ENDPROC(__cpu_setup)</span><br></pre></td></tr></table></figure>

<p>这段汇编代码初始化了CPU的一些寄存器, 如tcr_el1(translation control register)配置虚拟地址的大小, PAGE大小, ASID, share属性, TAG等, 并准备了开启MMU时需要写入sctlr_el1的值.</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>arm64_linux启动流程分析07_开启MMU切换到虚拟地址</title>
    <url>/2017/11/30/3442af41f346/</url>
    <content><![CDATA[<p>这篇内容我们来讲述<code>__primary_switch</code></p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__primary_switch:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RANDOMIZE_BASE</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 保存x0(开启MMU时需要写入sctlr_el1的值, 保存sctlr_el1的当前值</span></span><br><span class="line"><span class="comment">	 * 这两条汇编的作用是为了在开启MMU, 内核发现运行地址和链接地址是一致的时候再次关闭</span></span><br><span class="line"><span class="comment">	 * MMU, 然后通过获取设备树的`kaslr-seed`来将内核移动到一个随机地址运行, 当然如果</span></span><br><span class="line"><span class="comment">	 * 设备树没有`kaslr-seed`或者command line指定了`nokaslr`则就不启动kaslr(也就</span></span><br><span class="line"><span class="comment">	 * 不用返回重启MMU, 重新建立页表了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mov	x19, x0				<span class="comment">// preserve new SCTLR_EL1 value</span></span><br><span class="line">	mrs	x20, sctlr_el1			<span class="comment">// preserve old SCTLR_EL1 value</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* 开启MMU */</span></span><br><span class="line">	bl	__enable_mmu</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RELOCATABLE</span></span><br><span class="line">	<span class="comment">/* 如果因为kaslr的关系, 目前内核的运行地址和链接地址是不同的, 前面的code能正常运行</span></span><br><span class="line"><span class="comment">	 * 是因为所有的指令和数据都是PIC(代码位置无关)的, 后面的code是不能保证的, 所以需要</span></span><br><span class="line"><span class="comment">	 * 用内核的`.rela`段来修复这个问题</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bl	__relocate_kernel</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RANDOMIZE_BASE</span></span><br><span class="line">	<span class="comment">/* 在这里准备swapper的初始化环境, 后面正式跳入C code进行内核初始化, 这个下篇再说 */</span></span><br><span class="line">	ldr	x8, =__primary_switched</span><br><span class="line">	adrp	x0, __PHYS_OFFSET</span><br><span class="line">	blr	x8</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we return here, we have a KASLR displacement in x23 which we need</span></span><br><span class="line"><span class="comment">	 * to take into account by discarding the current kernel mapping and</span></span><br><span class="line"><span class="comment">	 * creating a new one.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果返回到这里表示使用设备树的`kaslr-seed`来启动kaslr, 这里内核已经被重新copy</span></span><br><span class="line"><span class="comment">	 * 到(0xffff_0000_0000_0000 + 128M(module) + kaslr-seed + TEXT_OFFSET的</span></span><br><span class="line"><span class="comment">	 * 位置, 因此内核的页表, 符号都需要重新进行设定. 所以下面的code关闭MMU, 重建页表,</span></span><br><span class="line"><span class="comment">	 * 修复内核符号, 再次跳入__primary_switched</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	msr	sctlr_el1, x20			<span class="comment">// disable the MMU</span></span><br><span class="line">	isb</span><br><span class="line">	bl	__create_page_tables		<span class="comment">// recreate kernel mapping</span></span><br><span class="line"></span><br><span class="line">	tlbi	vmalle1				<span class="comment">// Remove any stale TLB entries</span></span><br><span class="line">	dsb	nsh</span><br><span class="line"></span><br><span class="line">	msr	sctlr_el1, x19			<span class="comment">// re-enable the MMU</span></span><br><span class="line">	isb</span><br><span class="line">	ic	iallu				<span class="comment">// flush instructions fetched</span></span><br><span class="line">	dsb	nsh				<span class="comment">// via old mapping</span></span><br><span class="line">	isb</span><br><span class="line"></span><br><span class="line">	bl	__relocate_kernel</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	ldr	x8, =__primary_switched</span><br><span class="line">	adrp	x0, __PHYS_OFFSET</span><br><span class="line">	br	x8</span><br><span class="line">ENDPROC(__primary_switch)</span><br></pre></td></tr></table></figure>

<p>通过上面的注释, 我们可以大致了解到code的行为和, 我们我们来关注一下行为的细节.</p>
<p>首先是<code>__enable_mmu</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ENTRY(__enable_mmu)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 下面4条代码判断硬件是否实际支持4K页表映射, 如果不支持, 就跳入</span></span><br><span class="line"><span class="comment">	 * `__no_granule_support`, 表明启动失败, CPU调用wfe, wfi进入idle状态</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mrs	x1, ID_AA64MMFR0_EL1</span><br><span class="line">	ubfx	x2, x1, #ID_AA64MMFR0_TGRAN_SHIFT, <span class="number">4</span></span><br><span class="line">	cmp	x2, #ID_AA64MMFR0_TGRAN_SUPPORTED</span><br><span class="line">	b.ne	__no_granule_support</span><br><span class="line">	<span class="comment">/* 在`__early_cpu_boot_status`存入0表明CPU状态正常 */</span></span><br><span class="line">	update_early_cpu_boot_status <span class="number">0</span>, x1, x2</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 设定TTBR0, TTBR1, TTBR0用于虚拟地址MSB都为0时(在这里对应与物理地址相</span></span><br><span class="line"><span class="comment">	 * 等的虚拟地址)的页表映射, TTBR1用于虚拟地址MSB都为1时(在这里对应与物理地</span></span><br><span class="line"><span class="comment">	 * 址相等的虚拟地址)的页表映射. 在正常状态下TTBR0用于用户空间页表映射,</span></span><br><span class="line"><span class="comment">	 * TTBR1用于内核空间页表映射, 分成两个可以在切换进程时, 内核页表不用做切换</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	adrp	x1, idmap_pg_dir</span><br><span class="line">	adrp	x2, swapper_pg_dir</span><br><span class="line">	msr	ttbr0_el1, x1			<span class="comment">// load TTBR0</span></span><br><span class="line">	msr	ttbr1_el1, x2			<span class="comment">// load TTBR1</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 两条isb内存屏障保证中间的指令执行的顺序, isb还需flush cpu的pipe line,</span></span><br><span class="line"><span class="comment">	 * 这样CPU就会在开启MMU之后重新取指令, 可以保证去到的指令的正确性.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	isb</span><br><span class="line">	msr	sctlr_el1, x0</span><br><span class="line">	isb</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Invalidate the local I-cache so that any instructions fetched</span></span><br><span class="line"><span class="comment">	 * speculatively from the PoC are discarded, since they may have</span></span><br><span class="line"><span class="comment">	 * been dynamically patched at the PoU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * iallu = invalidate + all + PoU</span></span><br><span class="line"><span class="comment">	 * 清空左右的icache到PoU保证cpu core的各个模块看到的内容的一致性, dsb nsh</span></span><br><span class="line"><span class="comment">	 * 保证上面的动作在CORE本地(non-sharable)完成. 最后清空CPU pipeline, 返回</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ic	iallu</span><br><span class="line">	dsb	nsh</span><br><span class="line">	isb</span><br><span class="line">	ret</span><br><span class="line"><span class="title function_">ENDPROC</span><span class="params">(__enable_mmu)</span></span><br></pre></td></tr></table></figure>

<p>然后是<code>___relocate_kernel</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__relocate_kernel:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Iterate over each entry in the relocation table, and apply the</span></span><br><span class="line"><span class="comment">	 * relocations in place.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ldr	w9, =__rela_offset		<span class="comment">// offset to reloc table</span></span><br><span class="line">	ldr	w10, =__rela_size		<span class="comment">// size of reloc table</span></span><br><span class="line"></span><br><span class="line">	mov_q	x11, KIMAGE_VADDR		<span class="comment">// default virtual offset</span></span><br><span class="line">	add	x11, x11, x23			<span class="comment">// actual virtual offset</span></span><br><span class="line">	add	x9, x9, x11			<span class="comment">// __va(.rela)</span></span><br><span class="line">	add	x10, x9, x10			<span class="comment">// __va(.rela) + sizeof(.rela)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:	cmp	x9, x10</span><br><span class="line">	b.hs	<span class="number">1f</span></span><br><span class="line">	ldp	x11, x12, [x9], #<span class="number">24</span></span><br><span class="line">	ldr	x13, [x9, #<span class="number">-8</span>]</span><br><span class="line">	cmp	w12, #R_AARCH64_RELATIVE</span><br><span class="line">	b.ne	<span class="number">0b</span></span><br><span class="line">	add	x13, x13, x23			<span class="comment">// relocate</span></span><br><span class="line">	str	x13, [x11, x23]</span><br><span class="line">	b	<span class="number">0b</span></span><br><span class="line"><span class="number">1</span>:	ret</span><br><span class="line">ENDPROC(__relocate_kernel)</span><br></pre></td></tr></table></figure>

<p><code>__rela_offset</code>定义在链接文件中, 如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.rela : ALIGN(<span class="number">8</span>) &#123;</span><br><span class="line">		*(.rela .rela*)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__rela_offset	= ABSOLUTE(ADDR(.rela) - KIMAGE_VADDR);</span><br><span class="line">	__rela_size	= SIZEOF(.rela);</span><br></pre></td></tr></table></figure>

<p>可以看出<code>__rela_offset</code>是<code>.rela</code>段相对KERNEL起始地址的偏移. <code>__rela_size</code>是<code>.rela</code>段的偏移.<br>通过对汇编代码的阅读, 我们大致可以看出<code>.rela</code>段的内容如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">|     <span class="number">64</span> bit     |      <span class="number">64</span> bit     |      <span class="number">64</span> bit     |     ...</span><br><span class="line">+----------------+-----------------------------------+-----------------</span><br><span class="line">| sym0 link addr | sym0 reloc flag | sym0 link value | sym1 link ...</span><br><span class="line">+----------------+-----------------------------------+-----------------</span><br></pre></td></tr></table></figure>

<p>每个relocable symbol有三个entry, 每个entry都是32bit, 分别为link addr, relocation flag, link value. 对于需要重定位内核运行位置的情况, 我们需要把所有FLAG为R_AARCH64_RELATIVE的的entry指定的symbol进行修正, 修正方法为将link addr + offset的值修改为link value + offset. 其实这个段的含义就是说在IMAGE中, link addr的位置中存放的值是地址相关地值, 如果IMAGE发生了整体偏移, 那么link addr的位置实际在link addr + offset, 要把实际位置上的value修正, 这样说不知道是不是更清晰一些.</p>
<p>具体请参阅<a href="https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=8&cad=rja&uact=8&ved=0ahUKEwjimoD4pOXXAhVGnJQKHZLkAGEQFghZMAc&url=http://infocenter.arm.com/help/topic/com.arm.doc.ihi0056b/IHI0056B_aaelf64.pdf&usg=AOvVaw3BbJ_w77JynYnsJJQ767_d">ELF for the ARM 64-bit Architecture (AArch64)</a>, 我也没有细致研究.</p>
<p><code>__primary_switched</code>相关的内容我们放到下一篇内容中, 每一篇内容都少点, 好理解一些.</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>arm64_linux启动流程分析08_正式跳入内核空间虚拟地址段运行</title>
    <url>/2017/11/30/ccd823664217/</url>
    <content><![CDATA[<p>相信一些细心的读者有注意到, 到目前位置, 内核仍然在低地址段运行, 虽然我们已经启动了MMU, 但是仍然运行在等于物理地址的虚拟地址上, 下面我们就要正式的切换到内核态的高地址空间来运行.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ldr	x8, =__primary_switched</span><br><span class="line">adrp	x0, __PHYS_OFFSET</span><br><span class="line">blr	x8</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这段code是上篇遗留的一点内容, 现在来进行分析. 第一条指令是arm的伪指令, 将<code>__primary_switched</code>标签的链接地址放在x8中, 第二条将<code>__PHYS_OFFSET</code>对应的运行时地址存在在x0中, <code>__PHYS_OFFSET</code>虽然名字有PHYS, 但是实际他是指<code>_text - TEXT_OFFSET</code>的链接地址. 它等于0xffff_0000_0000_0000 + 128M(module) + kaslr, 那现在x0存放的应该就是 DDR起始地址 + 2M align预留内存 + kaslr, 然后跳转到x8执行</p>
<p>这里有一点需要注意, 第一条指令加载的是链接地址, 我们现在放置的位置和链接地址是有kaslr的偏移的, 他是如何跳对的呢?</p>
<p>第一条指令实际上变汇编成一条指令加一个内存池, 如:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	ldr x8 __priary_switched_addr</span><br><span class="line">__priary_switched_addr:</span><br><span class="line">	<span class="number">0xffff</span>_xxxx_xxxx_xxxx(也就是__primary_switched的链接地址)</span><br></pre></td></tr></table></figure>

<p>这个内存池实际上就会导致上一篇内容讲的<code>.rela</code>段增加3条内容. 因此在上篇的relocate运行时, 这个地址就已经被修正了. 自然就能跳转到正确的位置了.</p>
<p>来看看<code>__primary_switched</code>的内容(特别注意, 从跳转发生开始, 内核就开始运行到高的虚拟地址上了):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__primary_switched:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 把current SP指到`init_thread_union`的最高位置(ARM64和thread_info和</span></span><br><span class="line"><span class="comment">	 * stack不共用, thread_info放在task_strcut里面, init_thread_union只是用</span></span><br><span class="line"><span class="comment">	 * 于内核堆栈)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	adrp	x4, init_thread_union</span><br><span class="line">	add	sp, x4, #THREAD_SIZE</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 把EL0的sp放在init_task下面, 原因不明, 暂时放着, 目前看起来kernel好像</span></span><br><span class="line"><span class="comment">	 * 有把sp_el0设定在task_struct下面, 这样current实现起来会很容易直接把</span></span><br><span class="line"><span class="comment">	 * sp_el0类型转换一下就能返回进程的task_struct, 另外把thread_info也放在</span></span><br><span class="line"><span class="comment">	 * task_struct的第一个元素, 这个current_thread_info()也就是将current直接</span></span><br><span class="line"><span class="comment">	 * 强制类型转换一下就OK.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	adr_l	x5, init_task</span><br><span class="line">	msr	sp_el0, x5			<span class="comment">// Save thread_info</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化内核的异常向量表, 关于向量表的泪容后续还会在分析 */</span></span><br><span class="line">	adr_l	x8, vectors			<span class="comment">// load VBAR_EL1 with virtual</span></span><br><span class="line">	msr	vbar_el1, x8			<span class="comment">// vector table address</span></span><br><span class="line">	isb</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这一段code就是满足AARCH64 PCS(AArch64 Procedure Call Standard)来写的,</span></span><br><span class="line"><span class="comment">	 * PCS规定x29是FP寄存器, x30是lr寄存器, 在函数被调用时, 首先将fp和lr压</span></span><br><span class="line"><span class="comment">	 * 栈, 然后将sp保存在fp寄存器中. 这里就是完成了这样一个过程, 从而如果调</span></span><br><span class="line"><span class="comment">	 * 用了C code(kaslr就可能会调用设备树相关的C code), C code返回时, 能正确</span></span><br><span class="line"><span class="comment">	 * 的恢复sp, 从而我们也还能正常的返回到前面的`__primary_switch`函数中去,</span></span><br><span class="line"><span class="comment">	 * 由于这里fp没有的, 因此用xzr代替了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	stp	xzr, x30, [sp, #<span class="number">-16</span>]!</span><br><span class="line">	mov	x29, sp</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 把设备树的物理地址存到`__fdt_pointer`中. */</span></span><br><span class="line">	str_l	x21, __fdt_pointer, x5		<span class="comment">// Save FDT pointer</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * kimage_vaddr就是`.quad		_text - TEXT_OFFSET`, 这个值已经</span></span><br><span class="line"><span class="comment">	 * 被relocate修正了kaslr, 所以就是内核目前起始虚拟地址-TEXT_OFFSET,</span></span><br><span class="line"><span class="comment">	 * 也就是0xffff_0000_0000_0000 + 128M(module) + kaslr,</span></span><br><span class="line"><span class="comment">	 * 减掉x0之后就是内核虚拟地址和当前所在的物理地址的offset, 将其存放在</span></span><br><span class="line"><span class="comment">	 * kimage_voffset中.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ldr_l	x4, kimage_vaddr		<span class="comment">// Save the offset between</span></span><br><span class="line">	sub	x4, x4, x0			<span class="comment">// the kernel virtual and</span></span><br><span class="line">	str_l	x4, kimage_voffset, x5		<span class="comment">// physical mappings</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear BSS</span></span><br><span class="line">	adr_l	x0, __bss_start</span><br><span class="line">	mov	x1, xzr</span><br><span class="line">	adr_l	x2, __bss_stop</span><br><span class="line">	sub	x2, x2, x0</span><br><span class="line">	<span class="comment">/* 这里的`__pi_memset`定义在哪里还没搞清楚 */</span></span><br><span class="line">	bl	__pi_memset</span><br><span class="line">	dsb	ishst				<span class="comment">// Make zero page visible to PTW</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line">	<span class="comment">/* KASAN是一个中调试技术, 用来标记内存, 没细致研究 */</span></span><br><span class="line">	bl	kasan_early_init</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RANDOMIZE_BASE</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在第4篇文章中, 我们说到x23保存的是KASLR区域的大小. 如果这里判断如果</span></span><br><span class="line"><span class="comment">	 * x23为0, 那么表示内核没有被放在一个随机地址, 也就是前面说的第二种kaslr</span></span><br><span class="line"><span class="comment">	 * 启动方式没有被 使用, 那么将调用C code `kaslr_early_init`来获取</span></span><br><span class="line"><span class="comment">	 * `kaslr-seed`并搬运内核之后返回`__primary_switch`继续执行 关闭MMU</span></span><br><span class="line"><span class="comment">	 * relocate 开启MMU, 再调过来的过程, 就不细说了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tst	x23, ~(MIN_KIMG_ALIGN - <span class="number">1</span>)	<span class="comment">// already running randomized?</span></span><br><span class="line">	b.ne	<span class="number">0f</span></span><br><span class="line">	mov	x0, x21				<span class="comment">// pass FDT address in x0</span></span><br><span class="line">	bl	kaslr_early_init		<span class="comment">// parse FDT for KASLR options</span></span><br><span class="line">	cbz	x0, <span class="number">0f</span>				<span class="comment">// KASLR disabled? just proceed</span></span><br><span class="line">	orr	x23, x23, x0			<span class="comment">// record KASLR offset</span></span><br><span class="line">	ldp	x29, x30, [sp], #<span class="number">16</span>		<span class="comment">// we must enable KASLR, return</span></span><br><span class="line">	ret					<span class="comment">// to __primary_switch()</span></span><br><span class="line"><span class="number">0</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 这里对sp出栈(增加sp)的上面的出栈只有一个会运行, 要么出栈返回, 要么在</span></span><br><span class="line"><span class="comment">	 * 这里假装出栈, 最后调用`start_kernel`, 由于此处`start_kernel`不会返回,</span></span><br><span class="line"><span class="comment">	 * 我们也无须返回, 所以可以把lr和fp的内容直接抹掉了.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	add	sp, sp, #<span class="number">16</span></span><br><span class="line">	mov	x29, #<span class="number">0</span></span><br><span class="line">	mov	x30, #<span class="number">0</span></span><br><span class="line">	<span class="comment">/* 欢快的进入`start_kernel` C code取执行KERNEL初始化了. */</span></span><br><span class="line">	b	start_kernel</span><br><span class="line"><span class="title function_">ENDPROC</span><span class="params">(__primary_switched)</span></span><br></pre></td></tr></table></figure>

<p>以上就是arm64 linux启动过程的汇编部分的分析.</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>利用numpy的矩阵运算实现自定义转换矩阵的YCbCr2RGB工具</title>
    <url>/2018/01/19/494fd73745e1/</url>
    <content><![CDATA[<p>OpenCV自带的cvtColor色彩空间转换矩阵的转换矩阵好像不太好替换, 目前我没有找到合适的方法来搞定.  最后自己研究了一下, 利用numpy的矩阵运算可以和cvtColor一样快的把YCbCr图片转换成RGB图片.</p>
<p>这里使用了numpy的多维array的dot乘法. 在numpy的document中, 写明了多维array的计算方式:</p>
<span id="more"></span>

<blockquote>
<p><code>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</code></p>
</blockquote>
<p>首先, 我们需要把NV12&#x2F;NV16的YCbCr数据转换成YCbCr444模式.</p>
<p>之后, 目标是把YCbCr的三个通道换算成RGB通道, 也就是说通过一个3x3的矩阵左乘一个[Y, Cb, Cr].T, 就变成了[R, G, B].T了. 由于我们使用的YCbCr是基于BT709的FULL SWING的版本, 也就是说Y, Cb, Cr都是0-255范围的.  因此为了计算的正确性, 先把0 ~ 255的整数除以256换成浮点, 然后把Cb, Cr都减去0.5变成-0.5 ~ 0.5的范围.  然后做矩阵运算, 就可以算出0 ~ 1范围的RGB值了.</p>
<p>考虑YCbCr三个通道是<code>[height x width x 3]</code>, 为了能让YCbCr能被[3 x 3]的矩阵左乘, 需要换一下通道的顺序, 变成<code>[height x 3 x height]</code>, 通过numpy.swapaxis可以实现, 根据前面的dot乘法公式可以知道</p>
<blockquote>
<p><code>[3 x 3] dot [height x 3 x width] --&gt; [3 x height x width]</code></p>
</blockquote>
<p>因此算出的RGB通道同样需要切换一下顺序. 最后把计算好的RGB进行一下范围的限制, 防止溢出就可以了, 最终的程序如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> scipy.misc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShowYuv</span>:</span><br><span class="line">    _bt709_mat = np.linalg.inv(np.array([[<span class="number">0.213</span>, <span class="number">0.715</span>, <span class="number">0.072</span>],</span><br><span class="line">                                         [-<span class="number">0.115</span>, -<span class="number">0.385</span>, <span class="number">0.500</span>],</span><br><span class="line">                                         [<span class="number">0.500</span>, -<span class="number">0.454</span>, -<span class="number">0.046</span>]]))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_show_rgb</span>(<span class="params">rgb</span>):</span><br><span class="line">        plt.imshow(rgb)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_save_rgb</span>(<span class="params">rgb, filename</span>):</span><br><span class="line">        <span class="keyword">if</span> filename <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;saving <span class="subst">&#123;filename&#125;</span>...&#x27;</span>)</span><br><span class="line">            scipy.misc.imsave(filename, rgb)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_process_yuv444</span>(<span class="params">yuv444, filename, bmp</span>):</span><br><span class="line">        rgb = ShowYuv._yuv2rgb(yuv444)</span><br><span class="line">        ShowYuv._show_rgb(rgb)</span><br><span class="line">        <span class="keyword">if</span> bmp:</span><br><span class="line">            ShowYuv._save_rgb(rgb, os.path.splitext(filename)[<span class="number">0</span>] + <span class="string">&#x27;.bmp&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_yuv2rgb</span>(<span class="params">yuv444</span>):</span><br><span class="line">        yuv444 = yuv444 / <span class="number">256</span></span><br><span class="line">        yuv444[:, :, <span class="number">1</span>:] -= <span class="number">0.5</span></span><br><span class="line">        yuv444 = np.transpose(yuv444, (<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">        rgb = np.dot(ShowYuv._bt709_mat, yuv444)</span><br><span class="line">        rgb = np.transpose(rgb, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line">        rgb = np.around(rgb * <span class="number">256</span>)</span><br><span class="line">        rgb = np.clip(rgb, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">        <span class="keyword">return</span> rgb</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">yuv422sp</span>(<span class="params">filename, width, height, bmp=<span class="number">0</span></span>):</span><br><span class="line">        yuv422 = np.fromfile(filename, dtype=np.uint8)</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> * width * height != yuv422.shape[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;width or height error&#x27;</span>)</span><br><span class="line">        yuv444 = np.empty([height, width, <span class="number">3</span>], dtype=np.uint8)</span><br><span class="line">        yuv444[:, :, <span class="number">0</span>] = yuv422[:width * height].reshape(height, width)</span><br><span class="line">        u = yuv422[width * height::<span class="number">2</span>].reshape(height, width // <span class="number">2</span>)</span><br><span class="line">        yuv444[:, :, <span class="number">1</span>] = scipy.misc.imresize(u, (height, width))</span><br><span class="line">        v = yuv422[width * height + <span class="number">1</span>::<span class="number">2</span>].reshape(height, width // <span class="number">2</span>)</span><br><span class="line">        yuv444[:, :, <span class="number">2</span>] = scipy.misc.imresize(v, (height, width))</span><br><span class="line">        ShowYuv._process_yuv444(yuv444, filename, bmp)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">yuv420sp</span>(<span class="params">filename, width, height, bmp=<span class="number">0</span></span>):</span><br><span class="line">        yuv420 = np.fromfile(filename, dtype=np.uint8)</span><br><span class="line">        <span class="keyword">if</span> <span class="number">3</span> * width * height // <span class="number">2</span> != yuv420.shape[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;width or height error&#x27;</span>)</span><br><span class="line">        yuv444 = np.empty([height, width, <span class="number">3</span>], dtype=np.uint8)</span><br><span class="line">        yuv444[:, :, <span class="number">0</span>] = yuv420[:width * height].reshape(height, width)</span><br><span class="line">        u = yuv420[width * height::<span class="number">2</span>].reshape(height // <span class="number">2</span>, width // <span class="number">2</span>)</span><br><span class="line">        yuv444[:, :, <span class="number">1</span>] = scipy.misc.imresize(u, (height, width))</span><br><span class="line">        v = yuv420[width * height + <span class="number">1</span>::<span class="number">2</span>].reshape(height // <span class="number">2</span>, width // <span class="number">2</span>)</span><br><span class="line">        yuv444[:, :, <span class="number">2</span>] = scipy.misc.imresize(v, (height, width))</span><br><span class="line">        ShowYuv._process_yuv444(yuv444, filename, bmp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fire.Fire(ShowYuv)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>image</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>使用vscode和qemu调试linux内核（包含汇编）</title>
    <url>/2022/04/26/b76ba7cb1323/</url>
    <content><![CDATA[<p>vscode调试kernel的汇编部分有两个麻烦点</p>
<ul>
<li>linux加载地址和链接地址不同</li>
<li>vscode的默认setupCommands无法正常使用<span id="more"></span></li>
</ul>
<p>通过一段时间的摸索我找到了调试这部分代码的方法</p>
<ul>
<li>对于加载地址问题，可以通过gdb的add-symbol-file的-o参数来解决（这要求gdb的版本较新才可以）</li>
<li>对于vscode的配置，后面我会列出目前摸索出的配置文件供参考</li>
</ul>
<h1 id="调试步骤"><a href="#调试步骤" class="headerlink" title="调试步骤"></a>调试步骤</h1><ul>
<li><p>编译linux内核，目前我使用的是linux-5.17.4内核</p>
<p>  为了能更好的支持c的调试，我这边尽可能的将C代码通过O0编译，对kernel做了如下修改, 并且编译去掉了CONFIG_JUMP_LABEL：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm64/Makefile b/arch/arm64/Makefile</span><br><span class="line">index 2f1de8865..27ecec930 100644</span><br><span class="line">--- a/arch/arm64/Makefile</span><br><span class="line">+++ b/arch/arm64/Makefile</span><br><span class="line">@@ -213,3 +213,5 @@ define archhelp</span><br><span class="line">   echo  &#x27;                  (distribution) /sbin/installkernel or&#x27;</span><br><span class="line">   echo  &#x27;                  install to $$(INSTALL_PATH) and run lilo&#x27;</span><br><span class="line"> endef</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O0</span><br><span class="line">diff --git a/drivers/Makefile b/drivers/Makefile</span><br><span class="line">index a110338c8..da99b36a1 100644</span><br><span class="line">--- a/drivers/Makefile</span><br><span class="line">+++ b/drivers/Makefile</span><br><span class="line">@@ -187,3 +187,5 @@ obj-$(CONFIG_GNSS)		+= gnss/</span><br><span class="line"> obj-$(CONFIG_INTERCONNECT)	+= interconnect/</span><br><span class="line"> obj-$(CONFIG_COUNTER)		+= counter/</span><br><span class="line"> obj-$(CONFIG_MOST)		+= most/</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O0</span><br><span class="line">diff --git a/drivers/char/tpm/Makefile b/drivers/char/tpm/Makefile</span><br><span class="line">index 66d39ea6b..252f4d9d2 100644</span><br><span class="line">--- a/drivers/char/tpm/Makefile</span><br><span class="line">+++ b/drivers/char/tpm/Makefile</span><br><span class="line">@@ -41,3 +41,5 @@ obj-$(CONFIG_TCG_XEN) += xen-tpmfront.o</span><br><span class="line"> obj-$(CONFIG_TCG_CRB) += tpm_crb.o</span><br><span class="line"> obj-$(CONFIG_TCG_VTPM_PROXY) += tpm_vtpm_proxy.o</span><br><span class="line"> obj-$(CONFIG_TCG_FTPM_TEE) += tpm_ftpm_tee.o</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O1</span><br><span class="line">diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile</span><br><span class="line">index b2728d00f..f369abb70 100644</span><br><span class="line">--- a/drivers/net/phy/Makefile</span><br><span class="line">+++ b/drivers/net/phy/Makefile</span><br><span class="line">@@ -85,3 +85,5 @@ obj-$(CONFIG_STE10XP)		+= ste10Xp.o</span><br><span class="line"> obj-$(CONFIG_TERANETICS_PHY)	+= teranetics.o</span><br><span class="line"> obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o</span><br><span class="line"> obj-$(CONFIG_XILINX_GMII2RGMII) += xilinx_gmii2rgmii.o</span><br><span class="line">+</span><br><span class="line">+CFLAGS_phylink.o = -O1</span><br><span class="line">diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h</span><br><span class="line">index 472843eed..06d6edcdf 100644</span><br><span class="line">--- a/include/net/sch_generic.h</span><br><span class="line">+++ b/include/net/sch_generic.h</span><br><span class="line">@@ -512,7 +512,7 @@ static inline bool lockdep_tcf_proto_is_locked(struct tcf_proto *tp)</span><br><span class="line"></span><br><span class="line"> static inline void qdisc_cb_private_validate(const struct sk_buff *skb, int sz)</span><br><span class="line"> &#123;</span><br><span class="line">-	struct qdisc_skb_cb *qcb;</span><br><span class="line">+	struct qdisc_skb_cb *qcb __attribute__((unused));</span><br><span class="line"></span><br><span class="line"> 	BUILD_BUG_ON(sizeof(skb-&gt;cb) &lt; sizeof(*qcb));</span><br><span class="line"> 	BUILD_BUG_ON(sizeof(qcb-&gt;data) &lt; sz);</span><br><span class="line">diff --git a/init/Makefile b/init/Makefile</span><br><span class="line">index 06326e304..9a0b7f269 100644</span><br><span class="line">--- a/init/Makefile</span><br><span class="line">+++ b/init/Makefile</span><br><span class="line">@@ -35,3 +35,5 @@ quiet_cmd_compile.h = CHK     $@</span><br><span class="line"></span><br><span class="line"> include/generated/compile.h: FORCE</span><br><span class="line"> 	$(call cmd,compile.h)</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O0</span><br><span class="line">diff --git a/kernel/Makefile b/kernel/Makefile</span><br><span class="line">index a18d16973..aeaa9d6d8 100644</span><br><span class="line">--- a/kernel/Makefile</span><br><span class="line">+++ b/kernel/Makefile</span><br><span class="line">@@ -160,3 +160,5 @@ $(obj)/kheaders_data.tar.xz: FORCE</span><br><span class="line"> 	$(call cmd,genikh)</span><br><span class="line"></span><br><span class="line"> clean-files := kheaders_data.tar.xz kheaders.md5</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O0</span><br><span class="line">diff --git a/kernel/bpf/Makefile b/kernel/bpf/Makefile</span><br><span class="line">index c1a9be6a4..d4713f4e3 100644</span><br><span class="line">--- a/kernel/bpf/Makefile</span><br><span class="line">+++ b/kernel/bpf/Makefile</span><br><span class="line">@@ -40,3 +40,5 @@ obj-$(CONFIG_BPF_PRELOAD) += preload/</span><br><span class="line"> obj-$(CONFIG_BPF_SYSCALL) += relo_core.o</span><br><span class="line"> $(obj)/relo_core.o: $(srctree)/tools/lib/bpf/relo_core.c FORCE</span><br><span class="line"> 	$(call if_changed_rule,cc_o_c)</span><br><span class="line">+</span><br><span class="line">+CFLAGS_core.o = -O1</span><br><span class="line">diff --git a/kernel/dma/Makefile b/kernel/dma/Makefile</span><br><span class="line">index 0dd65ec1d..a09453711 100644</span><br><span class="line">--- a/kernel/dma/Makefile</span><br><span class="line">+++ b/kernel/dma/Makefile</span><br><span class="line">@@ -10,3 +10,5 @@ obj-$(CONFIG_SWIOTLB)			+= swiotlb.o</span><br><span class="line"> obj-$(CONFIG_DMA_COHERENT_POOL)		+= pool.o</span><br><span class="line"> obj-$(CONFIG_DMA_REMAP)			+= remap.o</span><br><span class="line"> obj-$(CONFIG_DMA_MAP_BENCHMARK)		+= map_benchmark.o</span><br><span class="line">+</span><br><span class="line">+CFLAGS_direct.o = -O1</span><br><span class="line">diff --git a/lib/Makefile b/lib/Makefile</span><br><span class="line">index 300f569c6..98aa9a698 100644</span><br><span class="line">--- a/lib/Makefile</span><br><span class="line">+++ b/lib/Makefile</span><br><span class="line">@@ -398,3 +398,5 @@ $(obj)/$(TEST_FORTIFY_LOG): $(addprefix $(obj)/, $(TEST_FORTIFY_LOGS)) FORCE</span><br><span class="line"> ifeq ($(CONFIG_FORTIFY_SOURCE),y)</span><br><span class="line"> $(obj)/string.o: $(obj)/$(TEST_FORTIFY_LOG)</span><br><span class="line"> endif</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O0</span><br><span class="line">diff --git a/lib/zstd/Makefile b/lib/zstd/Makefile</span><br><span class="line">index fc45339fc..96cb0ce27 100644</span><br><span class="line">--- a/lib/zstd/Makefile</span><br><span class="line">+++ b/lib/zstd/Makefile</span><br><span class="line">@@ -42,3 +42,5 @@ zstd_decompress-y := \</span><br><span class="line"> 		decompress/zstd_ddict.o \</span><br><span class="line"> 		decompress/zstd_decompress.o \</span><br><span class="line"> 		decompress/zstd_decompress_block.o \</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O1</span><br><span class="line">diff --git a/mm/Makefile b/mm/Makefile</span><br><span class="line">index 70d4309c9..c225b254c 100644</span><br><span class="line">--- a/mm/Makefile</span><br><span class="line">+++ b/mm/Makefile</span><br><span class="line">@@ -132,3 +132,12 @@ obj-$(CONFIG_PAGE_REPORTING) += page_reporting.o</span><br><span class="line"> obj-$(CONFIG_IO_MAPPING) += io-mapping.o</span><br><span class="line"> obj-$(CONFIG_HAVE_BOOTMEM_INFO_NODE) += bootmem_info.o</span><br><span class="line"> obj-$(CONFIG_GENERIC_IOREMAP) += ioremap.o</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O0</span><br><span class="line">+CFLAGS_truncate.o = -O1</span><br><span class="line">+CFLAGS_gup.o = -O1</span><br><span class="line">+CFLAGS_memory.o = -O1</span><br><span class="line">+CFLAGS_pagewalk.o = -O1</span><br><span class="line">+CFLAGS_page_io.o = -O1</span><br><span class="line">+CFLAGS_vmalloc.o = -O1</span><br><span class="line">+CFLAGS_swapfile.o = -O1</span><br></pre></td></tr></table></figure>
</li>
<li><p>将vscode的launch按如下方式进行配置</p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/vmlinux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/gngshn/.local/opt/aarch64-buildroot-linux-gnu/bin/aarch64-linux-gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;targetArchitecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arm64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;customLaunchSetupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;add-symbol-file vmlinux&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;add-symbol-file vmlinux -o -0xffff7fffc7e00000&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b _text&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;target remote :1234&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用qemu打开linux</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M virt -cpu cortex-a53 -smp 4 -m 4G -nographic -append &quot;console=ttyAMA0&quot; -kernel arch/arm64/boot/Image -initrd ../rootfs.cpio.uboot -S -s</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接再vscode中按F5开始调试即可</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vscode</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8 memory model</title>
    <url>/2022/05/09/e739740fa272/</url>
    <content><![CDATA[<p>在这边文章中, 我将以一个程序员的视角来谈一下我对ARMv8-A中的memory model的理解. 涉及到domain, atomic, ordering等. 如有错误请指正.</p>
<p>我会首先贴出ARM的官方描述, 然后在后面简要的描述一下我自己的理解. 部分章节或内容细节省略掉了.</p>
<span id="more"></span>

<ul>
<li><h1 id="Atomicity-in-the-Arm-architecture"><a href="#Atomicity-in-the-Arm-architecture" class="headerlink" title="Atomicity in the Arm architecture"></a>Atomicity in the Arm architecture</h1><p>这里要注意的是, 此处所说的atomic并非是原子指令所说的原子. 这里描述的是系统对一段memory的访问(读或写)是否是一笔完成, 不被其他transaction打断. 或者说读或写不会和其他读或写产生交叉. 不会读到部分写效果, 也不会只写一部分.</p>
<ul>
<li><h2 id="Requirements-for-single-copy-atomicity"><a href="#Requirements-for-single-copy-atomicity" class="headerlink" title="Requirements for single-copy atomicity"></a>Requirements for single-copy atomicity</h2><p>For explicit memory effects generated from an Exception level the following rules apply:</p>
<ul>
<li>A read that is generated by a load instruction that loads a single general-purpose register and is aligned to the size of the read in the instruction is single-copy atomic.</li>
<li>A write that is generated by a store instruction that stores a single general-purpose register and is aligned to the size of the write in the instruction is single-copy atomic.</li>
<li>Reads that are generated by a Load Pair instruction that loads two general-purpose registers and are aligned to the size of the load to each register are treated as two single-copy atomic reads, one for each register being loaded.</li>
<li>Writes that are generated by a Store pair instruction that stores two general-purpose registers and are aligned to the size of the store of each register are treated as two single-copy atomic writes, one for each register being stored.</li>
<li>Load-Exclusive Pair instructions of two 32-bit quantities and Store-Exclusive Pair instructions of 32-bit quantities are single-copy atomic.</li>
<li>When the Store-Exclusive of a Load-Exclusive&#x2F;Store-Exclusive pair instruction using two 64-bit quantities succeeds, it causes a single-copy atomic update of the entire memory location being updated.<blockquote>
<p>Note: To atomically load two 64-bit quantities, perform a Load-Exclusive pair&#x2F;Store-Exclusive pair sequence of reading and writing the same value for which the Store-Exclusive pair succeeds, and use the read values from the Load-Exclusive pair.</p>
</blockquote>
</li>
<li>Where translation table walks generate a read of a translation table entry, this read is single-copy atomic.</li>
<li>…</li>
</ul>
<p>注意的是这里的copy不要理解为复制, 个人认为这里理解为一份或副本可能更好一点. 后面会在multi-copy中再来细说这个.</p>
<p>这里描述single-copy atomicity的要求, 如要求对齐的load&#x2F;store是原子的. 对于load pair指令也有相应的约束, 细节可以逐条看spec. 就不啰嗦了.</p>
</li>
<li><h2 id="Properties-of-single-copy-atomic-accesses"><a href="#Properties-of-single-copy-atomic-accesses" class="headerlink" title="Properties of single-copy atomic accesses"></a>Properties of single-copy atomic accesses</h2><p>A memory access instruction that is single-copy atomic has the following properties:</p>
<ul>
<li>For a pair of overlapping single-copy atomic store instructions, all of the overlapping writes generated by one of the stores are Coherence-after the corresponding overlapping writes generated by the other store.</li>
<li>For a single-copy atomic load instruction L1 that overlaps a single-copy atomic store instruction S2, if one of the overlapping reads generated by L1 Reads-from one of the overlapping writes generated by S2, then none of the overlapping writes generated by S2 are Coherence-after the corresponding overlapping reads generated by L1.</li>
</ul>
<p>对于single-atomic的访存指令, 他有如下的属性:</p>
<ul>
<li>如果两条store指令有overlaping(见后面的overlapping access), 则两条指令一定是先后完成的. 也就是说, 两条指令不会同时修改内存, 而是一条修改完之后, 另一条才进行修改</li>
<li>如果load指令L1和store指令S2有重叠, 如果L1读到了S2的store的一个location(byte, 可以重叠多个location), 则L1一定读到了S2 store的所有overlap location, 也就是说如果L1不会读到S2部分的结果, 要么读到的是S2完成后的结果, 要么读到的是S2未产生效果时的结果.</li>
</ul>
</li>
<li><h2 id="Multi-copy-atomicity"><a href="#Multi-copy-atomicity" class="headerlink" title="Multi-copy atomicity"></a>Multi-copy atomicity</h2><p>In a multiprocessing system, writes to a memory location are multi-copy atomic if the following conditions are both true:</p>
<ul>
<li>All writes to the same location are serialized, meaning they are observed in the same order by all observers, although some observers might not observe all of the writes.</li>
<li>A read of a location does not return the value of a write until all observers observe that write.</li>
</ul>
<blockquote>
<p>Note: Writes that are not coherent are not multi-copy atomic.</p>
</blockquote>
<p>multi-copy atomicity描述的是多个PE(Processing Element, 可以认为是一个cpu core)的atomic, 个人理解, 这里的multi-copy可以认为是多个PE都可能有同一个location的副本(copy, 我觉得可以看做cache), 他们之间存在observed-by的关系. multi-copy atomic要求: 所有的observers对同一个location发起的写必须是完全顺序的, 每一笔写都<strong>可以</strong>被所有的observer观察到(当然observer不一定会去实际观察, 因此observer可能不会观察到所有的写, 但是观察到的写的顺序一定是一致的, 比如A, B, C, D四个写, Observer1观察到了A, C, D, Observer2观察到了B, D, Observer3观察到了A, C). 并且写指令在所有观察者可以观察到这个写之前是不能返回的. 另外这里的观察到可以见后面的observed-by详细描述.</p>
<p>从硬件上来看, 我觉得可以这样来理解, 在多核系统上, 多个observer都有自己的cache, 他们可以通过一定的cache总线和协议(如CCI和MOESI)来维护cache一致性. 对于multi-copy atomicity来说, 当一个observer对一个location发起写操作时, 其他的observer上的对应cache条目需要被invalid&#x2F;update(相当于观察到了这笔写)后才算这笔写完成(指令才能返回). 因此multi-copy atomicity是一个很高的原子要求. 写会变得很慢.</p>
<p>因此, arm的memory model不是使用的multi-copy atomicity, 而是使用的other-multi-copy aomicity. 这个后续会讲到.</p>
<p>但是这里要再多讲一句，ARM所说的multi-copy atomic和其他架构说的不是一回事，ARM的other-multi-copy atomic和我们常说的multi-copy atomic其实是一回事</p>
</li>
<li><h2 id="Requirements-for-multi-copy-atomicity"><a href="#Requirements-for-multi-copy-atomicity" class="headerlink" title="Requirements for multi-copy atomicity"></a>Requirements for multi-copy atomicity</h2><p>For Normal memory, writes are not required to be multi-copy atomic.</p>
<p>For Device memory, writes are not required to be multi-copy atomic.</p>
<p>The Arm memory model is Other-multi-copy atomic.</p>
<p>ARMv8不要求multi-copy atomicity, 而是要求other-multi-copy atomicity</p>
</li>
</ul>
</li>
<li><h1 id="Definition-of-the-Arm-memory-model"><a href="#Definition-of-the-Arm-memory-model" class="headerlink" title="Definition of the Arm memory model"></a>Definition of the Arm memory model</h1><ul>
<li><h2 id="Basic-definations"><a href="#Basic-definations" class="headerlink" title="Basic definations"></a>Basic definations</h2><p>ARMv8 memory model中有很多的概念, 这里抽出来一些来讲一下:</p>
<ul>
<li><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>An Observer refers to a processing element or mechanism in the system, such as a peripheral device, that can generate reads from, or writes to, memory.</p>
<p>Observer就是一个可以发起读写的master, 可以是一个外设, 或CPU内部能够发起读写的一些组件(取指, load&#x2F;store, MMU)等.</p>
</li>
<li><h3 id="Common-Shareability-Domain"><a href="#Common-Shareability-Domain" class="headerlink" title="Common Shareability Domain"></a>Common Shareability Domain</h3><p>For the purpose of this section, all Observers are assumed to belong to a Common Shareability Domain. All read and write effects access only Normal memory locations in a Common Shareability Domain, and excludes the situations described in Mismatched memory attributes on page B2-205.</p>
<p>我们这里讲的observers都是在同一个sharebility domain, 并且都是对normal memory发起的访问. sharebility domain在后面会讲到</p>
</li>
<li><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>A Location is a byte that is associated with an address in the physical address space.</p>
<blockquote>
<p>Note: It is expected that an operating system will present the illusion to the application programmer that is consistent with a location also being considered as a byte that is associated with an address in the virtual address space.</p>
</blockquote>
<p>Location就是对应到一个物理地址的byte. 另外操作系统可以透明的让程序员看到用虚拟地址对应的byte.</p>
</li>
<li><h3 id="Effects"><a href="#Effects" class="headerlink" title="Effects"></a>Effects</h3><p>The Effects of an instruction can be:</p>
<ul>
<li>Register effects.</li>
<li>Memory effects.</li>
<li>Barrier effects.</li>
<li>Tag effects.</li>
<li>Branching effects.</li>
</ul>
<p>The effects of an instruction I1 are said to appear in program order before the effects of an instruction I2 if and only if I1 occurs before I2 in the order specified by the program. Each effect generated by an instruction has a unique identifier, which characterizes it amongst the events generated by the same instruction.</p>
<p>Effect是一条指令的效果, 它可以是引起寄存器被读写, 内存被读写, 产生屏障, Tag(这里我没细看), 产生跳转决策等</p>
<p>如果说指令I1和I2是按照程序顺序发生, 那么他们产生的effect也是按程序顺序发生的</p>
</li>
<li><h3 id="Register-effect"><a href="#Register-effect" class="headerlink" title="Register effect"></a>Register effect</h3><p>The Register effects of an instruction are register reads or register writes of that instruction. For an instruction that accesses registers, a register read effect is generated for each register read by the instruction and a register write effect is generated for each register written by the instruction. An instruction may generate both read and write Register effects.</p>
<p>Register effect是一条指令产生对寄存器读或写的效果, 一条指令可以同时产生读效果和写效果</p>
</li>
<li><h3 id="Memory-effect"><a href="#Memory-effect" class="headerlink" title="Memory effect"></a>Memory effect</h3><p>The Memory effects of an instruction are the memory reads or writes generated by that instruction. For an instruction that accesses memory, a memory read effect is generated for each Location read by the instruction and a memory write effect is generated for each Location written by the instruction. An instruction may generate both read and write Memory effects.</p>
<p>Memory effect是一条指令产生对memory读或写的效果, 一条指令可以同时产生读效果和写效果, 比如原子改写指令LDADD等</p>
</li>
<li><h3 id="Reads-from"><a href="#Reads-from" class="headerlink" title="Reads-from"></a>Reads-from</h3><p>The Reads-from relation couples memory read and write effects to the same Location such that each memory read effect is paired with exactly one memory write effect in the execution of a program. A memory read effect R2 from a Location Reads-from a memory write effect W1 to the same Location if and only if R2 takes its data from W1.</p>
<p>Reads-from的意思是如果读效果R1读到的是写效果W1的结果, 那么R1 reads-from W1. 比如一条load指令, 加载了一条store指令store到memory中的结果.</p>
</li>
<li><h3 id="Local-read-successor"><a href="#Local-read-successor" class="headerlink" title="Local read successor"></a>Local read successor</h3><p>A memory read effect R2 of a Location is the Local read successor of a memory write effect W1 from the same Observer to the same Location if and only if W1 appears in program order before R2 and there is not a memory write effect W3 from the same Observer to the same Location appearing in program order between W1 and R2.</p>
<p>同一个observer对同一个location的读写, 如果读R2读到的是W1的结果, 那么R2 local read successor W1.</p>
</li>
<li><h3 id="Local-write-successor"><a href="#Local-write-successor" class="headerlink" title="Local write successor"></a>Local write successor</h3><p>A memory write effect W2 of a Location is a Local write successor of a memory read or write effect RW1 from the same Observer to the same Location if and only if RW1 appears in program order before W2.</p>
<p>同一个observer对同一个location的读写, 如果写W2是在读或写RW1之后发生, 则W2 local write successor RW1</p>
</li>
<li><h3 id="Coherence-order"><a href="#Coherence-order" class="headerlink" title="Coherence order"></a>Coherence order</h3><p>There is a per-location Coherence order relation that provides a total order over all memory write effects from all coherent Observers to that Location, starting with a notional memory write effect of the initial value. The Coherence order of a Location represents the order in which memory write effects to the Location arrive at memory.</p>
<p>Coherence order是指所有的coherence observers观察到的对同一个location写到达的顺序</p>
</li>
<li><h3 id="Coherence-after"><a href="#Coherence-after" class="headerlink" title="Coherence-after"></a>Coherence-after</h3><p>A memory write effect W2 to a Location is Coherence-after another memory write effect W1 to the same Location if and only if W2 is sequenced after W1 in the Coherence order of the Location.</p>
<p>写W2 Coherence-after写W1, 表示在同一个location上, W2在W1之后到达</p>
<p>A memory write effect W2 to a Location is Coherence-after a memory read effect R1 of the same location if and only if R1 Reads-from a memory write effect W3 to the same Location and W2 is Coherence-after W3.</p>
<p>写W2 Coherence-after读R1, 表示在同一个location上, R1读到是W2前的W3产生的写, 顺序是W3-&gt;R1-&gt;W2</p>
<p>可以看到coherence-after表示的是在同一location上一个写后于读&#x2F;写的含义</p>
</li>
<li><h3 id="Observed-by"><a href="#Observed-by" class="headerlink" title="Observed-by"></a>Observed-by</h3><p>A memory read or write effect RW1 from an Observer is Observed-by a memory write effect W2 from a different Observer if and only if W2 is coherence-after RW1.</p>
<p>RW1被W2观察到(RW1 observed-by W2), 表示W2 Coherence-after RW1, 也就是说W2比RW1后到达location, 且W2和RW1中间没有其他Wx</p>
<p>A memory write effect W1 from an Observer is Observed-by a memory read effect R2 from a different Observer if and only if R2 Reads-from W1.</p>
<p>W1被R2观察到(W1 observed-by R2), 表示R2 reads-from W1, 也就是说R2读到了W1的结果</p>
<blockquote>
<p>Note: The Observed-by relation relates only Memory effects generated by different Observers.</p>
</blockquote>
<p>observed-by描述的是不同的observer对一个location的操作顺序</p>
<p>这里的observed不要理解成读, observed并不需要读(load)到哪个数据才叫observed, 只要满足上面两条就可以看做observed</p>
</li>
<li><h3 id="Overlapping-accesses"><a href="#Overlapping-accesses" class="headerlink" title="Overlapping accesses"></a>Overlapping accesses</h3><p>Two Memory effects overlap if and only if they access the same Location. Two instructions overlap if and only if one or more of their generated Memory effects overlap.</p>
<p>memory effect overlap是指访问到了相同的location(byte), instruction overlap是指两条指令产生了访问到了相同的location(bytes)</p>
</li>
</ul>
</li>
<li><h2 id="Ordering-constraints"><a href="#Ordering-constraints" class="headerlink" title="Ordering constraints"></a>Ordering constraints</h2><p>The Arm memory model is described as being Other-multi-copy atomic. The definition of Other-multi-copy atomic is as follows:</p>
<ul>
<li><h3 id="Other-multi-copy-atomic"><a href="#Other-multi-copy-atomic" class="headerlink" title="Other-multi-copy atomic"></a>Other-multi-copy atomic</h3><p>In an Other-multi-copy atomic system, it is required that a memory write effect from an Observer, if observed by a different Observer, is then observed by all other Observers that access the Location coherently. It is, however, permitted for an Observer to observe its own writes prior to making them visible to other observers in the system.</p>
<p>ARMv8使用的是other-multi-copy atomic, other-multi-copy atomic要求, 对于其中一个observer的写, 如果被任意一个observer观察到, 那么所有其他的observers都必须能观察到这笔写. 并且发起写的这个observer是可以比其他observer先观察到它自己的这笔写的.</p>
<p>从硬件上来讲, 这表示一个PE执行写操作之后, 是可以立即返回的. 不用等CCI总线基于MOESI去对cache进行操作, 就可以执行完成返回, 继续下一条指令了. 如果其中一个observer观察到了这笔写(也就是说那个observer的cache已经同步了), 那么所有的observer的cache都必须已经同步.</p>
</li>
</ul>
</li>
<li><h2 id="Memory-barriers"><a href="#Memory-barriers" class="headerlink" title="Memory barriers"></a>Memory barriers</h2><p>Memory barrier is the general term applied to an instruction, or sequence of instructions, that forces synchronization events by a PE with respect to retiring load&#x2F;store instructions. The memory barriers defined by the Arm architecture provide a range of functionality, including:</p>
<ul>
<li>Ordering of load&#x2F;store instructions.</li>
<li>Completion of load&#x2F;store instructions.</li>
<li>Context synchronization.</li>
</ul>
<ul>
<li><h3 id="Instruction-Synchronization-Barrier-ISB"><a href="#Instruction-Synchronization-Barrier-ISB" class="headerlink" title="Instruction Synchronization Barrier (ISB)"></a>Instruction Synchronization Barrier (ISB)</h3><p>An ISB instruction ensures that all instructions that come after the ISB instruction in program order are fetched from the cache or memory after the ISB instruction has completed. Using an ISB ensures that the effects of context-changing operations executed before the ISB are visible to the instructions fetched after the ISB instruction. Examples of context-changing operations that require the insertion of an ISB instruction to ensure the effects of the operation are visible to instructions fetched after the ISB instruction are:</p>
<ul>
<li>Completed cache and TLB maintenance instructions.</li>
<li>Changes to System registers.</li>
</ul>
<p>Any context-changing operations appearing in program order after the ISB instruction take effect only after the ISB has been executed.</p>
<p>ISB保证和ISB指令完成后, 所有的指令都会cache&#x2F;memory重新获取. 从硬件上看, 相当于把CPU的pipeline flush掉, 然后从ISB后面的指令开始重新跑. ISB可以保证cache和TLB的操作或system寄存器的修改产生的效果能实际影响到ISB后面的指令. 在进程切换, cache操作, MMU操作, system寄存器修改后之后往往需要ISB来保证后续的指令是在上述操作之后的环境下产生的执行效果.</p>
<p>网上有很多博主说ISB是比DSB更加严格的barriar, 其实这是不对的. ISB和DSB是两个不同的概念, 他们的目的也不一样. DSB有ISB无法完成的功能, ISB也有DSB无法完成的功能.</p>
</li>
<li><h3 id="Data-Memory-Barrier-DMB"><a href="#Data-Memory-Barrier-DMB" class="headerlink" title="Data Memory Barrier (DMB)"></a>Data Memory Barrier (DMB)</h3><p>The DMB instruction is a memory barrier instruction that ensures the relative order of memory accesses before the barrier with memory accesses after the barrier. The DMB instruction does not ensure the completion of any of the memory accesses for which it ensures relative order.</p>
<p>The basic principle of a DMB instruction is to introduce order between memory accesses that are specified to be affected by the DMB options supplied as arguments to the DMB instruction. The DMB instruction ensures that all affected memory accesses by the PE executing the DMB instruction that appear in program order before the DMB instruction and those which originate from a different PE, to the extent required by the DMB options, which have been Observed-by the PE before the DMB instruction is executed, are Observed-by each PE, to the extent required by the DMB options, before any affected memory accesses that appear in program order after the DMB instruction are Observed-by that PE.</p>
<p>DMB保证了DMB前面的和后面的load&#x2F;store&#x2F;cache指令不会越过DMB发生乱序, DMB只保证顺序, 不保证前面的命令执行完成.</p>
<p>DMB指令可以在后面加参数来表示它限制的指令类型, 和保证生效的domain. 如DMB ISHST, ISH表示inner-shareable, ST表示限制STORE-STORE的顺序, 这条指令可以保证当前PE在DMB之后的指令观察到DMB前面的store的结果之前, 整个inner-shareable domain其他PE也都可以观察到DMB前面的store的结果, 关于domain, 后面会讲到</p>
</li>
<li><h3 id="Data-Synchronization-Barrier-DSB"><a href="#Data-Synchronization-Barrier-DSB" class="headerlink" title="Data Synchronization Barrier (DSB)"></a>Data Synchronization Barrier (DSB)</h3><p>A DSB instruction is a memory barrier that ensures that memory accesses that occur before the DSB instruction have completed before the completion of the DSB instruction. In doing this, it acts as a stronger barrier than a DMB and all ordering that is created by a DMB with specific options is also generated by a DSB with the same options.</p>
<p>A DSB instruction executed by a PE, PEe, completes when all of the following apply:</p>
<p>In addition, no instruction that appears in program order after the DSB instruction can alter any state of the system or perform any part of its functionality until the DSB completes other than:</p>
<ul>
<li>Being fetched from memory and decoded.</li>
<li>Reading the general-purpose, SIMD and floating-point, SVE vector or predicate, Special-purpose, or System registers that are directly or indirectly read without causing side-effects.</li>
<li>If FEAT_ETS is not implemented, having any virtual addresses of loads and stores translated.</li>
</ul>
<p>DSB是一个比DMB更强约束的指令, 并且和DMB一样可以在后面加参数产生一样的限制效果, DSB约束更强表现为:</p>
<ul>
<li>在DSB前面的load&#x2F;store&#x2F;cache完成之前, dsb不会返回, 相当于其他PE可以观察到dsb前面的这些操作前不能返回</li>
<li>DSB代码序(程序顺序)后面的所有会影响系统状态的指令都不会在DSB完成之前执行. 个人理解就是这些指令不能乱序到DMB前面来执行</li>
</ul>
</li>
<li><h3 id="Shareability-and-access-limitations-on-the-data-barrier-operations"><a href="#Shareability-and-access-limitations-on-the-data-barrier-operations" class="headerlink" title="Shareability and access limitations on the data barrier operations"></a>Shareability and access limitations on the data barrier operations</h3><p>The DMB and DSB instructions take an argument that specifies:</p>
<ul>
<li><p>The shareability domain over which the instruction must operate. This is one of:</p>
<ul>
<li>Full system.</li>
<li>Outer Shareable.</li>
<li>Inner Shareable.</li>
<li>Non-shareable.</li>
</ul>
</li>
</ul>
<p>Full system applies to all the observers in the system and, as such, encompasses the Inner and Outer Shareable domains of the processor.</p>
<ul>
<li><p>The accesses for which the instruction operates. This is one of:</p>
<ul>
<li>Read and write accesses, both before and after the barrier instruction.</li>
<li>Write accesses only, before and after the barrier instruction.</li>
<li>Read accesses before the barrier instruction, and read and write accesses after the barrier instruction.</li>
</ul>
</li>
</ul>
<p>DMB和DSB后面可以加参数来确定屏障生效的范围, 具体可以参考ARMv8-A ARM的table2-1, 一共有3种读写限制方式*4种domain&#x3D;12种case. 对于shareable domain后面还会讲</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h1 id="Memory-types-and-attributes"><a href="#Memory-types-and-attributes" class="headerlink" title="Memory types and attributes"></a>Memory types and attributes</h1><p>ARMv8将memory分为normal memory和device memory两种. 简单来说可以分别对应于RAM和外设.</p>
<ul>
<li><h2 id="Normal-memory"><a href="#Normal-memory" class="headerlink" title="Normal memory"></a>Normal memory</h2><p>The Normal memory type attribute applies to most memory in a system. It indicates that the hardware is permitted by the architecture to perform Speculative data read accesses to these locations, regardless of the access permissions for these locations.</p>
<p>For accesses to Normal memory, a DMB instruction is required to ensure the required ordering.</p>
<p>对于normal memory, 是允许硬件进行投机的访问的, 也就是说对normal memory进行读访问是没有side effect的. 对normal memory进行write, 如果写入的值和前值相等, 那也是没有side effect的. 想想我们的外设寄存器, 很多寄存器都是不能满足这个特性的. 允许对normal memory进行非对齐访问. 另外对normal memory的访问是可以merge的. 比如连续对数组两个元素的写, 可以合并成一条写来增加效率. normal memory的访问是允许进行乱序的, 如果需要顺序访问, 则需要加DMB&#x2F;DSB屏障</p>
<ul>
<li><h3 id="Shareable-Normal-memory"><a href="#Shareable-Normal-memory" class="headerlink" title="Shareable Normal memory"></a>Shareable Normal memory</h3><p>A Normal memory location has a Shareability attribute that is one of:</p>
<ul>
<li>Inner Shareable, meaning it applies across the Inner Shareable shareability domain.</li>
<li>Outer Shareable, meaning it applies across both the Inner Shareable and the Outer Shareable shareability domains.</li>
<li>Non-shareable.</li>
</ul>
<ul>
<li><h4 id="Shareable-Inner-Shareable-and-Outer-Shareable-Normal-memory"><a href="#Shareable-Inner-Shareable-and-Outer-Shareable-Normal-memory" class="headerlink" title="Shareable, Inner Shareable, and Outer Shareable Normal memory"></a>Shareable, Inner Shareable, and Outer Shareable Normal memory</h4><p>The Arm architecture abstracts the system as a series of Inner and Outer Shareability domains.</p>
<p>Each Inner Shareability domain contains a set of observers that are data coherent for each member of that set for data accesses with the Inner Shareable attribute made by any member of that set.</p>
<p>Each Outer Shareability domain contains a set of observers that are data coherent for each member of that set for data accesses with the Outer Shareable attribute made by any member of that set.</p>
<p>The following properties also hold:</p>
<ul>
<li>Each observer is a member of only a single Inner Shareability domain.</li>
<li>Each observer is a member of only a single Outer Shareability domain.</li>
<li>All observers in an Inner Shareability domain are always members of the same Outer Shareability domain. This means that an Inner Shareability domain is a subset of an Outer Shareability domain, although it is not required to be a proper subset.</li>
</ul>
<blockquote>
<p>Note:<br>Because all data accesses to Non-cacheable locations are data coherent to all observers, Non-cacheable locations are always treated as Outer Shareable.<br>The Inner Shareable domain is expected to be the set of PEs controlled by a single hypervisor or operating system.</p>
</blockquote>
<p>The details of the use of the shareability attributes are system-specific.</p>
</li>
</ul>
<p>Normal memory可以有shareability attribute, 可以是inner&#x2F;outer&#x2F;non-shareable, 这个attribute可以通过MMU页表的属性来配置. 这个特性和硬件定义的domain进行配合使用</p>
<p>简单来说, SoC在设计时会将系统分为如下四个shareable domain:</p>
<ul>
<li>non-shareable domain, 一般将一个core分在一个non-shareable domain中</li>
<li>inner-shareable domain, 一般将所有的core分在一个inner-shareable domain中, 可以有多个inner-shareable domain. 比如将cpu core分成两组, 分别跑不同的OS</li>
<li>outer-shareable domain, 一般将cache coherence的外设(如接在CCI上的GPU)和CPU一起放在outer-shareable domain中</li>
<li>system domain, 表示整个系统</li>
</ul>
<p>此时PEs访存的特性为:</p>
<ul>
<li>当cpu访问non-shareable memory时, 硬件不用去往外面广播来维护cache达到coherence</li>
<li>当cpu访问inner-shareable memory时, 硬件会通过bus和协议来让inner-shareable domain中的所有observer达到coherence</li>
<li>当cpu访问outer-shareable memory是, 硬件会通过bus和协议来让outer-shareable domain中的所有observer达到coherence</li>
</ul>
<p>上面说的硬件一般是CCI以及其内部的snoop组件. 通过MOESI来让所有的observer的cache达到一致(coherence).</p>
<p>另外前面讲过的DMB&#x2F;DSB可以通过指定shareable domain来将讲数据同步到指定的domain中.</p>
<p>另外一般来说, 跑在同一个操作系统上的PEs都会设定在同一个inner shareable domain上.</p>
<p>将系统切分不同的domain主要是为了更好的性能和更加的省电(不需要多做额外的coherence操作)</p>
</li>
<li><h3 id="Cacheability-attributes-for-Normal-memory"><a href="#Cacheability-attributes-for-Normal-memory" class="headerlink" title="Cacheability attributes for Normal memory"></a>Cacheability attributes for Normal memory</h3><p>In addition to being Outer Shareable, Inner Shareable or Non-shareable, each region of Normal memory is assigned a Cacheability attribute that is one of:</p>
<ul>
<li>Write-Through Cacheable.</li>
<li>Write-Back Cacheable.</li>
<li>Non-cacheable.</li>
</ul>
<p>Also, for Write-Through Cacheable and Write-Back Cacheable Normal memory regions:</p>
<ul>
<li>A region might be assigned cache allocation hints for read and write accesses.</li>
<li>It is IMPLEMENTATION DEFINED whether the cache allocation hints can have an additional attribute of Transient or Non-transient.</li>
</ul>
<p>Normal memory可以配置cache属性, cacheable&#x2F;non-cacheable, 对于cacheable, cache update的属性有:</p>
<ul>
<li>write-back, 表示store只将数据写到cache中</li>
<li>write-through, 表示store将数据同时写到cache和memory中</li>
</ul>
<p>cache allocation的属性有：</p>
<ul>
<li>read-allocate, 表示read miss时, 将发生cache line fill</li>
<li>write-allocate, 表示write miss时, 将发生cache line fill</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="Device-memory"><a href="#Device-memory" class="headerlink" title="Device memory"></a>Device memory</h2><p>The Device memory type attributes define memory locations where an access to the location can cause side-effects, or where the value returned for a load can vary depending on the number of loads performed. Typically, the Device memory attributes are used for memory-mapped peripherals and similar locations.</p>
<p>Device memory定义的内存区被访问时可能产生side effect, 多次从同一位置进行load时可能发生变化. 这些属性和和外设寄存器非常像. 所以通常来说device memory通常用来作为外设的映射属性.</p>
<p>Device memory有如下的属性:</p>
<ul>
<li>不允许进行投机的访问</li>
<li>数据访问对系统中所有的observer都是coherence的, 可以被视为outer shareable</li>
<li>device memory不能被cache</li>
<li>更多细节见ARMv8-A ARM手册…</li>
</ul>
<p>The Armv8 Device memory types are:</p>
<ul>
<li><strong>Device-nGnRnE</strong> Device non-Gathering, non-Reordering, No Early Write Acknowledgement. Equivalent to the Strongly-ordered memory type in earlier versions of the architecture.</li>
<li><strong>Device-nGnRE</strong> Device non-Gathering, non-Reordering, Early Write Acknowledgement. Equivalent to the Device memory type in earlier versions of the architecture.</li>
<li><strong>Device-nGRE</strong> Device non-Gathering, Reordering, Early Write Acknowledgement. Armv8 adds this memory type to the translation table formats found in earlier versions of the architecture. The use of barriers is required to order accesses to Device-nGRE memory.</li>
<li><strong>Device-GRE</strong> Device Gathering, Reordering, Early Write Acknowledgement. Armv8 adds this memory type to the translation table formats found in earlier versions of the architecture. Device-GRE memory has the fewest constraints. It behaves similar to Normal memory, with the restriction that Speculative accesses to Device-GRE memory is forbidden.</li>
</ul>
<p>Device memory类型可以有Device-nGnRnE(等价于ARMv7的Strongly-ordered), Device-nGnRE(相当于ARMv7的device memory), Device-nGRE, Device-GRE这几种</p>
<p>nG, G的G表示gathering, gathering表示是否可以将多笔连续地址写合并为一笔或将多笔同一地址写合并为一笔写</p>
<p>nR, R的R表示reordering, reordering表示对这种类型地址的方式是否可以像normal memory那样进行乱序访问</p>
<p>nE, E的E表示early-acknowlegement, early-acknowlegement相当于post write, 写操作可能被总线上的buffer直接会ack就表示完成, nE相当于non-post write, 一笔写必须等到实际写的位置确认才能表示完成. 所以当PE执行DSB时必须再写到达内存端点(比如实际写入到了外设寄存器)之后才完成</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>arm</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>armv8</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Rust转换bayer和yuv图像</title>
    <url>/2022/05/13/43df98d380f6/</url>
    <content><![CDATA[<p>这是我学习rust之后写的第一个程序，所以记录下，rust和c代码的使用方式还有有非常大的不同，我们不应该用for index的方式来写rust代码。反之使用map&#x2F;reduce这类函数式的写法会更好一些。不论是性能还是可读性上都更好一些</p>
<p>这里的raw图是2byte一个像素，低12bit有效。raw图前面有128byte的header，我暂时先直接将它略过了，没去解析。由于只是临时写一个工具。所以没有对error进行很好的处理，一路unwrap()</p>
<p>Rust的零开销iter抽象还是相当好用的，另外强推下vscode + rust-analyzer作为开发环境，目前看起来是最棒的组合了</p>
<span id="more"></span>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    fs::File,</span><br><span class="line">    io::&#123;Cursor, Read, Seek, SeekFrom&#125;,</span><br><span class="line">    vec,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> bayer::&#123;BayerDepth, Demosaic, RasterDepth, RasterMut&#125;;</span><br><span class="line"><span class="keyword">use</span> image::RgbImage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (w, h) = (<span class="number">1920</span>, <span class="number">1080</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;1.raw&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">seek</span>(SeekFrom::<span class="title function_ invoke__">Start</span>(<span class="number">128</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_end</span>(&amp;<span class="keyword">mut</span> buf).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">raw_vec</span>: <span class="type">Vec</span>&lt;_&gt; = buf.<span class="title function_ invoke__">chunks_exact</span>(<span class="number">2</span>).<span class="title function_ invoke__">map</span>(|v| v[<span class="number">0</span>] &gt;&gt; <span class="number">4</span> | v[<span class="number">1</span>] &lt;&lt; <span class="number">4</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rgb8_vec</span> = <span class="built_in">vec!</span>[<span class="number">0u8</span>; w * h * <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">dst</span> = RasterMut::<span class="title function_ invoke__">new</span>(w, h, RasterDepth::Depth8, &amp;<span class="keyword">mut</span> rgb8_vec);</span><br><span class="line">    bayer::<span class="title function_ invoke__">run_demosaic</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> Cursor::<span class="title function_ invoke__">new</span>(raw_vec.<span class="title function_ invoke__">as_slice</span>()),</span><br><span class="line">        BayerDepth::Depth8,</span><br><span class="line">        bayer::CFA::GRBG,</span><br><span class="line">        Demosaic::Cubic,</span><br><span class="line">        &amp;<span class="keyword">mut</span> dst,</span><br><span class="line">    )</span><br><span class="line">    .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    RgbImage::<span class="title function_ invoke__">from_vec</span>(w <span class="keyword">as</span> <span class="type">u32</span>, h <span class="keyword">as</span> <span class="type">u32</span>, rgb8_vec)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">save</span>(<span class="string">&quot;rgb8.png&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于YCbCr的图像, 也可以采用类似的方式来处理。我实际测试下来，下面的写法还是比纯C代码要慢的(慢了50%左右了)。可能是iterator做了实际的line copy带来的开销吧, 不过相应的这个写法的可读性比c循环要高很多。不过这个速度比之前用numpy写的哪个也要快非常多了。不知道除了使用unsafe模式外，是否还有更快的实现方式</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    fs::File,</span><br><span class="line">    io::&#123;Read, Seek, SeekFrom&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> image::RgbImage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_ycbcr</span>(filename: &amp;<span class="type">str</span>, capacity: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(capacity);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(filename).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">seek</span>(SeekFrom::<span class="title function_ invoke__">Start</span>(<span class="number">0</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_end</span>(&amp;<span class="keyword">mut</span> buf).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    buf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">write_rgb</span>(filename: &amp;<span class="type">str</span>, buf: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, w: <span class="type">usize</span>, h: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rgb</span> = RgbImage::<span class="title function_ invoke__">from_vec</span>(w <span class="keyword">as</span> <span class="type">u32</span>, h <span class="keyword">as</span> <span class="type">u32</span>, buf).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    rgb.<span class="title function_ invoke__">save</span>(filename).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">csc</span>(</span><br><span class="line">    y: <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item = <span class="type">u8</span>&gt;,</span><br><span class="line">    u: <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item = <span class="type">u8</span>&gt;,</span><br><span class="line">    v: <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item = <span class="type">u8</span>&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">    y.<span class="title function_ invoke__">zip</span>(u.<span class="title function_ invoke__">zip</span>(v))</span><br><span class="line">        .<span class="title function_ invoke__">flat_map</span>(|(y, (u, v))| &#123;</span><br><span class="line">            [</span><br><span class="line">                (y <span class="keyword">as</span> <span class="type">f32</span> + <span class="number">1.280</span> * (v <span class="keyword">as</span> <span class="type">f32</span> - <span class="number">128</span>.)) <span class="keyword">as</span> <span class="type">u8</span>,</span><br><span class="line">                (y <span class="keyword">as</span> <span class="type">f32</span> - <span class="number">0.215</span> * (u <span class="keyword">as</span> <span class="type">f32</span> - <span class="number">128</span>.) - <span class="number">0.380</span> * (v <span class="keyword">as</span> <span class="type">f32</span> - <span class="number">128</span>.)) <span class="keyword">as</span> <span class="type">u8</span>,</span><br><span class="line">                (y <span class="keyword">as</span> <span class="type">f32</span> + <span class="number">2.128</span> * (u <span class="keyword">as</span> <span class="type">f32</span> - <span class="number">128</span>.)) <span class="keyword">as</span> <span class="type">u8</span>,</span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">nv12_to_rgb</span>(nv12: &amp;<span class="type">str</span>, rgb: &amp;<span class="type">str</span>, w: <span class="type">usize</span>, h: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">buf</span> = <span class="title function_ invoke__">read_ycbcr</span>(nv12, w * h * <span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = buf[..w * h].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">copied</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">u</span> = buf[w * h..]</span><br><span class="line">        .<span class="title function_ invoke__">chunks_exact</span>(w)</span><br><span class="line">        .<span class="title function_ invoke__">flat_map</span>(|line| [line, line])</span><br><span class="line">        .<span class="title function_ invoke__">flatten</span>()</span><br><span class="line">        .<span class="title function_ invoke__">step_by</span>(<span class="number">2</span>)</span><br><span class="line">        .<span class="title function_ invoke__">flat_map</span>(|u| [u, u])</span><br><span class="line">        .<span class="title function_ invoke__">copied</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = buf[w * h..]</span><br><span class="line">        .<span class="title function_ invoke__">chunks_exact</span>(w)</span><br><span class="line">        .<span class="title function_ invoke__">flat_map</span>(|line| [line, line])</span><br><span class="line">        .<span class="title function_ invoke__">flatten</span>()</span><br><span class="line">        .<span class="title function_ invoke__">skip</span>(<span class="number">1</span>)</span><br><span class="line">        .<span class="title function_ invoke__">step_by</span>(<span class="number">2</span>)</span><br><span class="line">        .<span class="title function_ invoke__">flat_map</span>(|v| [v, v])</span><br><span class="line">        .<span class="title function_ invoke__">copied</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">write_rgb</span>(rgb, <span class="title function_ invoke__">csc</span>(y, u, v), w, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">nv16_to_rgb</span>(nv16: &amp;<span class="type">str</span>, rgb: &amp;<span class="type">str</span>, w: <span class="type">usize</span>, h: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">buf</span> = <span class="title function_ invoke__">read_ycbcr</span>(nv16, w * h * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = buf[..w * h].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">copied</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">u</span> = buf[w * h..].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">step_by</span>(<span class="number">2</span>).<span class="title function_ invoke__">flat_map</span>(|u| [u, u]).<span class="title function_ invoke__">copied</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = buf[w * h + <span class="number">1</span>..]</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">step_by</span>(<span class="number">2</span>)</span><br><span class="line">        .<span class="title function_ invoke__">flat_map</span>(|v| [v, v])</span><br><span class="line">        .<span class="title function_ invoke__">copied</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">write_rgb</span>(rgb, <span class="title function_ invoke__">csc</span>(y, u, v), w, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">yuyv_to_rgb</span>(yuyv: &amp;<span class="type">str</span>, rgb: &amp;<span class="type">str</span>, w: <span class="type">usize</span>, h: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">buf</span> = <span class="title function_ invoke__">read_ycbcr</span>(yuyv, w * h * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = buf.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">step_by</span>(<span class="number">2</span>).<span class="title function_ invoke__">copied</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">u</span> = buf[<span class="number">1</span>..].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">step_by</span>(<span class="number">4</span>).<span class="title function_ invoke__">flat_map</span>(|v| [v, v]).<span class="title function_ invoke__">copied</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = buf[<span class="number">3</span>..].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">step_by</span>(<span class="number">4</span>).<span class="title function_ invoke__">flat_map</span>(|v| [v, v]).<span class="title function_ invoke__">copied</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">write_rgb</span>(rgb, <span class="title function_ invoke__">csc</span>(y, u, v), w, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (w, h) = (<span class="number">2560</span>, <span class="number">1440</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">nv12_to_rgb</span>(<span class="string">&quot;nv12.yuv&quot;</span>, <span class="string">&quot;nv12.jpg&quot;</span>, w, h);</span><br><span class="line">    <span class="title function_ invoke__">nv16_to_rgb</span>(<span class="string">&quot;nv16.yuv&quot;</span>, <span class="string">&quot;nv16.jpg&quot;</span>, w, h);</span><br><span class="line">    <span class="title function_ invoke__">yuyv_to_rgb</span>(<span class="string">&quot;yuyv.yuv&quot;</span>, <span class="string">&quot;yuyv.jpg&quot;</span>, w, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>image</category>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>bayer</tag>
        <tag>image</tag>
        <tag>yuv</tag>
      </tags>
  </entry>
  <entry>
    <title>risc-v linux启动流程分析1-特性描述</title>
    <url>/2023/01/14/225a93f25ce4/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>现在RISC-V在芯片厂已经开始有一定的部署了, 从MCU级别的微控制处理器到AP CPU级别SoC都有进行一些设计或量产. 从芯片开发成本来看, RISC-V是一个非常适合用来实现减少授权费和版税的in-house CPU的指令集. 因为RISC-V指令集目前已经形成的一定生态并且有越来越好的趋势, 对于实现RISC-V的CPU, 可以直接免费使用基于这个指令集的开源生态, 如GCC, LLVM等.</p>
<p>虽然目前RISC-V指令集在实现AP CPU时还有一些扩展指令集正在准备或刚刚准备好, 但是RISC-V linux确实已经可以正常跑起来了. 我们就来以RISC-V 32来分析下Linux的启动过程, 我们主要分析在start_kernel之前的流程, 我们使用的linux版本时linux-6.2-rc3, 配置采用的时linux mainline上面的rv32_defconfig.</p>
<span id="more"></span>

<h1 id="RV32-linux的特点"><a href="#RV32-linux的特点" class="headerlink" title="RV32 linux的特点"></a>RV32 linux的特点</h1><h2 id="Memory-mapping"><a href="#Memory-mapping" class="headerlink" title="Memory mapping"></a>Memory mapping</h2><p>Linux内核目前在RV32上的memory mapping如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    0.000000] Virtual kernel memory layout:</span><br><span class="line">[    0.000000]       fixmap : 0x9cc00000 - 0x9d000000   (4096 kB)</span><br><span class="line">[    0.000000]       pci io : 0x9d000000 - 0x9e000000   (  16 MB)</span><br><span class="line">[    0.000000]      vmemmap : 0x9e000000 - 0xa0000000   (  32 MB)</span><br><span class="line">[    0.000000]      vmalloc : 0xa0000000 - 0xc0000000   ( 512 MB)</span><br><span class="line">[    0.000000]       lowmem : 0xc0000000 - 0x00000000   (1024 MB)</span><br></pre></td></tr></table></figure>

<p>可以看到内核地址空间和常规的的大约3:1有很大的不同, 变成了大约5:3, 用户地址空间被压缩的更小了. 带来的变化时内核线性地址区域增长到了1G, 并且vmalloc区域也有512MB, 比常规的3:1多了非常多. 另外地址空间中没有看到modules区域, 可能时放到了vmalloc里面. 这里先不去研究.</p>
<h2 id="Relocation特点"><a href="#Relocation特点" class="headerlink" title="Relocation特点"></a>Relocation特点</h2><p>Relocation在RISC-V linux上也是一个有特色的地方, 一是没有做动态链接, 二是地址空间切换的实现也比较有意思, 这一点我们在启动过程章节来描述</p>
<p>这一节我们主要说说RISC-V linux的relocation没有做动态链接这个事情. 常规的Linux实现都是采用类似动态链接的方式, 比如通过fpic&#x2F;fpie编译出可执行文件, 然后通过rel段&#x2F;dyn段来实现运行时的代码修改, 而RISC-V是没有这个运行时代码修改的过程的. 和linux实现比较, u-boot的relocation则是通过fpic编译选项加动态段来实现的. 那么linux不使用fpic编译选项是如何实现的呢, 如果实现能在不修改代码的情况下同时运行在两个不同的地址空间上的.</p>
<p>首先RISC-V linux在编译的时候的flag是fno-PIE的, 然后还有一个关键的flag是mcmodel&#x3D;medany, 这个选项在RISC-V上可以有两种选择, 我们来看看gcc的文档的描述:</p>
<ul>
<li>medlow: Generate code for the medium-low code model. The program and its statically defined symbols must lie within a single 2 GiB address range and must lie between absolute addresses -2 GiB and +2 GiB. Programs can be statically or dynamically linked. This is the default code model.</li>
<li>medany:Generate code for the medium-any code model. The program and its statically defined symbols must be within any single 2 GiB address range. Programs can be statically or dynamically linked.<br>The code generated by the medium-any code model is position-independent, but is not guaranteed to function correctly when linked into position-independent executables or libraries.</li>
</ul>
<p>medlow相当于可以访问-2G ~ +2G的空间, 对于RV32, 相当于完整的虚拟地址空间, 对于RV64相当于可以访问最高的2G和最低的2G空间. 具体来说, gcc会生成基于lui指令的寻址方法.<br>medany相当于可以访问PC-2G ~ PC+2G的空间, 对于RV32, 相当于还是还是完整的虚拟地址空间, 对于RV64则是跟着PC的位置动态变化的. 具体来说, gcc会生成基于auipc指令的寻址方法. 另外medany会生成地址无关的代码. 这个也是RISC-V linux目前实现的无运行时代码修改实现relocation的基础. 简单来说, medany会然gcc产生pic代码, 并且这个pic代码不依赖rel段和dyn段. 因此不用做运行时代码修改就可以实现直接运行在不同的地址空间之上了. 当然这会限制寻址范围, 但是基于基于PC +-2G的空间已经足够linux启动做relocation了.</p>
<h2 id="Page-based-cacheable控制"><a href="#Page-based-cacheable控制" class="headerlink" title="Page based cacheable控制"></a>Page based cacheable控制</h2><p>RISC-V的一个特点是: cacheable, atomic, ordering, idempoteny这些特性都是通过PMA和物理地址进行绑定的, 这个和目前比较常规的通过页表绑定到虚拟地址的方式是不一样的, 这样设计的优点是简化了控制, 在设计之初就确定好各个地址段的属性, 系统中所有的observer都按照这个属性去配置就可以了. 缺点是要求SoC自身要做到coherent, 这个是有硬件的开销的, 比如通过MOESI协议去实现. 如果系统没有做到coherent, 那么在RISC-V的这样的体系下, 要想动态申请一段uncached空间来和non-coherent device保持coherent就无法做到了. 可能我们只能预留一段memory, 将其配置为uncached来使用. 这样的话这块memory大小很难控制, 容易产生内存不足或浪费的问题.</p>
<p>在这样的情况下, RISC-V后面发布了Svpbmt(Page-Based Memory Types)扩展, 在RV64上, 将PTE的[62:61]这两个bit用来控制特定Page上的属性, 可以配置的值为:</p>
<ul>
<li>0 None</li>
<li>1 Non-cacheable, idempotent, weakly-ordered (RVWMO), main memory</li>
<li>2 Non-cacheable, non-idempotent, strongly-ordered (I&#x2F;O ordering), I&#x2F;O</li>
<li>3 Reserved for future standard use</li>
</ul>
<p>这样在RV64上就可以实现通过Page&#x2F;虚拟地址来控制某块地址空间的属性了.</p>
<p>但是RV32上就没有这样的好运了. 目前RV32的PTE一共32bit已经全部都花光了, 没有地方来添加这个扩展了. 不知道后续是否会有新的扩展来帮助实现这个功能.</p>
<p>目前work around的方案有:</p>
<ol>
<li>将物理地址空间拆成两部分, 比如高物理地址区域作为cached区域, 低物理地址空间作为uncached预取, 这样这两块空间只有一个bit会不同, 我们可以把这个bit对应到上面的1, 2这两种case来间接实现这种方案.</li>
<li>还有一种需要实现上来实现的hack, 因为RV32本来有34bit的物理地址寻址空间, 我们在硬件上可以实现为只做32bit的寻址空间, 剩下2个bit用来实现上面pbmt的功能</li>
</ol>
<p>方案1是符合标准的, 是一个软方案, 但是需要魔改linux实现, 并且可以寻址的物理地址空间相当于要变少了. 方案2是不符合标准的, 也需要魔改linux实现. 总的来说在RV32上想实现pbmt都是不通用的.</p>
<h2 id="Non-coherent-memory支持"><a href="#Non-coherent-memory支持" class="headerlink" title="Non-coherent memory支持"></a>Non-coherent memory支持</h2><p>前面讲了pbmt, 现在再讲到non-coherent memory支持, 如果要支持non-coherent memory, 也就是在non-coherent的system上, 我们的device和cpu访问同一块空间, 这块空间对于CPU来讲是cached, 对于device来说是uncached. 这样这块地址空间就存在cache同步的问题, 需要进行cache的clean&#x2F;invalid&#x2F;flush. 最开始RISC-V并没有在spec上对cached的操作进行规范, 因为spec基本上就是定在系统级实现了coherent的基础上. 正常是不需要cache操作的. 随着发展, 大家发现non-coherent system还是很有存在的必要(省面积, 功耗等). 所以发展出了pbmt用于控制page级的cache策略, 发展出了Zicbom, Zicbop, Zicboz扩展用于实现cache的操作. 其中Zicbom就是对应到我们这一节, cbom的意思是(Cache block operation management), 提供了三个指令cbo.flush, cbo.clean, cbo.inval. 根据spec这三个指令作用在effective address上, 看起来是在U&#x2F;S mode上就是虚拟地址了, 在M mode上就是物理地址了. 如果特定的SoC没有实现这个扩展, 那么要实现non-coherent memory也需要魔改linux, 比如通过sbi去控制等.</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>前面我们讲解的RISC-V和linux相关的一些特性的分析, 我们可以看到RISC-V正在发展的特点, 当然也是不够成熟的特点, 后续慢慢发展应该就能满足更多复杂的需求了. 下一篇文章, 我们将从代码出发来研究实际的启动过程.</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>risc-v</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>risc-v</tag>
      </tags>
  </entry>
  <entry>
    <title>rust no_std+alloc稳定和使用演示</title>
    <url>/2023/01/14/402b99cd8b7b/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章好些天前就想写了, 因为之前一直在追踪stable rust在no_std环境下使用alloc相关的github issue, 前段时间 <a href="https://github.com/rust-lang/rust/pull/102318">#102318</a> 这个issue正式合并了, 相关的改动将在rust 1.68中稳定.</p>
<span id="more"></span>

<p>no_std下可以使用alloc一方面可以让一些裸机firmware或操作系统内核可以使用堆内存. 另一方面, 一些嵌入式linux的library&#x2F;app的开发也可以使用no_std + alloc来做, 因为一些嵌入式linux经常在memory和flash空间都比较小的环境, 这种环境如果不使用no_std会导致编译出来的elf过大, no_std + alloc就可以解决这个问题, 这样能使用rust来写一些lib&#x2F;app. 但是在之前想要使用alloc, 必须依赖unstable的alloc_error_handler feature, 导致其不能在stable上使用.</p>
<p>在stable rust 1.68之后, 当在no_std环境下, alloc失败时默认会直接panic, 不再需要alloc_error_handler. 在stable rust就可以编写no_std + alloc的rust crate了. 这相当于有了在生产环境使用这种模式编写应用的基础了. 下面我们来演示下用no_std + alloc写linux app的方法</p>
<h1 id="no-std-linux-app"><a href="#no-std-linux-app" class="headerlink" title="no_std linux app"></a>no_std linux app</h1><p>首先安装libc, 另外我们使用libc-print crate来进行println演示, 你也可以自己实现print macro</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cargo add libc --no-default-features</span><br><span class="line">$ cargo add libc-print</span><br></pre></td></tr></table></figure>

<p>cargo.toml配置在panic时直接abort, 这样不需要使用unstable的lang item, panic直接abort也符合常规的嵌入式linux的用法:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&quot;abort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&quot;abort&quot;</span></span><br></pre></td></tr></table></figure>

<p>编写代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> libc_print::std_name::println;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_: &amp;core::panic::PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        libc::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以编译出所需的app了, 文件的体积也非常小. 写rust代码大多数情况下会比用c舒服很多. 就算是在no_std的情况下也是.</p>
<h1 id="no-std-alloc-linux-app"><a href="#no-std-alloc-linux-app" class="headerlink" title="no_std + alloc linux app"></a>no_std + alloc linux app</h1><p>如果还需要使用alloc, 则我们在引入一个crate, 或者也可以自己去实现一个基于libc的global allocator, 这里为了方便演示还是使用extern crate:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cargo add libc_alloc</span><br></pre></td></tr></table></figure>

<p>之后编写如下代码, 代码演示了alloc的使用方法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> alloc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> alloc::&#123;boxed::<span class="type">Box</span>, vec&#125;;</span><br><span class="line"><span class="keyword">use</span> libc_alloc::LibcAlloc;</span><br><span class="line"><span class="keyword">use</span> libc_print::std_name::println;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[global_allocator]</span></span><br><span class="line"><span class="keyword">static</span> GLOBAL_ALLOC: LibcAlloc = LibcAlloc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_: &amp;core::panic::PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        libc::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">test1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">v</span> <span class="keyword">in</span> test1 &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;v&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">test2</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;test2&#125;&quot;</span>);</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们需要使用global_allocator过程宏引入一个全局的分配器, 然后我们需要显式的用<code>extern crate alloc</code>来引入alloc crate, 对于标准库里面的crate, cargo不能自动帮忙引入, 所以需要手动引入. 另外Box, Vec这些在std下的preclude在no_std下是不会preclude的, 所以需要手动导入才能使用.</p>
<p>以上就是no_std + alloc的用法. 相信随着rust 1.68的到来, rust在嵌入式领域会有很多crate慢慢的都不再需要nightly编译器了.</p>
<hr>
<p>2023-01-15更新:<br>由于<a href="https://github.com/rust-lang/rust/pull/106045">#106045</a>的合并, 导致linux环境下no_std + alloc会编译失败, bare-metal环境不受影响. 目前提了一个新的issue: <a href="https://github.com/rust-lang/rust/issues/106864">#106864</a>, 不确定什么时候能合并. 不知道是否会影响到1.68上实现这个功能.</p>
<hr>
<p>2023-01-20更新:<br>根据和rust开发者在<a href="https://github.com/rust-lang/rust/issues/106864">#106864</a>中的沟通可以发现, 之前在OS based toolchain环境下no_std + alloc可以编译通过存在一些幸运, 这是连接器的GC帮忙把一些不应该引入的<code>eh_personality</code>去掉了, 所以编译通过了. 但是当做一些进一步的测试就能发现, 就算是之前可以编译过的nightly, 引入某些code之后, 也会编译失败. 后续可能需要等rust开发者有时间了之后再来修正这个问题了. 在stable下写有heap支持的linux的嵌入式软件似乎还得再等等了. 具体要等多久就不清楚了. unstable环境下只需要用cargo的build-std功能重新编译libcore是可以编译通过的.</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>解决arm64 linux kernel O0编译时报错的问题</title>
    <url>/2024/09/01/e0fb3ca2dadd/</url>
    <content><![CDATA[<p>最近在学习 linux driver 时, 在 qemu 上使用 aarch64 架构来跑 Image, 在想使用单步跑看看 driver 的某些执行路径时, 发现给 driver 添加 <code>O0</code> 编译时会有很多错误.</p>
<p>比如在 <code>Linux-6.10</code> 中, 我们在如下修改状态下, 使用命令 <code>make LLVM=1 ARCH=arm64 defconfig &amp;&amp; make LLVM=1 ARCH=arm64 Image -j12</code> 编译的时候</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig</span><br><span class="line">index 2c7bf4da0..857020b8c 100644</span><br><span class="line">--- a/arch/arm64/configs/defconfig</span><br><span class="line">+++ b/arch/arm64/configs/defconfig</span><br><span class="line">@@ -116,7 +116,7 @@ CONFIG_ACPI_APEI_MEMORY_FAILURE=y</span><br><span class="line"> CONFIG_ACPI_APEI_EINJ=y</span><br><span class="line"> CONFIG_VIRTUALIZATION=y</span><br><span class="line"> CONFIG_KVM=y</span><br><span class="line">-CONFIG_JUMP_LABEL=y</span><br><span class="line">+# CONFIG_JUMP_LABEL is not set</span><br><span class="line"> CONFIG_MODULES=y</span><br><span class="line"> CONFIG_MODULE_UNLOAD=y</span><br><span class="line"> CONFIG_IOSCHED_BFQ=y</span><br><span class="line">diff --git a/drivers/Makefile b/drivers/Makefile</span><br><span class="line">index fe9ceb0d2..f60455123 100644</span><br><span class="line">--- a/drivers/Makefile</span><br><span class="line">+++ b/drivers/Makefile</span><br><span class="line">@@ -193,3 +193,5 @@ obj-$(CONFIG_CDX_BUS)               += cdx/</span><br><span class="line"> obj-$(CONFIG_DPLL)             += dpll/</span><br><span class="line"></span><br><span class="line"> obj-$(CONFIG_S390)             += s390/</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y += -O0</span><br></pre></td></tr></table></figure>

<p>会报出汗多的 <code>error: invalid operand for inline asm constraint &#39;i&#39;</code> 错误. 下面我们就来探究下这个问题.</p>
<span id="more"></span>

<p>很多出错都指向了下面这个函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span></span><br><span class="line"><span class="title function_">alternative_has_cap_likely</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> cpucap)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cpucap_is_possible(cpucap))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">goto</span><span class="params">(</span></span><br><span class="line"><span class="params">        ALTERNATIVE_CB(<span class="string">&quot;b        %l[l_no]&quot;</span>, %[cpucap], alt_cb_patch_nops)</span></span><br><span class="line"><span class="params">        :</span></span><br><span class="line"><span class="params">        : [cpucap] <span class="string">&quot;i&quot;</span> (cpucap)</span></span><br><span class="line"><span class="params">        :</span></span><br><span class="line"><span class="params">        : l_no)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">l_no:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其传入了一个 <code>cpucap</code>, 在调用这个内联函数的时候, 传入给 <code>cpucap</code> 的都是一个编译时常量, 比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARM64_ALWAYS_BOOT 0</span></span><br><span class="line"></span><br><span class="line">alternative_has_cap_likely(ARM64_ALWAYS_BOOT);</span><br></pre></td></tr></table></figure>

<p>这样在调用的地方, 将这个内联函数展开, 此时 <code>cpucap</code> 就是一个编译时的常量. 因此在内嵌汇编 <code>asm</code> 块中可以将这个 <code>cpucap</code> 以 “i” 类型输入参数传递.</p>
<p>但是当我们关闭了优化(比如用 O0)编译的时候, 这个内联函数就不会被内联展开, 此时 <code>cpucap</code> 就是一个变量了, 变量是不能作为 “i” 类型输入参数传递给 <code>asm</code> 块的. 因此就会报错.</p>
<p>要解决这个问题, 我们需要修改下这种类型的内联函数的实现, 比如将这种内联函数修改成宏. 不过这个函数内部存在跳转. 我们修改的宏内部最好不要有这种跳转, 避免跳转标签发生冲突, 可以按照如下的方式来修改:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> alternative_has_cap_likely(cpucap)                                \</span></span><br><span class="line"><span class="meta">        (&#123;                                                                \</span></span><br><span class="line"><span class="meta">                int ret = true;                                           \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (cpucap_is_possible(cpucap)) &#123;                         \</span></span><br><span class="line"><span class="meta">                        asm(ALTERNATIVE_CB(<span class="string">&quot;mov %w[ret], #0&quot;</span>, %[_cpucap], \</span></span><br><span class="line"><span class="meta">                                           alt_cb_patch_nops)             \</span></span><br><span class="line"><span class="meta">                            : [ret] <span class="string">&quot;+r&quot;</span>(ret)                             \</span></span><br><span class="line"><span class="meta">                            : [_cpucap] <span class="string">&quot;i&quot;</span>(cpucap)                       \</span></span><br><span class="line"><span class="meta">                            :);                                           \</span></span><br><span class="line"><span class="meta">                &#125; <span class="keyword">else</span> &#123;                                                  \</span></span><br><span class="line"><span class="meta">                        ret = false;                                      \</span></span><br><span class="line"><span class="meta">                &#125;                                                         \</span></span><br><span class="line"><span class="meta">                ret;                                                      \</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br></pre></td></tr></table></figure>

<p>修改之后, 我们将 <code>goto</code> 这个需求去掉了. 但是实现了同样的功能. 由于此时我们将内联函数改为了宏, 也就避开了 <code>O0</code> 编译时内联函数不展开的问题了.</p>
<p>最终的修改 patch 如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig</span><br><span class="line">index <span class="number">2</span>c7bf4da0.<span class="number">.857020</span>b8c <span class="number">100644</span></span><br><span class="line">--- a/arch/arm64/configs/defconfig</span><br><span class="line">+++ b/arch/arm64/configs/defconfig</span><br><span class="line">@@ <span class="number">-116</span>,<span class="number">7</span> +<span class="number">116</span>,<span class="number">7</span> @@ CONFIG_ACPI_APEI_MEMORY_FAILURE=y</span><br><span class="line"> CONFIG_ACPI_APEI_EINJ=y</span><br><span class="line"> CONFIG_VIRTUALIZATION=y</span><br><span class="line"> CONFIG_KVM=y</span><br><span class="line">-CONFIG_JUMP_LABEL=y</span><br><span class="line">+# CONFIG_JUMP_LABEL is not <span class="built_in">set</span></span><br><span class="line"> CONFIG_MODULES=y</span><br><span class="line"> CONFIG_MODULE_UNLOAD=y</span><br><span class="line"> CONFIG_IOSCHED_BFQ=y</span><br><span class="line">diff --git a/arch/arm64/include/<span class="keyword">asm</span>/alternative-macros.h b/arch/arm64/include/<span class="keyword">asm</span>/alternative-macros.h</span><br><span class="line">index d328f549b.<span class="number">.17892</span>cb57 <span class="number">100644</span></span><br><span class="line">--- a/arch/arm64/include/<span class="keyword">asm</span>/alternative-macros.h</span><br><span class="line">+++ b/arch/arm64/include/<span class="keyword">asm</span>/alternative-macros.h</span><br><span class="line">@@ <span class="number">-223</span>,<span class="number">41</span> +<span class="number">223</span>,<span class="number">32</span> @@ alternative_endif</span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">-<span class="type">static</span> __always_inline <span class="type">bool</span></span><br><span class="line">-alternative_has_cap_likely(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> cpucap)</span><br><span class="line">-&#123;</span><br><span class="line">-       <span class="keyword">if</span> (!cpucap_is_possible(cpucap))</span><br><span class="line">-               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">-</span><br><span class="line">-       <span class="keyword">asm</span> <span class="title function_">goto</span><span class="params">(</span></span><br><span class="line"><span class="params">-       ALTERNATIVE_CB(<span class="string">&quot;b       %l[l_no]&quot;</span>, %[cpucap], alt_cb_patch_nops)</span></span><br><span class="line"><span class="params">-       :</span></span><br><span class="line"><span class="params">-       : [cpucap] <span class="string">&quot;i&quot;</span> (cpucap)</span></span><br><span class="line"><span class="params">-       :</span></span><br><span class="line"><span class="params">-       : l_no)</span>;</span><br><span class="line">-</span><br><span class="line">-       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">-l_no:</span><br><span class="line">-       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">-&#125;</span><br><span class="line">-</span><br><span class="line">-<span class="type">static</span> __always_inline <span class="type">bool</span></span><br><span class="line">-alternative_has_cap_unlikely(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> cpucap)</span><br><span class="line">-&#123;</span><br><span class="line">-       <span class="keyword">if</span> (!cpucap_is_possible(cpucap))</span><br><span class="line">-               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">-</span><br><span class="line">-       <span class="keyword">asm</span> <span class="title function_">goto</span><span class="params">(</span></span><br><span class="line"><span class="params">-       ALTERNATIVE(<span class="string">&quot;nop&quot;</span>, <span class="string">&quot;b   %l[l_yes]&quot;</span>, %[cpucap])</span></span><br><span class="line"><span class="params">-       :</span></span><br><span class="line"><span class="params">-       : [cpucap] <span class="string">&quot;i&quot;</span> (cpucap)</span></span><br><span class="line"><span class="params">-       :</span></span><br><span class="line"><span class="params">-       : l_yes)</span>;</span><br><span class="line">-</span><br><span class="line">-       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">-l_yes:</span><br><span class="line">-       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">-&#125;</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> alternative_has_cap_likely(cpucap)                                \</span></span><br><span class="line"><span class="meta">+       (&#123;                                                                \</span></span><br><span class="line"><span class="meta">+               int ret = true;                                           \</span></span><br><span class="line"><span class="meta">+               <span class="keyword">if</span> (cpucap_is_possible(cpucap)) &#123;                         \</span></span><br><span class="line"><span class="meta">+                       asm(ALTERNATIVE_CB(<span class="string">&quot;mov %w[ret], #0&quot;</span>, %[_cpucap], \</span></span><br><span class="line"><span class="meta">+                                          alt_cb_patch_nops)             \</span></span><br><span class="line"><span class="meta">+                           : [ret] <span class="string">&quot;+r&quot;</span>(ret)                             \</span></span><br><span class="line"><span class="meta">+                           : [_cpucap] <span class="string">&quot;i&quot;</span>(cpucap)                       \</span></span><br><span class="line"><span class="meta">+                           :);                                           \</span></span><br><span class="line"><span class="meta">+               &#125; <span class="keyword">else</span> &#123;                                                  \</span></span><br><span class="line"><span class="meta">+                       ret = false;                                      \</span></span><br><span class="line"><span class="meta">+               &#125;                                                         \</span></span><br><span class="line"><span class="meta">+               ret;                                                      \</span></span><br><span class="line"><span class="meta">+       &#125;)</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> alternative_has_cap_unlikely(cpucap)                                  \</span></span><br><span class="line"><span class="meta">+       (&#123;                                                                    \</span></span><br><span class="line"><span class="meta">+               int ret = false;                                              \</span></span><br><span class="line"><span class="meta">+               <span class="keyword">if</span> (cpucap_is_possible(cpucap)) &#123;                             \</span></span><br><span class="line"><span class="meta">+                       asm(ALTERNATIVE(<span class="string">&quot;nop&quot;</span>, <span class="string">&quot;mov %w[ret], #1&quot;</span>, %[_cpucap]) \</span></span><br><span class="line"><span class="meta">+                           : [ret] <span class="string">&quot;+r&quot;</span>(ret)                                 \</span></span><br><span class="line"><span class="meta">+                           : [_cpucap] <span class="string">&quot;i&quot;</span>(cpucap)                           \</span></span><br><span class="line"><span class="meta">+                           :);                                               \</span></span><br><span class="line"><span class="meta">+               &#125;                                                             \</span></span><br><span class="line"><span class="meta">+               ret;                                                          \</span></span><br><span class="line"><span class="meta">+       &#125;)</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __ASSEMBLY__ */</span></span></span><br><span class="line"></span><br><span class="line">diff --git a/arch/arm64/include/<span class="keyword">asm</span>/cpufeature.h b/arch/arm64/include/<span class="keyword">asm</span>/cpufeature.h</span><br><span class="line">index <span class="number">8b</span>904a757..aa26a1152 <span class="number">100644</span></span><br><span class="line">--- a/arch/arm64/include/<span class="keyword">asm</span>/cpufeature.h</span><br><span class="line">+++ b/arch/arm64/include/<span class="keyword">asm</span>/cpufeature.h</span><br><span class="line">@@ <span class="number">-475</span>,<span class="number">13</span> +<span class="number">475</span>,<span class="number">12</span> @@ <span class="type">static</span> __always_inline <span class="type">bool</span> <span class="title function_">cpus_have_cap</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num)</span></span><br><span class="line">  *</span><br><span class="line">  * @num must be a compile-time constant.</span><br><span class="line">  */</span><br><span class="line">-<span class="type">static</span> __always_inline <span class="type">bool</span> <span class="title function_">cpus_have_final_boot_cap</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">-&#123;</span><br><span class="line">-       <span class="keyword">if</span> (boot_capabilities_finalized())</span><br><span class="line">-               <span class="keyword">return</span> alternative_has_cap_unlikely(num);</span><br><span class="line">-       <span class="keyword">else</span></span><br><span class="line">-               BUG();</span><br><span class="line">-&#125;</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> cpus_have_final_boot_cap(num)               \</span></span><br><span class="line"><span class="meta">+       (&#123;                                          \</span></span><br><span class="line"><span class="meta">+               <span class="keyword">if</span> (!boot_capabilities_finalized()) \</span></span><br><span class="line"><span class="meta">+                       BUG();                      \</span></span><br><span class="line"><span class="meta">+               alternative_has_cap_unlikely(num);  \</span></span><br><span class="line"><span class="meta">+       &#125;)</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Test for a capability without a runtime check.</span></span><br><span class="line"><span class="comment">@@ -492,13 +491,12 @@ static __always_inline bool cpus_have_final_boot_cap(int num)</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @num must be a compile-time constant.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">-<span class="type">static</span> __always_inline <span class="type">bool</span> <span class="title function_">cpus_have_final_cap</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">-&#123;</span><br><span class="line">-       <span class="keyword">if</span> (system_capabilities_finalized())</span><br><span class="line">-               <span class="keyword">return</span> alternative_has_cap_unlikely(num);</span><br><span class="line">-       <span class="keyword">else</span></span><br><span class="line">-               BUG();</span><br><span class="line">-&#125;</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> cpus_have_final_cap(num)                      \</span></span><br><span class="line"><span class="meta">+       (&#123;                                            \</span></span><br><span class="line"><span class="meta">+               <span class="keyword">if</span> (!system_capabilities_finalized()) \</span></span><br><span class="line"><span class="meta">+                       BUG();                        \</span></span><br><span class="line"><span class="meta">+               alternative_has_cap_unlikely(num);    \</span></span><br><span class="line"><span class="meta">+       &#125;)</span></span><br><span class="line"></span><br><span class="line"> <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __attribute_const__</span><br><span class="line"> <span class="title function_">cpuid_feature_extract_signed_field_width</span><span class="params">(u64 features, <span class="type">int</span> field, <span class="type">int</span> width)</span></span><br><span class="line">diff --git a/drivers/Makefile b/drivers/Makefile</span><br><span class="line">index fe9ceb0d2..f60455123 100644</span><br><span class="line">--- a/drivers/Makefile</span><br><span class="line">+++ b/drivers/Makefile</span><br><span class="line">@@ -193,3 +193,5 @@ obj-$<span class="params">(CONFIG_CDX_BUS)</span>               += cdx/</span><br><span class="line"> obj-$(CONFIG_DPLL)             += dpll/</span><br><span class="line"></span><br><span class="line"> obj-$(CONFIG_S390)             += s390/</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y += -O0</span><br><span class="line">diff --git a/drivers/firmware/Makefile b/drivers/firmware/Makefile</span><br><span class="line">index <span class="number">7</span>a8d486e7.<span class="number">.342</span>f9dadc <span class="number">100644</span></span><br><span class="line">--- a/drivers/firmware/Makefile</span><br><span class="line">+++ b/drivers/firmware/Makefile</span><br><span class="line">@@ <span class="number">-36</span>,<span class="number">3</span> +<span class="number">36</span>,<span class="number">5</span> @@ obj-y                         += qcom/</span><br><span class="line"> obj-y                          += smccc/</span><br><span class="line"> obj-y                          += tegra/</span><br><span class="line"> obj-y                          += xilinx/</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y += -Og</span><br><span class="line">diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile</span><br><span class="line">index <span class="number">0</span>d872d4ef..baff0f30c <span class="number">100644</span></span><br><span class="line">--- a/drivers/net/ethernet/Makefile</span><br><span class="line">+++ b/drivers/net/ethernet/Makefile</span><br><span class="line">@@ <span class="number">-104</span>,<span class="number">3</span> +<span class="number">104</span>,<span class="number">5</span> @@ obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/</span><br><span class="line"> obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/</span><br><span class="line"> obj-$(CONFIG_NET_VENDOR_SYNOPSYS) += synopsys/</span><br><span class="line"> obj-$(CONFIG_NET_VENDOR_PENSANDO) += pensando/</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y += -Og</span><br><span class="line">diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h</span><br><span class="line">index <span class="number">79</span>edd5b5e..dba21fa6c <span class="number">100644</span></span><br><span class="line">--- a/include/net/sch_generic.h</span><br><span class="line">+++ b/include/net/sch_generic.h</span><br><span class="line">@@ <span class="number">-509</span>,<span class="number">7</span> +<span class="number">509</span>,<span class="number">7</span> @@ <span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> lockdep_tcf_proto_is_locked(<span class="keyword">struct</span> tcf_proto *tp)</span><br><span class="line"></span><br><span class="line"> <span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> qdisc_cb_private_validate(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> sz)</span><br><span class="line"> &#123;</span><br><span class="line">-       <span class="keyword">struct</span> qdisc_skb_cb *qcb;</span><br><span class="line">+       <span class="class"><span class="keyword">struct</span> <span class="title">qdisc_skb_cb</span> *<span class="title">qcb</span> __<span class="title">attribute__</span>((<span class="title">unused</span>));</span></span><br><span class="line"></span><br><span class="line">        BUILD_BUG_ON(<span class="keyword">sizeof</span>(skb-&gt;cb) &lt; <span class="keyword">sizeof</span>(*qcb));</span><br><span class="line">        BUILD_BUG_ON(<span class="keyword">sizeof</span>(qcb-&gt;data) &lt; sz);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>arm64</tag>
      </tags>
  </entry>
</search>
