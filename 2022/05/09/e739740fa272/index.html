<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.gngshn.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="在这边文章中, 我将以一个程序员的视角来谈一下我对ARMv8-A中的memory model的理解. 涉及到domain, atomic, ordering等. 如有错误请指正. 我会首先贴出ARM的官方描述, 然后在后面简要的描述一下我自己的理解. 部分章节或内容细节省略掉了.">
<meta property="og:type" content="article">
<meta property="og:title" content="ARMv8 memory model">
<meta property="og:url" content="https://blog.gngshn.com/2022/05/09/e739740fa272/index.html">
<meta property="og:site_name" content="gngshn的博客">
<meta property="og:description" content="在这边文章中, 我将以一个程序员的视角来谈一下我对ARMv8-A中的memory model的理解. 涉及到domain, atomic, ordering等. 如有错误请指正. 我会首先贴出ARM的官方描述, 然后在后面简要的描述一下我自己的理解. 部分章节或内容细节省略掉了.">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-09T12:06:25.000Z">
<meta property="article:modified_time" content="2025-01-02T05:59:41.601Z">
<meta property="article:author" content="gngshn">
<meta property="article:tag" content="arm">
<meta property="article:tag" content="armv8">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.gngshn.com/2022/05/09/e739740fa272/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.gngshn.com/2022/05/09/e739740fa272/","path":"2022/05/09/e739740fa272/","title":"ARMv8 memory model"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ARMv8 memory model | gngshn的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">gngshn的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">专注, 平静</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Atomicity-in-the-Arm-architecture"><span class="nav-number">1.</span> <span class="nav-text">Atomicity in the Arm architecture</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Requirements-for-single-copy-atomicity"><span class="nav-number">1.1.</span> <span class="nav-text">Requirements for single-copy atomicity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Properties-of-single-copy-atomic-accesses"><span class="nav-number">1.2.</span> <span class="nav-text">Properties of single-copy atomic accesses</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Multi-copy-atomicity"><span class="nav-number">1.3.</span> <span class="nav-text">Multi-copy atomicity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Requirements-for-multi-copy-atomicity"><span class="nav-number">1.4.</span> <span class="nav-text">Requirements for multi-copy atomicity</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Definition-of-the-Arm-memory-model"><span class="nav-number">2.</span> <span class="nav-text">Definition of the Arm memory model</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-definations"><span class="nav-number">2.1.</span> <span class="nav-text">Basic definations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Observer"><span class="nav-number">2.1.1.</span> <span class="nav-text">Observer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Common-Shareability-Domain"><span class="nav-number">2.1.2.</span> <span class="nav-text">Common Shareability Domain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Location"><span class="nav-number">2.1.3.</span> <span class="nav-text">Location</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Effects"><span class="nav-number">2.1.4.</span> <span class="nav-text">Effects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Register-effect"><span class="nav-number">2.1.5.</span> <span class="nav-text">Register effect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-effect"><span class="nav-number">2.1.6.</span> <span class="nav-text">Memory effect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reads-from"><span class="nav-number">2.1.7.</span> <span class="nav-text">Reads-from</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Local-read-successor"><span class="nav-number">2.1.8.</span> <span class="nav-text">Local read successor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Local-write-successor"><span class="nav-number">2.1.9.</span> <span class="nav-text">Local write successor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Coherence-order"><span class="nav-number">2.1.10.</span> <span class="nav-text">Coherence order</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Coherence-after"><span class="nav-number">2.1.11.</span> <span class="nav-text">Coherence-after</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Observed-by"><span class="nav-number">2.1.12.</span> <span class="nav-text">Observed-by</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Overlapping-accesses"><span class="nav-number">2.1.13.</span> <span class="nav-text">Overlapping accesses</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ordering-constraints"><span class="nav-number">2.2.</span> <span class="nav-text">Ordering constraints</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Other-multi-copy-atomic"><span class="nav-number">2.2.1.</span> <span class="nav-text">Other-multi-copy atomic</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory-barriers"><span class="nav-number">2.3.</span> <span class="nav-text">Memory barriers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Instruction-Synchronization-Barrier-ISB"><span class="nav-number">2.3.1.</span> <span class="nav-text">Instruction Synchronization Barrier (ISB)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Memory-Barrier-DMB"><span class="nav-number">2.3.2.</span> <span class="nav-text">Data Memory Barrier (DMB)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Synchronization-Barrier-DSB"><span class="nav-number">2.3.3.</span> <span class="nav-text">Data Synchronization Barrier (DSB)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shareability-and-access-limitations-on-the-data-barrier-operations"><span class="nav-number">2.3.4.</span> <span class="nav-text">Shareability and access limitations on the data barrier operations</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Memory-types-and-attributes"><span class="nav-number">3.</span> <span class="nav-text">Memory types and attributes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Normal-memory"><span class="nav-number">3.1.</span> <span class="nav-text">Normal memory</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Shareable-Normal-memory"><span class="nav-number">3.1.1.</span> <span class="nav-text">Shareable Normal memory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Shareable-Inner-Shareable-and-Outer-Shareable-Normal-memory"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">Shareable, Inner Shareable, and Outer Shareable Normal memory</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cacheability-attributes-for-Normal-memory"><span class="nav-number">3.1.2.</span> <span class="nav-text">Cacheability attributes for Normal memory</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Device-memory"><span class="nav-number">3.2.</span> <span class="nav-text">Device memory</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gngshn"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">gngshn</p>
  <div class="site-description" itemprop="description">linux程序员一枚</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gngshn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gngshn" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:gngshn@gmail.com" title="E-Mail → mailto:gngshn@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.gngshn.com/2022/05/09/e739740fa272/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="gngshn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gngshn的博客">
      <meta itemprop="description" content="linux程序员一枚">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="ARMv8 memory model | gngshn的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ARMv8 memory model
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-09 20:06:25" itemprop="dateCreated datePublished" datetime="2022-05-09T20:06:25+08:00">2022-05-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-02 13:59:41" itemprop="dateModified" datetime="2025-01-02T13:59:41+08:00">2025-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/arm/" itemprop="url" rel="index"><span itemprop="name">arm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>在这边文章中, 我将以一个程序员的视角来谈一下我对ARMv8-A中的memory model的理解. 涉及到domain, atomic, ordering等. 如有错误请指正.</p>
<p>我会首先贴出ARM的官方描述, 然后在后面简要的描述一下我自己的理解. 部分章节或内容细节省略掉了.</p>
<span id="more"></span>

<ul>
<li><h1 id="Atomicity-in-the-Arm-architecture"><a href="#Atomicity-in-the-Arm-architecture" class="headerlink" title="Atomicity in the Arm architecture"></a>Atomicity in the Arm architecture</h1><p>这里要注意的是, 此处所说的atomic并非是原子指令所说的原子. 这里描述的是系统对一段memory的访问(读或写)是否是一笔完成, 不被其他transaction打断. 或者说读或写不会和其他读或写产生交叉. 不会读到部分写效果, 也不会只写一部分.</p>
<ul>
<li><h2 id="Requirements-for-single-copy-atomicity"><a href="#Requirements-for-single-copy-atomicity" class="headerlink" title="Requirements for single-copy atomicity"></a>Requirements for single-copy atomicity</h2><p>For explicit memory effects generated from an Exception level the following rules apply:</p>
<ul>
<li>A read that is generated by a load instruction that loads a single general-purpose register and is aligned to the size of the read in the instruction is single-copy atomic.</li>
<li>A write that is generated by a store instruction that stores a single general-purpose register and is aligned to the size of the write in the instruction is single-copy atomic.</li>
<li>Reads that are generated by a Load Pair instruction that loads two general-purpose registers and are aligned to the size of the load to each register are treated as two single-copy atomic reads, one for each register being loaded.</li>
<li>Writes that are generated by a Store pair instruction that stores two general-purpose registers and are aligned to the size of the store of each register are treated as two single-copy atomic writes, one for each register being stored.</li>
<li>Load-Exclusive Pair instructions of two 32-bit quantities and Store-Exclusive Pair instructions of 32-bit quantities are single-copy atomic.</li>
<li>When the Store-Exclusive of a Load-Exclusive&#x2F;Store-Exclusive pair instruction using two 64-bit quantities succeeds, it causes a single-copy atomic update of the entire memory location being updated.<blockquote>
<p>Note: To atomically load two 64-bit quantities, perform a Load-Exclusive pair&#x2F;Store-Exclusive pair sequence of reading and writing the same value for which the Store-Exclusive pair succeeds, and use the read values from the Load-Exclusive pair.</p>
</blockquote>
</li>
<li>Where translation table walks generate a read of a translation table entry, this read is single-copy atomic.</li>
<li>…</li>
</ul>
<p>注意的是这里的copy不要理解为复制, 个人认为这里理解为一份或副本可能更好一点. 后面会在multi-copy中再来细说这个.</p>
<p>这里描述single-copy atomicity的要求, 如要求对齐的load&#x2F;store是原子的. 对于load pair指令也有相应的约束, 细节可以逐条看spec. 就不啰嗦了.</p>
</li>
<li><h2 id="Properties-of-single-copy-atomic-accesses"><a href="#Properties-of-single-copy-atomic-accesses" class="headerlink" title="Properties of single-copy atomic accesses"></a>Properties of single-copy atomic accesses</h2><p>A memory access instruction that is single-copy atomic has the following properties:</p>
<ul>
<li>For a pair of overlapping single-copy atomic store instructions, all of the overlapping writes generated by one of the stores are Coherence-after the corresponding overlapping writes generated by the other store.</li>
<li>For a single-copy atomic load instruction L1 that overlaps a single-copy atomic store instruction S2, if one of the overlapping reads generated by L1 Reads-from one of the overlapping writes generated by S2, then none of the overlapping writes generated by S2 are Coherence-after the corresponding overlapping reads generated by L1.</li>
</ul>
<p>对于single-atomic的访存指令, 他有如下的属性:</p>
<ul>
<li>如果两条store指令有overlaping(见后面的overlapping access), 则两条指令一定是先后完成的. 也就是说, 两条指令不会同时修改内存, 而是一条修改完之后, 另一条才进行修改</li>
<li>如果load指令L1和store指令S2有重叠, 如果L1读到了S2的store的一个location(byte, 可以重叠多个location), 则L1一定读到了S2 store的所有overlap location, 也就是说如果L1不会读到S2部分的结果, 要么读到的是S2完成后的结果, 要么读到的是S2未产生效果时的结果.</li>
</ul>
</li>
<li><h2 id="Multi-copy-atomicity"><a href="#Multi-copy-atomicity" class="headerlink" title="Multi-copy atomicity"></a>Multi-copy atomicity</h2><p>In a multiprocessing system, writes to a memory location are multi-copy atomic if the following conditions are both true:</p>
<ul>
<li>All writes to the same location are serialized, meaning they are observed in the same order by all observers, although some observers might not observe all of the writes.</li>
<li>A read of a location does not return the value of a write until all observers observe that write.</li>
</ul>
<blockquote>
<p>Note: Writes that are not coherent are not multi-copy atomic.</p>
</blockquote>
<p>multi-copy atomicity描述的是多个PE(Processing Element, 可以认为是一个cpu core)的atomic, 个人理解, 这里的multi-copy可以认为是多个PE都可能有同一个location的副本(copy, 我觉得可以看做cache), 他们之间存在observed-by的关系. multi-copy atomic要求: 所有的observers对同一个location发起的写必须是完全顺序的, 每一笔写都<strong>可以</strong>被所有的observer观察到(当然observer不一定会去实际观察, 因此observer可能不会观察到所有的写, 但是观察到的写的顺序一定是一致的, 比如A, B, C, D四个写, Observer1观察到了A, C, D, Observer2观察到了B, D, Observer3观察到了A, C). 并且写指令在所有观察者可以观察到这个写之前是不能返回的. 另外这里的观察到可以见后面的observed-by详细描述.</p>
<p>从硬件上来看, 我觉得可以这样来理解, 在多核系统上, 多个observer都有自己的cache, 他们可以通过一定的cache总线和协议(如CCI和MOESI)来维护cache一致性. 对于multi-copy atomicity来说, 当一个observer对一个location发起写操作时, 其他的observer上的对应cache条目需要被invalid&#x2F;update(相当于观察到了这笔写)后才算这笔写完成(指令才能返回). 因此multi-copy atomicity是一个很高的原子要求. 写会变得很慢.</p>
<p>因此, arm的memory model不是使用的multi-copy atomicity, 而是使用的other-multi-copy aomicity. 这个后续会讲到.</p>
<p>但是这里要再多讲一句，ARM所说的multi-copy atomic和其他架构说的不是一回事，ARM的other-multi-copy atomic和我们常说的multi-copy atomic其实是一回事</p>
</li>
<li><h2 id="Requirements-for-multi-copy-atomicity"><a href="#Requirements-for-multi-copy-atomicity" class="headerlink" title="Requirements for multi-copy atomicity"></a>Requirements for multi-copy atomicity</h2><p>For Normal memory, writes are not required to be multi-copy atomic.</p>
<p>For Device memory, writes are not required to be multi-copy atomic.</p>
<p>The Arm memory model is Other-multi-copy atomic.</p>
<p>ARMv8不要求multi-copy atomicity, 而是要求other-multi-copy atomicity</p>
</li>
</ul>
</li>
<li><h1 id="Definition-of-the-Arm-memory-model"><a href="#Definition-of-the-Arm-memory-model" class="headerlink" title="Definition of the Arm memory model"></a>Definition of the Arm memory model</h1><ul>
<li><h2 id="Basic-definations"><a href="#Basic-definations" class="headerlink" title="Basic definations"></a>Basic definations</h2><p>ARMv8 memory model中有很多的概念, 这里抽出来一些来讲一下:</p>
<ul>
<li><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>An Observer refers to a processing element or mechanism in the system, such as a peripheral device, that can generate reads from, or writes to, memory.</p>
<p>Observer就是一个可以发起读写的master, 可以是一个外设, 或CPU内部能够发起读写的一些组件(取指, load&#x2F;store, MMU)等.</p>
</li>
<li><h3 id="Common-Shareability-Domain"><a href="#Common-Shareability-Domain" class="headerlink" title="Common Shareability Domain"></a>Common Shareability Domain</h3><p>For the purpose of this section, all Observers are assumed to belong to a Common Shareability Domain. All read and write effects access only Normal memory locations in a Common Shareability Domain, and excludes the situations described in Mismatched memory attributes on page B2-205.</p>
<p>我们这里讲的observers都是在同一个sharebility domain, 并且都是对normal memory发起的访问. sharebility domain在后面会讲到</p>
</li>
<li><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>A Location is a byte that is associated with an address in the physical address space.</p>
<blockquote>
<p>Note: It is expected that an operating system will present the illusion to the application programmer that is consistent with a location also being considered as a byte that is associated with an address in the virtual address space.</p>
</blockquote>
<p>Location就是对应到一个物理地址的byte. 另外操作系统可以透明的让程序员看到用虚拟地址对应的byte.</p>
</li>
<li><h3 id="Effects"><a href="#Effects" class="headerlink" title="Effects"></a>Effects</h3><p>The Effects of an instruction can be:</p>
<ul>
<li>Register effects.</li>
<li>Memory effects.</li>
<li>Barrier effects.</li>
<li>Tag effects.</li>
<li>Branching effects.</li>
</ul>
<p>The effects of an instruction I1 are said to appear in program order before the effects of an instruction I2 if and only if I1 occurs before I2 in the order specified by the program. Each effect generated by an instruction has a unique identifier, which characterizes it amongst the events generated by the same instruction.</p>
<p>Effect是一条指令的效果, 它可以是引起寄存器被读写, 内存被读写, 产生屏障, Tag(这里我没细看), 产生跳转决策等</p>
<p>如果说指令I1和I2是按照程序顺序发生, 那么他们产生的effect也是按程序顺序发生的</p>
</li>
<li><h3 id="Register-effect"><a href="#Register-effect" class="headerlink" title="Register effect"></a>Register effect</h3><p>The Register effects of an instruction are register reads or register writes of that instruction. For an instruction that accesses registers, a register read effect is generated for each register read by the instruction and a register write effect is generated for each register written by the instruction. An instruction may generate both read and write Register effects.</p>
<p>Register effect是一条指令产生对寄存器读或写的效果, 一条指令可以同时产生读效果和写效果</p>
</li>
<li><h3 id="Memory-effect"><a href="#Memory-effect" class="headerlink" title="Memory effect"></a>Memory effect</h3><p>The Memory effects of an instruction are the memory reads or writes generated by that instruction. For an instruction that accesses memory, a memory read effect is generated for each Location read by the instruction and a memory write effect is generated for each Location written by the instruction. An instruction may generate both read and write Memory effects.</p>
<p>Memory effect是一条指令产生对memory读或写的效果, 一条指令可以同时产生读效果和写效果, 比如原子改写指令LDADD等</p>
</li>
<li><h3 id="Reads-from"><a href="#Reads-from" class="headerlink" title="Reads-from"></a>Reads-from</h3><p>The Reads-from relation couples memory read and write effects to the same Location such that each memory read effect is paired with exactly one memory write effect in the execution of a program. A memory read effect R2 from a Location Reads-from a memory write effect W1 to the same Location if and only if R2 takes its data from W1.</p>
<p>Reads-from的意思是如果读效果R1读到的是写效果W1的结果, 那么R1 reads-from W1. 比如一条load指令, 加载了一条store指令store到memory中的结果.</p>
</li>
<li><h3 id="Local-read-successor"><a href="#Local-read-successor" class="headerlink" title="Local read successor"></a>Local read successor</h3><p>A memory read effect R2 of a Location is the Local read successor of a memory write effect W1 from the same Observer to the same Location if and only if W1 appears in program order before R2 and there is not a memory write effect W3 from the same Observer to the same Location appearing in program order between W1 and R2.</p>
<p>同一个observer对同一个location的读写, 如果读R2读到的是W1的结果, 那么R2 local read successor W1.</p>
</li>
<li><h3 id="Local-write-successor"><a href="#Local-write-successor" class="headerlink" title="Local write successor"></a>Local write successor</h3><p>A memory write effect W2 of a Location is a Local write successor of a memory read or write effect RW1 from the same Observer to the same Location if and only if RW1 appears in program order before W2.</p>
<p>同一个observer对同一个location的读写, 如果写W2是在读或写RW1之后发生, 则W2 local write successor RW1</p>
</li>
<li><h3 id="Coherence-order"><a href="#Coherence-order" class="headerlink" title="Coherence order"></a>Coherence order</h3><p>There is a per-location Coherence order relation that provides a total order over all memory write effects from all coherent Observers to that Location, starting with a notional memory write effect of the initial value. The Coherence order of a Location represents the order in which memory write effects to the Location arrive at memory.</p>
<p>Coherence order是指所有的coherence observers观察到的对同一个location写到达的顺序</p>
</li>
<li><h3 id="Coherence-after"><a href="#Coherence-after" class="headerlink" title="Coherence-after"></a>Coherence-after</h3><p>A memory write effect W2 to a Location is Coherence-after another memory write effect W1 to the same Location if and only if W2 is sequenced after W1 in the Coherence order of the Location.</p>
<p>写W2 Coherence-after写W1, 表示在同一个location上, W2在W1之后到达</p>
<p>A memory write effect W2 to a Location is Coherence-after a memory read effect R1 of the same location if and only if R1 Reads-from a memory write effect W3 to the same Location and W2 is Coherence-after W3.</p>
<p>写W2 Coherence-after读R1, 表示在同一个location上, R1读到是W2前的W3产生的写, 顺序是W3-&gt;R1-&gt;W2</p>
<p>可以看到coherence-after表示的是在同一location上一个写后于读&#x2F;写的含义</p>
</li>
<li><h3 id="Observed-by"><a href="#Observed-by" class="headerlink" title="Observed-by"></a>Observed-by</h3><p>A memory read or write effect RW1 from an Observer is Observed-by a memory write effect W2 from a different Observer if and only if W2 is coherence-after RW1.</p>
<p>RW1被W2观察到(RW1 observed-by W2), 表示W2 Coherence-after RW1, 也就是说W2比RW1后到达location, 且W2和RW1中间没有其他Wx</p>
<p>A memory write effect W1 from an Observer is Observed-by a memory read effect R2 from a different Observer if and only if R2 Reads-from W1.</p>
<p>W1被R2观察到(W1 observed-by R2), 表示R2 reads-from W1, 也就是说R2读到了W1的结果</p>
<blockquote>
<p>Note: The Observed-by relation relates only Memory effects generated by different Observers.</p>
</blockquote>
<p>observed-by描述的是不同的observer对一个location的操作顺序</p>
<p>这里的observed不要理解成读, observed并不需要读(load)到哪个数据才叫observed, 只要满足上面两条就可以看做observed</p>
</li>
<li><h3 id="Overlapping-accesses"><a href="#Overlapping-accesses" class="headerlink" title="Overlapping accesses"></a>Overlapping accesses</h3><p>Two Memory effects overlap if and only if they access the same Location. Two instructions overlap if and only if one or more of their generated Memory effects overlap.</p>
<p>memory effect overlap是指访问到了相同的location(byte), instruction overlap是指两条指令产生了访问到了相同的location(bytes)</p>
</li>
</ul>
</li>
<li><h2 id="Ordering-constraints"><a href="#Ordering-constraints" class="headerlink" title="Ordering constraints"></a>Ordering constraints</h2><p>The Arm memory model is described as being Other-multi-copy atomic. The definition of Other-multi-copy atomic is as follows:</p>
<ul>
<li><h3 id="Other-multi-copy-atomic"><a href="#Other-multi-copy-atomic" class="headerlink" title="Other-multi-copy atomic"></a>Other-multi-copy atomic</h3><p>In an Other-multi-copy atomic system, it is required that a memory write effect from an Observer, if observed by a different Observer, is then observed by all other Observers that access the Location coherently. It is, however, permitted for an Observer to observe its own writes prior to making them visible to other observers in the system.</p>
<p>ARMv8使用的是other-multi-copy atomic, other-multi-copy atomic要求, 对于其中一个observer的写, 如果被任意一个observer观察到, 那么所有其他的observers都必须能观察到这笔写. 并且发起写的这个observer是可以比其他observer先观察到它自己的这笔写的.</p>
<p>从硬件上来讲, 这表示一个PE执行写操作之后, 是可以立即返回的. 不用等CCI总线基于MOESI去对cache进行操作, 就可以执行完成返回, 继续下一条指令了. 如果其中一个observer观察到了这笔写(也就是说那个observer的cache已经同步了), 那么所有的observer的cache都必须已经同步.</p>
</li>
</ul>
</li>
<li><h2 id="Memory-barriers"><a href="#Memory-barriers" class="headerlink" title="Memory barriers"></a>Memory barriers</h2><p>Memory barrier is the general term applied to an instruction, or sequence of instructions, that forces synchronization events by a PE with respect to retiring load&#x2F;store instructions. The memory barriers defined by the Arm architecture provide a range of functionality, including:</p>
<ul>
<li>Ordering of load&#x2F;store instructions.</li>
<li>Completion of load&#x2F;store instructions.</li>
<li>Context synchronization.</li>
</ul>
<ul>
<li><h3 id="Instruction-Synchronization-Barrier-ISB"><a href="#Instruction-Synchronization-Barrier-ISB" class="headerlink" title="Instruction Synchronization Barrier (ISB)"></a>Instruction Synchronization Barrier (ISB)</h3><p>An ISB instruction ensures that all instructions that come after the ISB instruction in program order are fetched from the cache or memory after the ISB instruction has completed. Using an ISB ensures that the effects of context-changing operations executed before the ISB are visible to the instructions fetched after the ISB instruction. Examples of context-changing operations that require the insertion of an ISB instruction to ensure the effects of the operation are visible to instructions fetched after the ISB instruction are:</p>
<ul>
<li>Completed cache and TLB maintenance instructions.</li>
<li>Changes to System registers.</li>
</ul>
<p>Any context-changing operations appearing in program order after the ISB instruction take effect only after the ISB has been executed.</p>
<p>ISB保证和ISB指令完成后, 所有的指令都会cache&#x2F;memory重新获取. 从硬件上看, 相当于把CPU的pipeline flush掉, 然后从ISB后面的指令开始重新跑. ISB可以保证cache和TLB的操作或system寄存器的修改产生的效果能实际影响到ISB后面的指令. 在进程切换, cache操作, MMU操作, system寄存器修改后之后往往需要ISB来保证后续的指令是在上述操作之后的环境下产生的执行效果.</p>
<p>网上有很多博主说ISB是比DSB更加严格的barriar, 其实这是不对的. ISB和DSB是两个不同的概念, 他们的目的也不一样. DSB有ISB无法完成的功能, ISB也有DSB无法完成的功能.</p>
</li>
<li><h3 id="Data-Memory-Barrier-DMB"><a href="#Data-Memory-Barrier-DMB" class="headerlink" title="Data Memory Barrier (DMB)"></a>Data Memory Barrier (DMB)</h3><p>The DMB instruction is a memory barrier instruction that ensures the relative order of memory accesses before the barrier with memory accesses after the barrier. The DMB instruction does not ensure the completion of any of the memory accesses for which it ensures relative order.</p>
<p>The basic principle of a DMB instruction is to introduce order between memory accesses that are specified to be affected by the DMB options supplied as arguments to the DMB instruction. The DMB instruction ensures that all affected memory accesses by the PE executing the DMB instruction that appear in program order before the DMB instruction and those which originate from a different PE, to the extent required by the DMB options, which have been Observed-by the PE before the DMB instruction is executed, are Observed-by each PE, to the extent required by the DMB options, before any affected memory accesses that appear in program order after the DMB instruction are Observed-by that PE.</p>
<p>DMB保证了DMB前面的和后面的load&#x2F;store&#x2F;cache指令不会越过DMB发生乱序, DMB只保证顺序, 不保证前面的命令执行完成.</p>
<p>DMB指令可以在后面加参数来表示它限制的指令类型, 和保证生效的domain. 如DMB ISHST, ISH表示inner-shareable, ST表示限制STORE-STORE的顺序, 这条指令可以保证当前PE在DMB之后的指令观察到DMB前面的store的结果之前, 整个inner-shareable domain其他PE也都可以观察到DMB前面的store的结果, 关于domain, 后面会讲到</p>
</li>
<li><h3 id="Data-Synchronization-Barrier-DSB"><a href="#Data-Synchronization-Barrier-DSB" class="headerlink" title="Data Synchronization Barrier (DSB)"></a>Data Synchronization Barrier (DSB)</h3><p>A DSB instruction is a memory barrier that ensures that memory accesses that occur before the DSB instruction have completed before the completion of the DSB instruction. In doing this, it acts as a stronger barrier than a DMB and all ordering that is created by a DMB with specific options is also generated by a DSB with the same options.</p>
<p>A DSB instruction executed by a PE, PEe, completes when all of the following apply:</p>
<p>In addition, no instruction that appears in program order after the DSB instruction can alter any state of the system or perform any part of its functionality until the DSB completes other than:</p>
<ul>
<li>Being fetched from memory and decoded.</li>
<li>Reading the general-purpose, SIMD and floating-point, SVE vector or predicate, Special-purpose, or System registers that are directly or indirectly read without causing side-effects.</li>
<li>If FEAT_ETS is not implemented, having any virtual addresses of loads and stores translated.</li>
</ul>
<p>DSB是一个比DMB更强约束的指令, 并且和DMB一样可以在后面加参数产生一样的限制效果, DSB约束更强表现为:</p>
<ul>
<li>在DSB前面的load&#x2F;store&#x2F;cache完成之前, dsb不会返回, 相当于其他PE可以观察到dsb前面的这些操作前不能返回</li>
<li>DSB代码序(程序顺序)后面的所有会影响系统状态的指令都不会在DSB完成之前执行. 个人理解就是这些指令不能乱序到DMB前面来执行</li>
</ul>
</li>
<li><h3 id="Shareability-and-access-limitations-on-the-data-barrier-operations"><a href="#Shareability-and-access-limitations-on-the-data-barrier-operations" class="headerlink" title="Shareability and access limitations on the data barrier operations"></a>Shareability and access limitations on the data barrier operations</h3><p>The DMB and DSB instructions take an argument that specifies:</p>
<ul>
<li><p>The shareability domain over which the instruction must operate. This is one of:</p>
<ul>
<li>Full system.</li>
<li>Outer Shareable.</li>
<li>Inner Shareable.</li>
<li>Non-shareable.</li>
</ul>
</li>
</ul>
<p>Full system applies to all the observers in the system and, as such, encompasses the Inner and Outer Shareable domains of the processor.</p>
<ul>
<li><p>The accesses for which the instruction operates. This is one of:</p>
<ul>
<li>Read and write accesses, both before and after the barrier instruction.</li>
<li>Write accesses only, before and after the barrier instruction.</li>
<li>Read accesses before the barrier instruction, and read and write accesses after the barrier instruction.</li>
</ul>
</li>
</ul>
<p>DMB和DSB后面可以加参数来确定屏障生效的范围, 具体可以参考ARMv8-A ARM的table2-1, 一共有3种读写限制方式*4种domain&#x3D;12种case. 对于shareable domain后面还会讲</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h1 id="Memory-types-and-attributes"><a href="#Memory-types-and-attributes" class="headerlink" title="Memory types and attributes"></a>Memory types and attributes</h1><p>ARMv8将memory分为normal memory和device memory两种. 简单来说可以分别对应于RAM和外设.</p>
<ul>
<li><h2 id="Normal-memory"><a href="#Normal-memory" class="headerlink" title="Normal memory"></a>Normal memory</h2><p>The Normal memory type attribute applies to most memory in a system. It indicates that the hardware is permitted by the architecture to perform Speculative data read accesses to these locations, regardless of the access permissions for these locations.</p>
<p>For accesses to Normal memory, a DMB instruction is required to ensure the required ordering.</p>
<p>对于normal memory, 是允许硬件进行投机的访问的, 也就是说对normal memory进行读访问是没有side effect的. 对normal memory进行write, 如果写入的值和前值相等, 那也是没有side effect的. 想想我们的外设寄存器, 很多寄存器都是不能满足这个特性的. 允许对normal memory进行非对齐访问. 另外对normal memory的访问是可以merge的. 比如连续对数组两个元素的写, 可以合并成一条写来增加效率. normal memory的访问是允许进行乱序的, 如果需要顺序访问, 则需要加DMB&#x2F;DSB屏障</p>
<ul>
<li><h3 id="Shareable-Normal-memory"><a href="#Shareable-Normal-memory" class="headerlink" title="Shareable Normal memory"></a>Shareable Normal memory</h3><p>A Normal memory location has a Shareability attribute that is one of:</p>
<ul>
<li>Inner Shareable, meaning it applies across the Inner Shareable shareability domain.</li>
<li>Outer Shareable, meaning it applies across both the Inner Shareable and the Outer Shareable shareability domains.</li>
<li>Non-shareable.</li>
</ul>
<ul>
<li><h4 id="Shareable-Inner-Shareable-and-Outer-Shareable-Normal-memory"><a href="#Shareable-Inner-Shareable-and-Outer-Shareable-Normal-memory" class="headerlink" title="Shareable, Inner Shareable, and Outer Shareable Normal memory"></a>Shareable, Inner Shareable, and Outer Shareable Normal memory</h4><p>The Arm architecture abstracts the system as a series of Inner and Outer Shareability domains.</p>
<p>Each Inner Shareability domain contains a set of observers that are data coherent for each member of that set for data accesses with the Inner Shareable attribute made by any member of that set.</p>
<p>Each Outer Shareability domain contains a set of observers that are data coherent for each member of that set for data accesses with the Outer Shareable attribute made by any member of that set.</p>
<p>The following properties also hold:</p>
<ul>
<li>Each observer is a member of only a single Inner Shareability domain.</li>
<li>Each observer is a member of only a single Outer Shareability domain.</li>
<li>All observers in an Inner Shareability domain are always members of the same Outer Shareability domain. This means that an Inner Shareability domain is a subset of an Outer Shareability domain, although it is not required to be a proper subset.</li>
</ul>
<blockquote>
<p>Note:<br>Because all data accesses to Non-cacheable locations are data coherent to all observers, Non-cacheable locations are always treated as Outer Shareable.<br>The Inner Shareable domain is expected to be the set of PEs controlled by a single hypervisor or operating system.</p>
</blockquote>
<p>The details of the use of the shareability attributes are system-specific.</p>
</li>
</ul>
<p>Normal memory可以有shareability attribute, 可以是inner&#x2F;outer&#x2F;non-shareable, 这个attribute可以通过MMU页表的属性来配置. 这个特性和硬件定义的domain进行配合使用</p>
<p>简单来说, SoC在设计时会将系统分为如下四个shareable domain:</p>
<ul>
<li>non-shareable domain, 一般将一个core分在一个non-shareable domain中</li>
<li>inner-shareable domain, 一般将所有的core分在一个inner-shareable domain中, 可以有多个inner-shareable domain. 比如将cpu core分成两组, 分别跑不同的OS</li>
<li>outer-shareable domain, 一般将cache coherence的外设(如接在CCI上的GPU)和CPU一起放在outer-shareable domain中</li>
<li>system domain, 表示整个系统</li>
</ul>
<p>此时PEs访存的特性为:</p>
<ul>
<li>当cpu访问non-shareable memory时, 硬件不用去往外面广播来维护cache达到coherence</li>
<li>当cpu访问inner-shareable memory时, 硬件会通过bus和协议来让inner-shareable domain中的所有observer达到coherence</li>
<li>当cpu访问outer-shareable memory是, 硬件会通过bus和协议来让outer-shareable domain中的所有observer达到coherence</li>
</ul>
<p>上面说的硬件一般是CCI以及其内部的snoop组件. 通过MOESI来让所有的observer的cache达到一致(coherence).</p>
<p>另外前面讲过的DMB&#x2F;DSB可以通过指定shareable domain来将讲数据同步到指定的domain中.</p>
<p>另外一般来说, 跑在同一个操作系统上的PEs都会设定在同一个inner shareable domain上.</p>
<p>将系统切分不同的domain主要是为了更好的性能和更加的省电(不需要多做额外的coherence操作)</p>
</li>
<li><h3 id="Cacheability-attributes-for-Normal-memory"><a href="#Cacheability-attributes-for-Normal-memory" class="headerlink" title="Cacheability attributes for Normal memory"></a>Cacheability attributes for Normal memory</h3><p>In addition to being Outer Shareable, Inner Shareable or Non-shareable, each region of Normal memory is assigned a Cacheability attribute that is one of:</p>
<ul>
<li>Write-Through Cacheable.</li>
<li>Write-Back Cacheable.</li>
<li>Non-cacheable.</li>
</ul>
<p>Also, for Write-Through Cacheable and Write-Back Cacheable Normal memory regions:</p>
<ul>
<li>A region might be assigned cache allocation hints for read and write accesses.</li>
<li>It is IMPLEMENTATION DEFINED whether the cache allocation hints can have an additional attribute of Transient or Non-transient.</li>
</ul>
<p>Normal memory可以配置cache属性, cacheable&#x2F;non-cacheable, 对于cacheable, cache update的属性有:</p>
<ul>
<li>write-back, 表示store只将数据写到cache中</li>
<li>write-through, 表示store将数据同时写到cache和memory中</li>
</ul>
<p>cache allocation的属性有：</p>
<ul>
<li>read-allocate, 表示read miss时, 将发生cache line fill</li>
<li>write-allocate, 表示write miss时, 将发生cache line fill</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="Device-memory"><a href="#Device-memory" class="headerlink" title="Device memory"></a>Device memory</h2><p>The Device memory type attributes define memory locations where an access to the location can cause side-effects, or where the value returned for a load can vary depending on the number of loads performed. Typically, the Device memory attributes are used for memory-mapped peripherals and similar locations.</p>
<p>Device memory定义的内存区被访问时可能产生side effect, 多次从同一位置进行load时可能发生变化. 这些属性和和外设寄存器非常像. 所以通常来说device memory通常用来作为外设的映射属性.</p>
<p>Device memory有如下的属性:</p>
<ul>
<li>不允许进行投机的访问</li>
<li>数据访问对系统中所有的observer都是coherence的, 可以被视为outer shareable</li>
<li>device memory不能被cache</li>
<li>更多细节见ARMv8-A ARM手册…</li>
</ul>
<p>The Armv8 Device memory types are:</p>
<ul>
<li><strong>Device-nGnRnE</strong> Device non-Gathering, non-Reordering, No Early Write Acknowledgement. Equivalent to the Strongly-ordered memory type in earlier versions of the architecture.</li>
<li><strong>Device-nGnRE</strong> Device non-Gathering, non-Reordering, Early Write Acknowledgement. Equivalent to the Device memory type in earlier versions of the architecture.</li>
<li><strong>Device-nGRE</strong> Device non-Gathering, Reordering, Early Write Acknowledgement. Armv8 adds this memory type to the translation table formats found in earlier versions of the architecture. The use of barriers is required to order accesses to Device-nGRE memory.</li>
<li><strong>Device-GRE</strong> Device Gathering, Reordering, Early Write Acknowledgement. Armv8 adds this memory type to the translation table formats found in earlier versions of the architecture. Device-GRE memory has the fewest constraints. It behaves similar to Normal memory, with the restriction that Speculative accesses to Device-GRE memory is forbidden.</li>
</ul>
<p>Device memory类型可以有Device-nGnRnE(等价于ARMv7的Strongly-ordered), Device-nGnRE(相当于ARMv7的device memory), Device-nGRE, Device-GRE这几种</p>
<p>nG, G的G表示gathering, gathering表示是否可以将多笔连续地址写合并为一笔或将多笔同一地址写合并为一笔写</p>
<p>nR, R的R表示reordering, reordering表示对这种类型地址的方式是否可以像normal memory那样进行乱序访问</p>
<p>nE, E的E表示early-acknowlegement, early-acknowlegement相当于post write, 写操作可能被总线上的buffer直接会ack就表示完成, nE相当于non-post write, 一笔写必须等到实际写的位置确认才能表示完成. 所以当PE执行DSB时必须再写到达内存端点(比如实际写入到了外设寄存器)之后才完成</p>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/arm/" rel="tag"><i class="fa fa-tag"></i> arm</a>
              <a href="/tags/armv8/" rel="tag"><i class="fa fa-tag"></i> armv8</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/26/b76ba7cb1323/" rel="prev" title="使用vscode和qemu调试linux内核（包含汇编）">
                  <i class="fa fa-angle-left"></i> 使用vscode和qemu调试linux内核（包含汇编）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/05/13/43df98d380f6/" rel="next" title="使用Rust转换bayer和yuv图像">
                  使用Rust转换bayer和yuv图像 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">gngshn</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
