<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gngshn的博客</title>
  <icon>https://www.gravatar.com/avatar/aa0b2b8f6666ac9818fed2bf83d84fc2</icon>
  <subtitle>专注, 平静</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gngshn.github.io/"/>
  <updated>2022-04-26T10:31:50.702Z</updated>
  <id>http://gngshn.github.io/</id>
  
  <author>
    <name>gngshn</name>
    <email>gngshn@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用vscode和qemu调试linux内核（包含汇编）</title>
    <link href="http://gngshn.github.io/2022/04/26/%E4%BD%BF%E7%94%A8vscode%E5%92%8Cqemu%E8%B0%83%E8%AF%95linux%E5%86%85%E6%A0%B8%EF%BC%88%E5%8C%85%E5%90%AB%E6%B1%87%E7%BC%96%EF%BC%89/"/>
    <id>http://gngshn.github.io/2022/04/26/使用vscode和qemu调试linux内核（包含汇编）/</id>
    <published>2022-04-26T03:42:50.000Z</published>
    <updated>2022-04-26T10:31:50.702Z</updated>
    
    <content type="html"><![CDATA[<p>vscode调试kernel的汇编部分有两个麻烦点</p><ul><li>linux加载地址和链接地址不同</li><li>vscode的默认setupCommands无法正常使用<a id="more"></a></li></ul><p>通过一段时间的摸索我找到了调试这部分代码的方法</p><ul><li>对于加载地址问题，可以通过gdb的add-symbol-file的-o参数来解决（这要求gdb的版本较新才可以）</li><li>对于vscode的配置，后面我会列出目前摸索出的配置文件供参考</li></ul><h1 id="调试步骤"><a href="#调试步骤" class="headerlink" title="调试步骤"></a>调试步骤</h1><ul><li><p>编译linux内核，目前我使用的是linux-5.17.4内核</p><p>  为了能更好的支持c的调试，我这边尽可能的将C代码通过O0编译，对kernel做了如下修改, 并且编译去掉了CONFIG_JUMP_LABEL：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/arch/arm64/Makefile b/arch/arm64/Makefile</span><br><span class="line">index 2f1de8865..27ecec930 100644</span><br><span class="line">--- a/arch/arm64/Makefile</span><br><span class="line">+++ b/arch/arm64/Makefile</span><br><span class="line">@@ -213,3 +213,5 @@ define archhelp</span><br><span class="line">   echo  &apos;                  (distribution) /sbin/installkernel or&apos;</span><br><span class="line">   echo  &apos;                  install to $$(INSTALL_PATH) and run lilo&apos;</span><br><span class="line"> endef</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O0</span><br><span class="line">diff --git a/drivers/Makefile b/drivers/Makefile</span><br><span class="line">index a110338c8..da99b36a1 100644</span><br><span class="line">--- a/drivers/Makefile</span><br><span class="line">+++ b/drivers/Makefile</span><br><span class="line">@@ -187,3 +187,5 @@ obj-$(CONFIG_GNSS)+= gnss/</span><br><span class="line"> obj-$(CONFIG_INTERCONNECT)+= interconnect/</span><br><span class="line"> obj-$(CONFIG_COUNTER)+= counter/</span><br><span class="line"> obj-$(CONFIG_MOST)+= most/</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O0</span><br><span class="line">diff --git a/drivers/char/tpm/Makefile b/drivers/char/tpm/Makefile</span><br><span class="line">index 66d39ea6b..252f4d9d2 100644</span><br><span class="line">--- a/drivers/char/tpm/Makefile</span><br><span class="line">+++ b/drivers/char/tpm/Makefile</span><br><span class="line">@@ -41,3 +41,5 @@ obj-$(CONFIG_TCG_XEN) += xen-tpmfront.o</span><br><span class="line"> obj-$(CONFIG_TCG_CRB) += tpm_crb.o</span><br><span class="line"> obj-$(CONFIG_TCG_VTPM_PROXY) += tpm_vtpm_proxy.o</span><br><span class="line"> obj-$(CONFIG_TCG_FTPM_TEE) += tpm_ftpm_tee.o</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O1</span><br><span class="line">diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile</span><br><span class="line">index b2728d00f..f369abb70 100644</span><br><span class="line">--- a/drivers/net/phy/Makefile</span><br><span class="line">+++ b/drivers/net/phy/Makefile</span><br><span class="line">@@ -85,3 +85,5 @@ obj-$(CONFIG_STE10XP)+= ste10Xp.o</span><br><span class="line"> obj-$(CONFIG_TERANETICS_PHY)+= teranetics.o</span><br><span class="line"> obj-$(CONFIG_VITESSE_PHY)+= vitesse.o</span><br><span class="line"> obj-$(CONFIG_XILINX_GMII2RGMII) += xilinx_gmii2rgmii.o</span><br><span class="line">+</span><br><span class="line">+CFLAGS_phylink.o = -O1</span><br><span class="line">diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h</span><br><span class="line">index 472843eed..06d6edcdf 100644</span><br><span class="line">--- a/include/net/sch_generic.h</span><br><span class="line">+++ b/include/net/sch_generic.h</span><br><span class="line">@@ -512,7 +512,7 @@ static inline bool lockdep_tcf_proto_is_locked(struct tcf_proto *tp)</span><br><span class="line"></span><br><span class="line"> static inline void qdisc_cb_private_validate(const struct sk_buff *skb, int sz)</span><br><span class="line"> &#123;</span><br><span class="line">-struct qdisc_skb_cb *qcb;</span><br><span class="line">+struct qdisc_skb_cb *qcb __attribute__((unused));</span><br><span class="line"></span><br><span class="line"> BUILD_BUG_ON(sizeof(skb-&gt;cb) &lt; sizeof(*qcb));</span><br><span class="line"> BUILD_BUG_ON(sizeof(qcb-&gt;data) &lt; sz);</span><br><span class="line">diff --git a/init/Makefile b/init/Makefile</span><br><span class="line">index 06326e304..9a0b7f269 100644</span><br><span class="line">--- a/init/Makefile</span><br><span class="line">+++ b/init/Makefile</span><br><span class="line">@@ -35,3 +35,5 @@ quiet_cmd_compile.h = CHK     $@</span><br><span class="line"></span><br><span class="line"> include/generated/compile.h: FORCE</span><br><span class="line"> $(call cmd,compile.h)</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O0</span><br><span class="line">diff --git a/kernel/Makefile b/kernel/Makefile</span><br><span class="line">index a18d16973..aeaa9d6d8 100644</span><br><span class="line">--- a/kernel/Makefile</span><br><span class="line">+++ b/kernel/Makefile</span><br><span class="line">@@ -160,3 +160,5 @@ $(obj)/kheaders_data.tar.xz: FORCE</span><br><span class="line"> $(call cmd,genikh)</span><br><span class="line"></span><br><span class="line"> clean-files := kheaders_data.tar.xz kheaders.md5</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O0</span><br><span class="line">diff --git a/kernel/bpf/Makefile b/kernel/bpf/Makefile</span><br><span class="line">index c1a9be6a4..d4713f4e3 100644</span><br><span class="line">--- a/kernel/bpf/Makefile</span><br><span class="line">+++ b/kernel/bpf/Makefile</span><br><span class="line">@@ -40,3 +40,5 @@ obj-$(CONFIG_BPF_PRELOAD) += preload/</span><br><span class="line"> obj-$(CONFIG_BPF_SYSCALL) += relo_core.o</span><br><span class="line"> $(obj)/relo_core.o: $(srctree)/tools/lib/bpf/relo_core.c FORCE</span><br><span class="line"> $(call if_changed_rule,cc_o_c)</span><br><span class="line">+</span><br><span class="line">+CFLAGS_core.o = -O1</span><br><span class="line">diff --git a/kernel/dma/Makefile b/kernel/dma/Makefile</span><br><span class="line">index 0dd65ec1d..a09453711 100644</span><br><span class="line">--- a/kernel/dma/Makefile</span><br><span class="line">+++ b/kernel/dma/Makefile</span><br><span class="line">@@ -10,3 +10,5 @@ obj-$(CONFIG_SWIOTLB)+= swiotlb.o</span><br><span class="line"> obj-$(CONFIG_DMA_COHERENT_POOL)+= pool.o</span><br><span class="line"> obj-$(CONFIG_DMA_REMAP)+= remap.o</span><br><span class="line"> obj-$(CONFIG_DMA_MAP_BENCHMARK)+= map_benchmark.o</span><br><span class="line">+</span><br><span class="line">+CFLAGS_direct.o = -O1</span><br><span class="line">diff --git a/lib/Makefile b/lib/Makefile</span><br><span class="line">index 300f569c6..98aa9a698 100644</span><br><span class="line">--- a/lib/Makefile</span><br><span class="line">+++ b/lib/Makefile</span><br><span class="line">@@ -398,3 +398,5 @@ $(obj)/$(TEST_FORTIFY_LOG): $(addprefix $(obj)/, $(TEST_FORTIFY_LOGS)) FORCE</span><br><span class="line"> ifeq ($(CONFIG_FORTIFY_SOURCE),y)</span><br><span class="line"> $(obj)/string.o: $(obj)/$(TEST_FORTIFY_LOG)</span><br><span class="line"> endif</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O0</span><br><span class="line">diff --git a/lib/zstd/Makefile b/lib/zstd/Makefile</span><br><span class="line">index fc45339fc..96cb0ce27 100644</span><br><span class="line">--- a/lib/zstd/Makefile</span><br><span class="line">+++ b/lib/zstd/Makefile</span><br><span class="line">@@ -42,3 +42,5 @@ zstd_decompress-y := \</span><br><span class="line"> decompress/zstd_ddict.o \</span><br><span class="line"> decompress/zstd_decompress.o \</span><br><span class="line"> decompress/zstd_decompress_block.o \</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O1</span><br><span class="line">diff --git a/mm/Makefile b/mm/Makefile</span><br><span class="line">index 70d4309c9..c225b254c 100644</span><br><span class="line">--- a/mm/Makefile</span><br><span class="line">+++ b/mm/Makefile</span><br><span class="line">@@ -132,3 +132,12 @@ obj-$(CONFIG_PAGE_REPORTING) += page_reporting.o</span><br><span class="line"> obj-$(CONFIG_IO_MAPPING) += io-mapping.o</span><br><span class="line"> obj-$(CONFIG_HAVE_BOOTMEM_INFO_NODE) += bootmem_info.o</span><br><span class="line"> obj-$(CONFIG_GENERIC_IOREMAP) += ioremap.o</span><br><span class="line">+</span><br><span class="line">+subdir-ccflags-y = -O0</span><br><span class="line">+CFLAGS_truncate.o = -O1</span><br><span class="line">+CFLAGS_gup.o = -O1</span><br><span class="line">+CFLAGS_memory.o = -O1</span><br><span class="line">+CFLAGS_pagewalk.o = -O1</span><br><span class="line">+CFLAGS_page_io.o = -O1</span><br><span class="line">+CFLAGS_vmalloc.o = -O1</span><br><span class="line">+CFLAGS_swapfile.o = -O1</span><br></pre></td></tr></table></figure></li><li><p>将vscode的launch按如下方式进行配置</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"linux"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/vmlinux"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [],</span><br><span class="line">            <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">            <span class="attr">"environment"</span>: [],</span><br><span class="line">            <span class="attr">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="attr">"miDebuggerPath"</span>: <span class="string">"/home/gngshn/.local/opt/aarch64-buildroot-linux-gnu/bin/aarch64-linux-gdb"</span>,</span><br><span class="line">            <span class="attr">"targetArchitecture"</span>: <span class="string">"arm64"</span>,</span><br><span class="line">            <span class="attr">"customLaunchSetupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"text"</span>: <span class="string">"add-symbol-file vmlinux"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"text"</span>: <span class="string">"add-symbol-file vmlinux -o -0xffff7fffc7e00000"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"text"</span>: <span class="string">"b _text"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"text"</span>: <span class="string">"target remote :1234"</span></span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用qemu打开linux</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 -M virt -cpu cortex-a53 -smp 4 -m 4G -nographic -append &quot;console=ttyAMA0&quot; -kernel arch/arm64/boot/Image -initrd ../rootfs.cpio.uboot -S -s</span><br></pre></td></tr></table></figure></li><li><p>直接再vscode中按F5开始调试即可</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vscode调试kernel的汇编部分有两个麻烦点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;linux加载地址和链接地址不同&lt;/li&gt;
&lt;li&gt;vscode的默认setupCommands无法正常使用
    
    </summary>
    
    
      <category term="linux" scheme="http://gngshn.github.io/tags/linux/"/>
    
      <category term="vscode" scheme="http://gngshn.github.io/tags/vscode/"/>
    
      <category term="gdb" scheme="http://gngshn.github.io/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>利用numpy的矩阵运算实现自定义转换矩阵的YCbCr2RGB工具</title>
    <link href="http://gngshn.github.io/2018/01/19/%E5%88%A9%E7%94%A8numpy%E7%9A%84%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E6%8D%A2%E7%9F%A9%E9%98%B5%E7%9A%84YCbCr2RGB%E5%B7%A5%E5%85%B7/"/>
    <id>http://gngshn.github.io/2018/01/19/利用numpy的矩阵运算实现自定义转换矩阵的YCbCr2RGB工具/</id>
    <published>2018-01-19T03:04:12.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>OpenCV自带的cvtColor色彩空间转换矩阵的转换矩阵好像不太好替换, 目前我没有找到合适的方法来搞定.  最后自己研究了一下, 利用numpy的矩阵运算可以和cvtColor一样快的把YCbCr图片转换成RGB图片.</p><p>这里使用了numpy的多维array的dot乘法. 在numpy的document中, 写明了多维array的计算方式:<br><a id="more"></a></p><blockquote><p><code>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</code></p></blockquote><p>首先, 我们需要把NV12/NV16的YCbCr数据转换成YCbCr444模式.</p><p>之后, 目标是把YCbCr的三个通道换算成RGB通道, 也就是说通过一个3x3的矩阵左乘一个[Y, Cb, Cr].T, 就变成了[R, G, B].T了. 由于我们使用的YCbCr是基于BT709的FULL SWING的版本, 也就是说Y, Cb, Cr都是0-255范围的.  因此为了计算的正确性, 先把0~255的整数除以256换成浮点, 然后把Cb, Cr都减去0.5变成-0.5~0.5的范围.  然后做矩阵运算, 就可以算出0~1范围的RGB值了.</p><p>考虑YCbCr三个通道是<code>[height x width x 3]</code>, 为了能让YCbCr能被[3 x 3]的矩阵左乘, 需要换一下通道的顺序, 变成<code>[height x 3 x height]</code>, 通过numpy.swapaxis可以实现, 根据前面的dot乘法公式可以知道</p><blockquote><p><code>[3 x 3] dot [height x 3 x width] --&gt; [3 x height x width]</code></p></blockquote><p>因此算出的RGB通道同样需要切换一下顺序. 最后把计算好的RGB进行一下范围的限制, 防止溢出就可以了, 最终的程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> scipy.misc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowYuv</span>:</span></span><br><span class="line">    _bt709_mat = np.linalg.inv(np.array([[<span class="number">0.213</span>, <span class="number">0.715</span>, <span class="number">0.072</span>],</span><br><span class="line">                                         [<span class="number">-0.115</span>, <span class="number">-0.385</span>, <span class="number">0.500</span>],</span><br><span class="line">                                         [<span class="number">0.500</span>, <span class="number">-0.454</span>, <span class="number">-0.046</span>]]))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_show_rgb</span><span class="params">(rgb)</span>:</span></span><br><span class="line">        plt.imshow(rgb)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_save_rgb</span><span class="params">(rgb, filename)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> filename <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">f'saving <span class="subst">&#123;filename&#125;</span>...'</span>)</span><br><span class="line">            scipy.misc.imsave(filename, rgb)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_process_yuv444</span><span class="params">(yuv444, filename, bmp)</span>:</span></span><br><span class="line">        rgb = ShowYuv._yuv2rgb(yuv444)</span><br><span class="line">        ShowYuv._show_rgb(rgb)</span><br><span class="line">        <span class="keyword">if</span> bmp:</span><br><span class="line">            ShowYuv._save_rgb(rgb, os.path.splitext(filename)[<span class="number">0</span>] + <span class="string">'.bmp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_yuv2rgb</span><span class="params">(yuv444)</span>:</span></span><br><span class="line">        yuv444 = yuv444 / <span class="number">256</span></span><br><span class="line">        yuv444[:, :, <span class="number">1</span>:] -= <span class="number">0.5</span></span><br><span class="line">        yuv444 = np.transpose(yuv444, (<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">        rgb = np.dot(ShowYuv._bt709_mat, yuv444)</span><br><span class="line">        rgb = np.transpose(rgb, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line">        rgb = np.around(rgb * <span class="number">256</span>)</span><br><span class="line">        rgb = np.clip(rgb, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">        <span class="keyword">return</span> rgb</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">yuv422sp</span><span class="params">(filename, width, height, bmp=<span class="number">0</span>)</span>:</span></span><br><span class="line">        yuv422 = np.fromfile(filename, dtype=np.uint8)</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> * width * height != yuv422.shape[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'width or height error'</span>)</span><br><span class="line">        yuv444 = np.empty([height, width, <span class="number">3</span>], dtype=np.uint8)</span><br><span class="line">        yuv444[:, :, <span class="number">0</span>] = yuv422[:width * height].reshape(height, width)</span><br><span class="line">        u = yuv422[width * height::<span class="number">2</span>].reshape(height, width // <span class="number">2</span>)</span><br><span class="line">        yuv444[:, :, <span class="number">1</span>] = scipy.misc.imresize(u, (height, width))</span><br><span class="line">        v = yuv422[width * height + <span class="number">1</span>::<span class="number">2</span>].reshape(height, width // <span class="number">2</span>)</span><br><span class="line">        yuv444[:, :, <span class="number">2</span>] = scipy.misc.imresize(v, (height, width))</span><br><span class="line">        ShowYuv._process_yuv444(yuv444, filename, bmp)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">yuv420sp</span><span class="params">(filename, width, height, bmp=<span class="number">0</span>)</span>:</span></span><br><span class="line">        yuv420 = np.fromfile(filename, dtype=np.uint8)</span><br><span class="line">        <span class="keyword">if</span> <span class="number">3</span> * width * height // <span class="number">2</span> != yuv420.shape[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'width or height error'</span>)</span><br><span class="line">        yuv444 = np.empty([height, width, <span class="number">3</span>], dtype=np.uint8)</span><br><span class="line">        yuv444[:, :, <span class="number">0</span>] = yuv420[:width * height].reshape(height, width)</span><br><span class="line">        u = yuv420[width * height::<span class="number">2</span>].reshape(height // <span class="number">2</span>, width // <span class="number">2</span>)</span><br><span class="line">        yuv444[:, :, <span class="number">1</span>] = scipy.misc.imresize(u, (height, width))</span><br><span class="line">        v = yuv420[width * height + <span class="number">1</span>::<span class="number">2</span>].reshape(height // <span class="number">2</span>, width // <span class="number">2</span>)</span><br><span class="line">        yuv444[:, :, <span class="number">2</span>] = scipy.misc.imresize(v, (height, width))</span><br><span class="line">        ShowYuv._process_yuv444(yuv444, filename, bmp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fire.Fire(ShowYuv)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OpenCV自带的cvtColor色彩空间转换矩阵的转换矩阵好像不太好替换, 目前我没有找到合适的方法来搞定.  最后自己研究了一下, 利用numpy的矩阵运算可以和cvtColor一样快的把YCbCr图片转换成RGB图片.&lt;/p&gt;
&lt;p&gt;这里使用了numpy的多维array的dot乘法. 在numpy的document中, 写明了多维array的计算方式:&lt;br&gt;
    
    </summary>
    
      <category term="image" scheme="http://gngshn.github.io/categories/image/"/>
    
    
      <category term="python" scheme="http://gngshn.github.io/tags/python/"/>
    
      <category term="numpy" scheme="http://gngshn.github.io/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>arm64_linux启动流程分析08_正式跳入内核空间虚拟地址段运行</title>
    <link href="http://gngshn.github.io/2017/11/30/arm64-linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%9008-%E6%AD%A3%E5%BC%8F%E8%B7%B3%E5%85%A5%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E6%AE%B5%E8%BF%90%E8%A1%8C/"/>
    <id>http://gngshn.github.io/2017/11/30/arm64-linux启动流程分析08-正式跳入内核空间虚拟地址段运行/</id>
    <published>2017-11-30T04:00:54.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>相信一些细心的读者有注意到, 到目前位置, 内核仍然在低地址段运行, 虽然我们已经启动了MMU, 但是仍然运行在等于物理地址的虚拟地址上, 下面我们就要正式的切换到内核态的高地址空间来运行.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">blrx8</span><br></pre></td></tr></table></figure><a id="more"></a><p>这段code是上篇遗留的一点内容, 现在来进行分析. 第一条指令是arm的伪指令, 将<code>__primary_switched</code>标签的链接地址放在x8中, 第二条将<code>__PHYS_OFFSET</code>对应的运行时地址存在在x0中, <code>__PHYS_OFFSET</code>虽然名字有PHYS, 但是实际他是指<code>_text - TEXT_OFFSET</code>的链接地址. 它等于0xffff_0000_0000_0000 + 128M(module) + kaslr, 那现在x0存放的应该就是 DDR起始地址 + 2M align预留内存 + kaslr, 然后跳转到x8执行</p><p>这里有一点需要注意, 第一条指令加载的是链接地址, 我们现在放置的位置和链接地址是有kaslr的偏移的, 他是如何跳对的呢?</p><p>第一条指令实际上变汇编成一条指令加一个内存池, 如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldr x8 __priary_switched_addr</span><br><span class="line">__priary_switched_addr:</span><br><span class="line"><span class="number">0xffff</span>_xxxx_xxxx_xxxx(也就是__primary_switched的链接地址)</span><br></pre></td></tr></table></figure><p>这个内存池实际上就会导致上一篇内容讲的<code>.rela</code>段增加3条内容. 因此在上篇的relocate运行时, 这个地址就已经被修正了. 自然就能跳转到正确的位置了.</p><p>来看看<code>__primary_switched</code>的内容(特别注意, 从跳转发生开始, 内核就开始运行到高的虚拟地址上了):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">__primary_switched:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 把current SP指到`init_thread_union`的最高位置(ARM64和thread_info和</span></span><br><span class="line"><span class="comment"> * stack不共用, thread_info放在task_strcut里面, init_thread_union只是用</span></span><br><span class="line"><span class="comment"> * 于内核堆栈)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">adrpx4, init_thread_union</span><br><span class="line">addsp, x4, #THREAD_SIZE</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 把EL0的sp放在init_task下面, 原因不明, 暂时放着, 目前看起来kernel好像</span></span><br><span class="line"><span class="comment"> * 有把sp_el0设定在task_struct下面, 这样current实现起来会很容易直接把</span></span><br><span class="line"><span class="comment"> * sp_el0类型转换一下就能返回进程的task_struct, 另外把thread_info也放在</span></span><br><span class="line"><span class="comment"> * task_struct的第一个元素, 这个current_thread_info()也就是将current直接</span></span><br><span class="line"><span class="comment"> * 强制类型转换一下就OK.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">adr_lx5, init_task</span><br><span class="line">msrsp_el0, x5<span class="comment">// Save thread_info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化内核的异常向量表, 关于向量表的泪容后续还会在分析 */</span></span><br><span class="line">adr_lx8, vectors<span class="comment">// load VBAR_EL1 with virtual</span></span><br><span class="line">msrvbar_el1, x8<span class="comment">// vector table address</span></span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这一段code就是满足AARCH64 PCS(AArch64 Procedure Call Standard)来写的,</span></span><br><span class="line"><span class="comment"> * PCS规定x29是FP寄存器, x30是lr寄存器, 在函数被调用时, 首先将fp和lr压</span></span><br><span class="line"><span class="comment"> * 栈, 然后将sp保存在fp寄存器中. 这里就是完成了这样一个过程, 从而如果调</span></span><br><span class="line"><span class="comment"> * 用了C code(kaslr就可能会调用设备树相关的C code), C code返回时, 能正确</span></span><br><span class="line"><span class="comment"> * 的恢复sp, 从而我们也还能正常的返回到前面的`__primary_switch`函数中去,</span></span><br><span class="line"><span class="comment"> * 由于这里fp没有的, 因此用xzr代替了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stpxzr, x30, [sp, #<span class="number">-16</span>]!</span><br><span class="line">movx29, sp</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把设备树的物理地址存到`__fdt_pointer`中. */</span></span><br><span class="line">str_lx21, __fdt_pointer, x5<span class="comment">// Save FDT pointer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kimage_vaddr就是`.quad_text - TEXT_OFFSET`, 这个值已经</span></span><br><span class="line"><span class="comment"> * 被relocate修正了kaslr, 所以就是内核目前起始虚拟地址-TEXT_OFFSET,</span></span><br><span class="line"><span class="comment"> * 也就是0xffff_0000_0000_0000 + 128M(module) + kaslr,</span></span><br><span class="line"><span class="comment"> * 减掉x0之后就是内核虚拟地址和当前所在的物理地址的offset, 将其存放在</span></span><br><span class="line"><span class="comment"> * kimage_voffset中.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ldr_lx4, kimage_vaddr<span class="comment">// Save the offset between</span></span><br><span class="line">subx4, x4, x0<span class="comment">// the kernel virtual and</span></span><br><span class="line">str_lx4, kimage_voffset, x5<span class="comment">// physical mappings</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear BSS</span></span><br><span class="line">adr_lx0, __bss_start</span><br><span class="line">movx1, xzr</span><br><span class="line">adr_lx2, __bss_stop</span><br><span class="line">subx2, x2, x0</span><br><span class="line"><span class="comment">/* 这里的`__pi_memset`定义在哪里还没搞清楚 */</span></span><br><span class="line">bl__pi_memset</span><br><span class="line">dsbishst<span class="comment">// Make zero page visible to PTW</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line"><span class="comment">/* KASAN是一个中调试技术, 用来标记内存, 没细致研究 */</span></span><br><span class="line">blkasan_early_init</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RANDOMIZE_BASE</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在第4篇文章中, 我们说到x23保存的是KASLR区域的大小. 如果这里判断如果</span></span><br><span class="line"><span class="comment"> * x23为0, 那么表示内核没有被放在一个随机地址, 也就是前面说的第二种kaslr</span></span><br><span class="line"><span class="comment"> * 启动方式没有被 使用, 那么将调用C code `kaslr_early_init`来获取</span></span><br><span class="line"><span class="comment"> * `kaslr-seed`并搬运内核之后返回`__primary_switch`继续执行 关闭MMU</span></span><br><span class="line"><span class="comment"> * relocate 开启MMU, 再调过来的过程, 就不细说了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">tstx23, ~(MIN_KIMG_ALIGN - <span class="number">1</span>)<span class="comment">// already running randomized?</span></span><br><span class="line">b.ne<span class="number">0f</span></span><br><span class="line">movx0, x21<span class="comment">// pass FDT address in x0</span></span><br><span class="line">blkaslr_early_init<span class="comment">// parse FDT for KASLR options</span></span><br><span class="line">cbzx0, <span class="number">0f</span><span class="comment">// KASLR disabled? just proceed</span></span><br><span class="line">orrx23, x23, x0<span class="comment">// record KASLR offset</span></span><br><span class="line">ldpx29, x30, [sp], #<span class="number">16</span><span class="comment">// we must enable KASLR, return</span></span><br><span class="line">ret<span class="comment">// to __primary_switch()</span></span><br><span class="line"><span class="number">0</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里对sp出栈(增加sp)的上面的出栈只有一个会运行, 要么出栈返回, 要么在</span></span><br><span class="line"><span class="comment"> * 这里假装出栈, 最后调用`start_kernel`, 由于此处`start_kernel`不会返回,</span></span><br><span class="line"><span class="comment"> * 我们也无须返回, 所以可以把lr和fp的内容直接抹掉了.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addsp, sp, #<span class="number">16</span></span><br><span class="line">movx29, #<span class="number">0</span></span><br><span class="line">movx30, #<span class="number">0</span></span><br><span class="line"><span class="comment">/* 欢快的进入`start_kernel` C code取执行KERNEL初始化了. */</span></span><br><span class="line">bstart_kernel</span><br><span class="line">ENDPROC(__primary_switched)</span><br></pre></td></tr></table></figure><p>以上就是arm64 linux启动过程的汇编部分的分析.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信一些细心的读者有注意到, 到目前位置, 内核仍然在低地址段运行, 虽然我们已经启动了MMU, 但是仍然运行在等于物理地址的虚拟地址上, 下面我们就要正式的切换到内核态的高地址空间来运行.&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ldr	x8, =__primary_switched&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;adrp	x0, __PHYS_OFFSET&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;blr	x8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="linux" scheme="http://gngshn.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://gngshn.github.io/tags/linux/"/>
    
      <category term="arm64" scheme="http://gngshn.github.io/tags/arm64/"/>
    
  </entry>
  
  <entry>
    <title>arm64_linux启动流程分析07_开启MMU切换到虚拟地址</title>
    <link href="http://gngshn.github.io/2017/11/30/arm64-linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%9007-%E5%BC%80%E5%90%AFMMU%E5%88%87%E6%8D%A2%E5%88%B0%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/"/>
    <id>http://gngshn.github.io/2017/11/30/arm64-linux启动流程分析07-开启MMU切换到虚拟地址/</id>
    <published>2017-11-30T04:00:44.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>这篇内容我们来讲述<code>__primary_switch</code></p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">__primary_switch:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RANDOMIZE_BASE</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存x0(开启MMU时需要写入sctlr_el1的值, 保存sctlr_el1的当前值</span></span><br><span class="line"><span class="comment"> * 这两条汇编的作用是为了在开启MMU, 内核发现运行地址和链接地址是一致的时候再次关闭</span></span><br><span class="line"><span class="comment"> * MMU, 然后通过获取设备树的`kaslr-seed`来将内核移动到一个随机地址运行, 当然如果</span></span><br><span class="line"><span class="comment"> * 设备树没有`kaslr-seed`或者command line指定了`nokaslr`则就不启动kaslr(也就</span></span><br><span class="line"><span class="comment"> * 不用返回重启MMU, 重新建立页表了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">movx19, x0<span class="comment">// preserve new SCTLR_EL1 value</span></span><br><span class="line">mrsx20, sctlr_el1<span class="comment">// preserve old SCTLR_EL1 value</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 开启MMU */</span></span><br><span class="line">bl__enable_mmu</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RELOCATABLE</span></span><br><span class="line"><span class="comment">/* 如果因为kaslr的关系, 目前内核的运行地址和链接地址是不同的, 前面的code能正常运行</span></span><br><span class="line"><span class="comment"> * 是因为所有的指令和数据都是PIC(代码位置无关)的, 后面的code是不能保证的, 所以需要</span></span><br><span class="line"><span class="comment"> * 用内核的`.rela`段来修复这个问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">bl__relocate_kernel</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RANDOMIZE_BASE</span></span><br><span class="line"><span class="comment">/* 在这里准备swapper的初始化环境, 后面正式跳入C code进行内核初始化, 这个下篇再说 */</span></span><br><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">blrx8</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we return here, we have a KASLR displacement in x23 which we need</span></span><br><span class="line"><span class="comment"> * to take into account by discarding the current kernel mapping and</span></span><br><span class="line"><span class="comment"> * creating a new one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果返回到这里表示使用设备树的`kaslr-seed`来启动kaslr, 这里内核已经被重新copy</span></span><br><span class="line"><span class="comment"> * 到(0xffff_0000_0000_0000 + 128M(module) + kaslr-seed + TEXT_OFFSET的</span></span><br><span class="line"><span class="comment"> * 位置, 因此内核的页表, 符号都需要重新进行设定. 所以下面的code关闭MMU, 重建页表,</span></span><br><span class="line"><span class="comment"> * 修复内核符号, 再次跳入__primary_switched</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">msrsctlr_el1, x20<span class="comment">// disable the MMU</span></span><br><span class="line">isb</span><br><span class="line">bl__create_page_tables<span class="comment">// recreate kernel mapping</span></span><br><span class="line"></span><br><span class="line">tlbivmalle1<span class="comment">// Remove any stale TLB entries</span></span><br><span class="line">dsbnsh</span><br><span class="line"></span><br><span class="line">msrsctlr_el1, x19<span class="comment">// re-enable the MMU</span></span><br><span class="line">isb</span><br><span class="line">iciallu<span class="comment">// flush instructions fetched</span></span><br><span class="line">dsbnsh<span class="comment">// via old mapping</span></span><br><span class="line">isb</span><br><span class="line"></span><br><span class="line">bl__relocate_kernel</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">ldrx8, =__primary_switched</span><br><span class="line">adrpx0, __PHYS_OFFSET</span><br><span class="line">brx8</span><br><span class="line">ENDPROC(__primary_switch)</span><br></pre></td></tr></table></figure><p>通过上面的注释, 我们可以大致了解到code的行为和, 我们我们来关注一下行为的细节.</p><p>首先是<code>__enable_mmu</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(__enable_mmu)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 下面4条代码判断硬件是否实际支持4K页表映射, 如果不支持, 就跳入</span></span><br><span class="line"><span class="comment"> * `__no_granule_support`, 表明启动失败, CPU调用wfe, wfi进入idle状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mrsx1, ID_AA64MMFR0_EL1</span><br><span class="line">ubfxx2, x1, #ID_AA64MMFR0_TGRAN_SHIFT, <span class="number">4</span></span><br><span class="line">cmpx2, #ID_AA64MMFR0_TGRAN_SUPPORTED</span><br><span class="line">b.ne__no_granule_support</span><br><span class="line"><span class="comment">/* 在`__early_cpu_boot_status`存入0表明CPU状态正常 */</span></span><br><span class="line">update_early_cpu_boot_status <span class="number">0</span>, x1, x2</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设定TTBR0, TTBR1, TTBR0用于虚拟地址MSB都为0时(在这里对应与物理地址相</span></span><br><span class="line"><span class="comment"> * 等的虚拟地址)的页表映射, TTBR1用于虚拟地址MSB都为1时(在这里对应与物理地</span></span><br><span class="line"><span class="comment"> * 址相等的虚拟地址)的页表映射. 在正常状态下TTBR0用于用户空间页表映射,</span></span><br><span class="line"><span class="comment"> * TTBR1用于内核空间页表映射, 分成两个可以在切换进程时, 内核页表不用做切换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">adrpx1, idmap_pg_dir</span><br><span class="line">adrpx2, swapper_pg_dir</span><br><span class="line">msrttbr0_el1, x1<span class="comment">// load TTBR0</span></span><br><span class="line">msrttbr1_el1, x2<span class="comment">// load TTBR1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 两条isb内存屏障保证中间的指令执行的顺序, isb还需flush cpu的pipe line,</span></span><br><span class="line"><span class="comment"> * 这样CPU就会在开启MMU之后重新取指令, 可以保证去到的指令的正确性.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">isb</span><br><span class="line">msrsctlr_el1, x0</span><br><span class="line">isb</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Invalidate the local I-cache so that any instructions fetched</span></span><br><span class="line"><span class="comment"> * speculatively from the PoC are discarded, since they may have</span></span><br><span class="line"><span class="comment"> * been dynamically patched at the PoU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * iallu = invalidate + all + PoU</span></span><br><span class="line"><span class="comment"> * 清空左右的icache到PoU保证cpu core的各个模块看到的内容的一致性, dsb nsh</span></span><br><span class="line"><span class="comment"> * 保证上面的动作在CORE本地(non-sharable)完成. 最后清空CPU pipeline, 返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">iciallu</span><br><span class="line">dsbnsh</span><br><span class="line">isb</span><br><span class="line">ret</span><br><span class="line">ENDPROC(__enable_mmu)</span><br></pre></td></tr></table></figure><p>然后是<code>___relocate_kernel</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">__relocate_kernel:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Iterate over each entry in the relocation table, and apply the</span></span><br><span class="line"><span class="comment"> * relocations in place.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ldrw9, =__rela_offset<span class="comment">// offset to reloc table</span></span><br><span class="line">ldrw10, =__rela_size<span class="comment">// size of reloc table</span></span><br><span class="line"></span><br><span class="line">mov_qx11, KIMAGE_VADDR<span class="comment">// default virtual offset</span></span><br><span class="line">addx11, x11, x23<span class="comment">// actual virtual offset</span></span><br><span class="line">addx9, x9, x11<span class="comment">// __va(.rela)</span></span><br><span class="line">addx10, x9, x10<span class="comment">// __va(.rela) + sizeof(.rela)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:cmpx9, x10</span><br><span class="line">b.hs<span class="number">1f</span></span><br><span class="line">ldpx11, x12, [x9], #<span class="number">24</span></span><br><span class="line">ldrx13, [x9, #<span class="number">-8</span>]</span><br><span class="line">cmpw12, #R_AARCH64_RELATIVE</span><br><span class="line">b.ne<span class="number">0b</span></span><br><span class="line">addx13, x13, x23<span class="comment">// relocate</span></span><br><span class="line">strx13, [x11, x23]</span><br><span class="line">b<span class="number">0b</span></span><br><span class="line"><span class="number">1</span>:ret</span><br><span class="line">ENDPROC(__relocate_kernel)</span><br></pre></td></tr></table></figure><p><code>__rela_offset</code>定义在链接文件中, 如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.rela : ALIGN(<span class="number">8</span>) &#123;</span><br><span class="line">*(.rela .rela*)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__rela_offset= ABSOLUTE(ADDR(.rela) - KIMAGE_VADDR);</span><br><span class="line">__rela_size= SIZEOF(.rela);</span><br></pre></td></tr></table></figure><p>可以看出<code>__rela_offset</code>是<code>.rela</code>段相对KERNEL起始地址的偏移. <code>__rela_size</code>是<code>.rela</code>段的偏移.<br>通过对汇编代码的阅读, 我们大致可以看出<code>.rela</code>段的内容如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|     <span class="number">64</span> bit     |      <span class="number">64</span> bit     |      <span class="number">64</span> bit     |     ...</span><br><span class="line">+----------------+-----------------------------------+-----------------</span><br><span class="line">| sym0 link addr | sym0 reloc flag | sym0 link value | sym1 link ...</span><br><span class="line">+----------------+-----------------------------------+-----------------</span><br></pre></td></tr></table></figure><p>每个relocable symbol有三个entry, 每个entry都是32bit, 分别为link addr, relocation flag, link value. 对于需要重定位内核运行位置的情况, 我们需要把所有FLAG为R_AARCH64_RELATIVE的的entry指定的symbol进行修正, 修正方法为将link addr + offset的值修改为link value + offset. 其实这个段的含义就是说在IMAGE中, link addr的位置中存放的值是地址相关地值, 如果IMAGE发生了整体偏移, 那么link addr的位置实际在link addr + offset, 要把实际位置上的value修正, 这样说不知道是不是更清晰一些.</p><p>具体请参阅<a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=8&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjimoD4pOXXAhVGnJQKHZLkAGEQFghZMAc&amp;url=http%3A%2F%2Finfocenter.arm.com%2Fhelp%2Ftopic%2Fcom.arm.doc.ihi0056b%2FIHI0056B_aaelf64.pdf&amp;usg=AOvVaw3BbJ_w77JynYnsJJQ767_d" target="_blank" rel="noopener">ELF for the ARM 64-bit Architecture (AArch64)</a>, 我也没有细致研究.</p><p><code>__primary_switched</code>相关的内容我们放到下一篇内容中, 每一篇内容都少点, 好理解一些.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇内容我们来讲述&lt;code&gt;__primary_switch&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://gngshn.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://gngshn.github.io/tags/linux/"/>
    
      <category term="arm64" scheme="http://gngshn.github.io/tags/arm64/"/>
    
  </entry>
  
  <entry>
    <title>arm64_linux启动流程分析06_CPU的一些初始化</title>
    <link href="http://gngshn.github.io/2017/11/30/arm64-linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%9006-CPU%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://gngshn.github.io/2017/11/30/arm64-linux启动流程分析06-CPU的一些初始化/</id>
    <published>2017-11-30T04:00:36.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>接下来进入<code>__cpu_setup</code>函数</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(__cpu_setup)</span><br><span class="line"><span class="comment">/* 清空当前CORE所有的tlb, vm + all + el1, 这条指令需要对non-sharable区域加内存屏障 */</span></span><br><span class="line">tlbivmalle1<span class="comment">// Invalidate local TLB</span></span><br><span class="line">dsbnsh</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开启CPU的FP/SIMD, debug功能, 关闭PMU等 */</span></span><br><span class="line">movx0, #<span class="number">3</span> &lt;&lt; <span class="number">20</span></span><br><span class="line">msrcpacr_el1, x0<span class="comment">// Enable FP/ASIMD</span></span><br><span class="line">movx0, #<span class="number">1</span> &lt;&lt; <span class="number">12</span><span class="comment">// Reset mdscr_el1 and disable</span></span><br><span class="line">msrmdscr_el1, x0<span class="comment">// access to the DCC from EL0</span></span><br><span class="line">isb<span class="comment">// Unmask debug exceptions now,</span></span><br><span class="line">enable_dbg<span class="comment">// since this is per-cpu</span></span><br><span class="line">reset_pmuserenr_el0 x0<span class="comment">// Disable PMU access from EL0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 上面内容我们说到了, 页表entry表明内存是普通内存, 就是结合这里的初始化来指明的,</span></span><br><span class="line"><span class="comment"> * PMD_ATTRINDX(MT_NORMAL)是4, 这其实是一个index, 指向MAIR寄存器的[4*8+7:4*8],</span></span><br><span class="line"><span class="comment"> * MAIR寄存器一共有8组, KERNEL用了6组, 每组有8bit, 每个bit都有相应的含义.</span></span><br><span class="line"><span class="comment"> * 具体参考手册, 这里就不细说了, 点到为止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Memory region attributes for LPAE:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   n = AttrIndx[2:0]</span></span><br><span class="line"><span class="comment"> *nMAIR</span></span><br><span class="line"><span class="comment"> *   DEVICE_nGnRnE00000000000</span></span><br><span class="line"><span class="comment"> *   DEVICE_nGnRE00100000100</span></span><br><span class="line"><span class="comment"> *   DEVICE_GRE01000001100</span></span><br><span class="line"><span class="comment"> *   NORMAL_NC01101000100</span></span><br><span class="line"><span class="comment"> *   NORMAL10011111111</span></span><br><span class="line"><span class="comment"> *   NORMAL_WT10110111011</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ldrx5, =MAIR(<span class="number">0x00</span>, MT_DEVICE_nGnRnE) | \</span><br><span class="line">     MAIR(<span class="number">0x04</span>, MT_DEVICE_nGnRE) | \</span><br><span class="line">     MAIR(<span class="number">0x0c</span>, MT_DEVICE_GRE) | \</span><br><span class="line">     MAIR(<span class="number">0x44</span>, MT_NORMAL_NC) | \</span><br><span class="line">     MAIR(<span class="number">0xff</span>, MT_NORMAL) | \</span><br><span class="line">     MAIR(<span class="number">0xbb</span>, MT_NORMAL_WT)</span><br><span class="line">msrmair_el1, x5</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Prepare SCTLR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 从这里开始注意x0寄存器, 保存了后面开启MMU时需要写入sctlr_el1的值 */</span></span><br><span class="line">adrx5, crval</span><br><span class="line">ldpw5, w6, [x5]</span><br><span class="line">mrsx0, sctlr_el1</span><br><span class="line">bicx0, x0, x5<span class="comment">// clear bits</span></span><br><span class="line">orrx0, x0, x6<span class="comment">// set bits</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set/prepare TCR and TTBR. We use 512GB (39-bit) address range for</span></span><br><span class="line"><span class="comment"> * both user and kernel.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ldrx10, =TCR_TxSZ(VA_BITS) | TCR_CACHE_FLAGS | TCR_SMP_FLAGS | \</span><br><span class="line">TCR_TG_FLAGS | TCR_ASID16 | TCR_TBI0</span><br><span class="line">tcr_set_idmap_t0szx10, x9</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read the PARange bits from ID_AA64MMFR0_EL1 and set the IPS bits in</span></span><br><span class="line"><span class="comment"> * TCR_EL1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mrsx9, ID_AA64MMFR0_EL1</span><br><span class="line">bfix10, x9, #<span class="number">32</span>, #<span class="number">3</span></span><br><span class="line">#ifdef CONFIG_ARM64_HW_AFDBM</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Hardware update of the Access and Dirty bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mrsx9, ID_AA64MMFR1_EL1</span><br><span class="line"><span class="keyword">and</span>x9, x9, #<span class="number">0xf</span></span><br><span class="line">cbzx9, <span class="number">2f</span></span><br><span class="line">cmpx9, #<span class="number">2</span></span><br><span class="line">b.lt<span class="number">1f</span></span><br><span class="line">orrx10, x10, #TCR_HD<span class="comment">// hardware Dirty flag update</span></span><br><span class="line"><span class="number">1</span>:orrx10, x10, #TCR_HA<span class="comment">// hardware Access flag update</span></span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">#endif<span class="comment">/* CONFIG_ARM64_HW_AFDBM */</span></span><br><span class="line">msrtcr_el1, x10</span><br><span class="line">ret<span class="comment">// return to head.S</span></span><br><span class="line">ENDPROC(__cpu_setup)</span><br></pre></td></tr></table></figure><p>这段汇编代码初始化了CPU的一些寄存器, 如tcr_el1(translation control register)配置虚拟地址的大小, PAGE大小, ASID, share属性, TAG等, 并准备了开启MMU时需要写入sctlr_el1的值.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接下来进入&lt;code&gt;__cpu_setup&lt;/code&gt;函数&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://gngshn.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://gngshn.github.io/tags/linux/"/>
    
      <category term="arm64" scheme="http://gngshn.github.io/tags/arm64/"/>
    
  </entry>
  
  <entry>
    <title>arm64_linux启动流程分析05_配置内核启动的临时页表</title>
    <link href="http://gngshn.github.io/2017/11/30/arm64-linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%9005-%E9%85%8D%E7%BD%AE%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E7%9A%84%E4%B8%B4%E6%97%B6%E9%A1%B5%E8%A1%A8/"/>
    <id>http://gngshn.github.io/2017/11/30/arm64-linux启动流程分析05-配置内核启动的临时页表/</id>
    <published>2017-11-30T04:00:28.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>这篇内容讲讲页表的配置, 为了kernel运行速度加快, 我们需要启动cache, 启动cache需要先启动MMU让CPU运行到虚拟地址上, 那么我们就需要启动一个能覆盖KERNEL内存区域的页表.</p><p>本篇内容假设在您对MMU有一定的了解的基础上来讲述的.</p><p>我们假设使用4K页来管理内存, 同时虚拟地址使用48位地址</p><a id="more"></a><p>我们将<code>__create_page_tables</code>函数分成几段来讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__create_page_tables:</span><br><span class="line">movx28, lr</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Invalidate the idmap and swapper page tables to avoid potential</span></span><br><span class="line"><span class="comment"> * dirty cache lines being evicted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">adrpx0, idmap_pg_dir</span><br><span class="line">ldrx1, =(IDMAP_DIR_SIZE + SWAPPER_DIR_SIZE + RESERVED_TTBR0_SIZE)</span><br><span class="line">bl__inval_dcache_area</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Clear the idmap and swapper page tables.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">adrpx0, idmap_pg_dir</span><br><span class="line">ldrx1, =(IDMAP_DIR_SIZE + SWAPPER_DIR_SIZE + RESERVED_TTBR0_SIZE)</span><br><span class="line"><span class="number">1</span>:stpxzr, xzr, [x0], #<span class="number">16</span></span><br><span class="line">stpxzr, xzr, [x0], #<span class="number">16</span></span><br><span class="line">stpxzr, xzr, [x0], #<span class="number">16</span></span><br><span class="line">stpxzr, xzr, [x0], #<span class="number">16</span></span><br><span class="line">subsx1, x1, #<span class="number">64</span></span><br><span class="line">b.ne<span class="number">1b</span></span><br></pre></td></tr></table></figure><p>在vmlinux.lds.S中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">. = ALIGN(PAGE_SIZE);</span><br><span class="line">idmap_pg_dir = .;</span><br><span class="line">. += IDMAP_DIR_SIZE;</span><br><span class="line">swapper_pg_dir = .;</span><br><span class="line">. += SWAPPER_DIR_SIZE;</span><br></pre></td></tr></table></figure><p>所以<code>idmap_pg_dir</code>是在bss段后面且是<code>PAGE_SIZE</code>对齐的. x0保存<code>idmap_pg_dir</code>当前所在的物理地址. x1保存<code>idmap_pg_dir</code>和<code>swapper_pg_dir</code>的大小.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPPER_DIR_SIZE(SWAPPER_PGTABLE_LEVELS * PAGE_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDMAP_DIR_SIZE(IDMAP_PGTABLE_LEVELS * PAGE_SIZE)</span></span><br></pre></td></tr></table></figure><p>通过对宏的观察, 我们了解到<code>idmap_pg_dir</code>和<code>swapper_pg_dir</code>都是3个PAGE_SIZE(12K), 我们知道使用4K页加48bit虚拟地址需要4级页表才能满足, 每级页表都是一个PAGE</p><ul><li><p>level0 [47:39] 512个entry, 每个8byte, 一共4K</p></li><li><p>level1 [38:30] 512个entry, 每个8byte, 一共4K</p></li><li><p>level2 [29:21] 512个entry, 每个8byte, 一共4K</p></li><li><p>level3 [20:13] 512个entry, 每个8byte, 一共4K</p></li></ul><p>剩下的11:0地址用level3的内容拼接得到最终的物理地址.</p><p>而这里<code>idmap_pg_dir</code>和<code>swapper_pg_dir</code>都只有3个PAGE是如何来映射的呢? 其实这里KERNEL在早期的临时页表为了节省内存, 并没有使用标准的4级映射, 而是使用的MMU中的block来直接描述2M(使用低21bit)内存区, 而不是用entry来描述4K页, 从而节省了level3的页表.</p><p>也就是说上面的level2页表中, 每条entry指向的不是level3页表, 而是一个2M的内存区.</p><p>上面的代码把这里的6个page全部清零, 因此所有的entry都成了invalid.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * x7保存level3页表的entry的flags, 表明是普通内存,</span></span><br><span class="line"><span class="comment"> * 是一个block的entry, 后面细说</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">movx7, SWAPPER_MM_MMUFLAGS</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create the identity mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">adrpx0, idmap_pg_dir</span><br><span class="line">adrpx3, __idmap_text_start<span class="comment">// __pa(__idmap_text_start)</span></span><br><span class="line"></span><br><span class="line">create_pgd_entry x0, x3, x5, x6</span><br><span class="line">movx5, x3<span class="comment">// __pa(__idmap_text_start)</span></span><br><span class="line">adr_lx6, __idmap_text_end<span class="comment">// __pa(__idmap_text_end)</span></span><br><span class="line">create_block_map x0, x7, x3, x5, x6</span><br></pre></td></tr></table></figure><p>x0保存<code>idmap_pg_dir</code>的物理地址. x3保存<code>__idmap_text_start</code>的物理地址.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. = ALIGN(SZ_4K);\</span><br><span class="line">VMLINUX_SYMBOL(__idmap_text_start) = .;\</span><br><span class="line">*(.idmap.text)\</span><br><span class="line">VMLINUX_SYMBOL(__idmap_text_end) = .;</span><br></pre></td></tr></table></figure><p>所以x3保存的是<code>.idmap.text</code>段所在的物理地址. 这个段是head.S文件的后半部分, 这部份code是CPU和MMU从关闭到开启的过程中执行的code, 说道这里你应该明白了, <code>idmap_pg_dir</code>对应的页表是用来将与KERNEL所在物理地址相等的虚拟地址映射到相同的物理地址. 从而保证开启MMU时, 不会发生无法获取页表的情况. 而<code>swapper_pg_dir</code>如其名是swapper进程运行所需的页表, 是内核初始化过程所用的页表.</p><p>另外ARM64有TTBR0, TTBR1(Translation Table Base Register)分别用来指示内核空间和用户空间页表所在的物理地址, 而在这个时候, TTBR0不是用来指示用户空间地址, 而是用来指示与物理地址相等的虚拟地址所用的页表. 所以TTBR0里面是<code>.idmap.text</code>的物理地址, TTBR1里面是<code>swapper_pg_dir</code>的物理地址.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.macrocreate_pgd_entry, tbl, virt, tmp1, tmp2</span><br><span class="line"><span class="comment">/* 这里PGDIR_SHIFT是39, PTRS_PER_PGD是512 */</span></span><br><span class="line">create_table_entry \tbl, \virt, PGDIR_SHIFT, PTRS_PER_PGD, \tmp1, \tmp2</span><br><span class="line"><span class="comment">/* 使用4K页时SWAPPER_PGTABLE_LEVELS为3 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SWAPPER_PGTABLE_LEVELS &gt; 3</span></span><br><span class="line">create_table_entry \tbl, \virt, PUD_SHIFT, PTRS_PER_PUD, \tmp1, \tmp2</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SWAPPER_PGTABLE_LEVELS &gt; 2</span></span><br><span class="line"><span class="comment">/* SWAPPER_TABLE_SHIFT是30, PTRS_PER_PTE是512 */</span></span><br><span class="line">create_table_entry \tbl, \virt, SWAPPER_TABLE_SHIFT, PTRS_PER_PTE, \tmp1, \tmp2</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p><code>create_pgd_entry</code>宏用来创建level0和和level1的页表. 虚拟地址的[47:39]在level0页表中进行索引, 索引到的entry指向level1的页表, 这里level1的页表就是level0页表的下一个PAGE. 对应的[38:30]在level1页表中进行索引, 索引的entry指向level2的页表. 也就是再下一个PAGE. 这里来分析下<code>create_table_entry</code>宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.macrocreate_table_entry, tbl, virt, shift, ptrs, tmp1, tmp2</span><br><span class="line"><span class="comment">/* 下面两条指令取出虚拟地址(virt)的[shift+9:shift], 作为index */</span></span><br><span class="line">lsr\tmp1, \virt, #\shift</span><br><span class="line"><span class="keyword">and</span>\tmp1, \tmp1, #\ptrs - <span class="number">1</span><span class="comment">// table index</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 下面两条指令计算出这一级页表对应virt的entry的值, 第一条指令计算entry指向的下一级</span></span><br><span class="line"><span class="comment"> * 页表的物理地址, 第二条指令指定当前entry是PMD_TYPE_TABLE, 也就是表示当前entry</span></span><br><span class="line"><span class="comment"> * 指向的仍然是一个页目录, 具体看arm的architecture reference manual.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">add\tmp2, \tbl, #PAGE_SIZE</span><br><span class="line">orr\tmp2, \tmp2, #PMD_TYPE_TABLE<span class="comment">// address of next table and entry type</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用之前计算的index来得到virt对应的entry的位置(tbl + index * 8byte), 然后把</span></span><br><span class="line"><span class="comment"> * 页表entry存到那个位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">str\tmp2, [\tbl, \tmp1, lsl #<span class="number">3</span>]</span><br><span class="line"><span class="comment">/* tbl指向下一级页表, 方便下一次计算 */</span></span><br><span class="line">add\tbl, \tbl, #PAGE_SIZE<span class="comment">// next level table page</span></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p>level2的页表由<code>create_block_map</code>来配置.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.macrocreate_block_map, tbl, flags, phys, start, end</span><br><span class="line"><span class="comment">/* SWAPPER_BLOCK_SHIFT是21, 把物理地址右移21bit, 剩下的就是entry中的地址 */</span></span><br><span class="line">lsr\phys, \phys, #SWAPPER_BLOCK_SHIFT</span><br><span class="line"><span class="comment">/* 这两条指令取出start的[29:21]作为level2页表的索引, 存在start中 */</span></span><br><span class="line">lsr\start, \start, #SWAPPER_BLOCK_SHIFT</span><br><span class="line"><span class="keyword">and</span>\start, \start, #PTRS_PER_PTE - <span class="number">1</span><span class="comment">// table index</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * phys = flags | (phys &lt;&lt; 21), 很明显, 就是构建一条level2页表entry,</span></span><br><span class="line"><span class="comment"> * entry将虚拟地址start(前面两条指令计算之前的值)转换成物理地址phys(计算前的值)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">orr\phys, \flags, \phys, lsl #SWAPPER_BLOCK_SHIFT<span class="comment">// table entry</span></span><br><span class="line"><span class="comment">/* 将end也计算成一个index, 方便后面的循环建立页表 */</span></span><br><span class="line">lsr\end, \end, #SWAPPER_BLOCK_SHIFT</span><br><span class="line"><span class="keyword">and</span>\end, \end, #PTRS_PER_PTE - <span class="number">1</span><span class="comment">// table end index</span></span><br><span class="line"><span class="comment">/* 将之前构建的页表entry存到level2页表对应的位置(由[29:21]索引) */</span></span><br><span class="line"><span class="number">9999</span>:str\phys, [\tbl, \start, lsl #<span class="number">3</span>]<span class="comment">// store the entry</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 索引每次加1, 页表entry的物理地址每次加2M, 这样就能计算出下一条entry的内容</span></span><br><span class="line"><span class="comment"> * 和存放路径了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">add\start, \start, #<span class="number">1</span><span class="comment">// next entry</span></span><br><span class="line">add\phys, \phys, #SWAPPER_BLOCK_SIZE<span class="comment">// next block</span></span><br><span class="line"><span class="comment">/* 循环创建参数中start到end的地址的映射 */</span></span><br><span class="line">cmp\start, \end</span><br><span class="line">b.ls<span class="number">9999b</span></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p>综合上面的注释, 这里就是按照armv8 MMU的block条目来创建从start到end虚拟地址空间的映射, 每一个条目映射2M的地址空间. 这里把前面提到的x7保存的flags细说一下.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPPER_MM_MMUFLAGS(PMD_ATTRINDX(MT_NORMAL) | SWAPPER_PMD_FLAGS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MT_NORMAL4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMD_ATTRINDX(t)(_AT(pmdval_t, (t)) &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPPER_PMD_FLAGS(PMD_TYPE_SECT | PMD_SECT_AF | PMD_SECT_S)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMD_TYPE_SECT(_AT(pmdval_t, 1) &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMD_SECT_AF(_AT(pmdval_t, 1) &lt;&lt; 10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMD_SECT_S(_AT(pmdval_t, 3) &lt;&lt; 8)</span></span><br><span class="line"><span class="keyword">typedef</span> u64 <span class="keyword">pmdval_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _AC(X,Y)X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _AT(T,X)X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __AC(X,Y)(X##Y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _AC(X,Y)__AC(X,Y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _AT(T,X)((T)(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>具体每个字段的含义可以查询arm手册来看, 大致来说, 这个flags表明, 这条entry指向的是一个2M的block, 这个block是一段普通的内存(不是device memory, 下篇内容我们还会继续说), 是已经访问过的, 是inner sharable的. 另外一些没有设定的位置为0也有一些含义, 如表示code是可执行的, 访问权限是EL0 RO, EL1 RW, 具体看arm的architecture reference manual.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">adrpx0, swapper_pg_dir</span><br><span class="line">mov_qx5, KIMAGE_VADDR + TEXT_OFFSET<span class="comment">// compile time __va(_text)</span></span><br><span class="line">addx5, x5, x23<span class="comment">// add KASLR displacement</span></span><br><span class="line">create_pgd_entry x0, x5, x3, x6</span><br><span class="line">adrpx6, _end<span class="comment">// runtime __pa(_end)</span></span><br><span class="line">adrpx3, _text<span class="comment">// runtime __pa(_text)</span></span><br><span class="line">subx6, x6, x3<span class="comment">// _end - _text</span></span><br><span class="line">addx6, x6, x5<span class="comment">// runtime __va(_end)</span></span><br><span class="line">create_block_map x0, x7, x3, x5, x6</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Since the page tables have been populated with non-cacheable</span></span><br><span class="line"><span class="comment"> * accesses (MMU disabled), invalidate the idmap and swapper page</span></span><br><span class="line"><span class="comment"> * tables again to remove any speculatively loaded cache lines.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">adrpx0, idmap_pg_dir</span><br><span class="line">ldrx1, =(IDMAP_DIR_SIZE + SWAPPER_DIR_SIZE + RESERVED_TTBR0_SIZE)</span><br><span class="line">dmbsy</span><br><span class="line">bl__inval_dcache_area</span><br><span class="line"></span><br><span class="line">retx28</span><br></pre></td></tr></table></figure><p>后面的code参照前面的分析就很好理解了, 创建swapper的页表, 然后用<code>dmb sy</code>完成同步, 最后清空缓存.</p><p>这里由一个需要注意低地方, 跟之前说的KASLR有关. <code>add    x5, x5, x23</code>在x5中保存_text的虚拟地址之后, 又加了x23, 这个x23就是之前保存的kaslr区域的大小. 也就是说把KEREL运行的虚拟地址进行了随机化.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇内容讲讲页表的配置, 为了kernel运行速度加快, 我们需要启动cache, 启动cache需要先启动MMU让CPU运行到虚拟地址上, 那么我们就需要启动一个能覆盖KERNEL内存区域的页表.&lt;/p&gt;
&lt;p&gt;本篇内容假设在您对MMU有一定的了解的基础上来讲述的.&lt;/p&gt;
&lt;p&gt;我们假设使用4K页来管理内存, 同时虚拟地址使用48位地址&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://gngshn.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://gngshn.github.io/tags/linux/"/>
    
      <category term="arm64" scheme="http://gngshn.github.io/tags/arm64/"/>
    
  </entry>
  
  <entry>
    <title>arm64_linux启动流程分析04_KASLR</title>
    <link href="http://gngshn.github.io/2017/11/30/arm64-linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%9004-KASLR/"/>
    <id>http://gngshn.github.io/2017/11/30/arm64-linux启动流程分析04-KASLR/</id>
    <published>2017-11-30T04:00:19.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>这篇内容主要是说一下KASLR</p><p>KASLR是让内核在一个随机的地址上运行的技术, 就是说内核的运行时地址是随机的, 每次启动会变化. 这样内核的符号对应的地址会变化并不是链接地址从而加强安全性. 这里画一个图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+-------+-------------+----------------------</span><br><span class="line">|               |       |             |</span><br><span class="line">| <span class="number">2</span>M align resv | KASLR | TEXT_OFFSET | KERNEL IMAGE</span><br><span class="line">|               |       |             |</span><br><span class="line">+---------------+-------+-------------+----------------------</span><br><span class="line">|                       |             |</span><br><span class="line">|                       |             +----内核在DDR中的位置.</span><br><span class="line">|                       +----------------- ARM64规定的KERNEL运行前必须放在 <span class="number">2</span>M对齐地址+TEXT_OFFSET 的地方</span><br><span class="line">|                                          这里是经过KASLR技术relocate之后的位置.</span><br><span class="line">+----------------------------------------- DDR起始地址.</span><br></pre></td></tr></table></figure><a id="more"></a><p>目前开启KASLR的内核启动有两种办法:</p><ol><li><p>bootloader在设备树中添加一个<code>kaslr-seed</code>的节点. 并赋予一个随机的偏移, 将KERNEL放在ARM64规定的2M对齐地址+TEXT_OFFSET的地方, 然后启动内核, 之后内核会将自己relocate到2M对齐地址+KASLR offset+TEXT_OFFSET的地方运行</p></li><li><p>bootloader把将KERNEL放在2M对齐地址+KASLR offset+TEXT_OFFSET的地方(KASLR offset小于2M), 然后启动内核, 之后内核会修复symbol, 然后在原地运行.</p></li></ol><p>在上一篇文章中, 我们放了一段code没说</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adrpx23, __PHYS_OFFSET</span><br><span class="line"><span class="keyword">and</span>x23, x23, MIN_KIMG_ALIGN - <span class="number">1</span><span class="comment">// KASLR offset, defaults to 0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PHYS_OFFSET(KERNEL_START - TEXT_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_START      _text</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_KIMG_ALIGNSZ_2M</span></span><br></pre></td></tr></table></figure><p>我们假设使用第二种启动办法, 那么<code>__PHYS_OFFSET</code>指向KASLR区域的最后面所在的物理地址. 第二条汇编就会计算出KASLR区域的大小然后保存在x23寄存器中. 对这个寄存器多加留意, 在调用<code>start_kernel</code>之前还会再用到.</p><p>对于KASLR的BOOT后面还需继续降到, 这里先放放, 我们先在下篇接着往下说.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇内容主要是说一下KASLR&lt;/p&gt;
&lt;p&gt;KASLR是让内核在一个随机的地址上运行的技术, 就是说内核的运行时地址是随机的, 每次启动会变化. 这样内核的符号对应的地址会变化并不是链接地址从而加强安全性. 这里画一个图&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+---------------+-------+-------------+----------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|               |       |             |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;M align resv | KASLR | TEXT_OFFSET | KERNEL IMAGE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|               |       |             |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+---------------+-------+-------------+----------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                       |             |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                       |             +----内核在DDR中的位置.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                       +----------------- ARM64规定的KERNEL运行前必须放在 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;M对齐地址+TEXT_OFFSET 的地方&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                                          这里是经过KASLR技术relocate之后的位置.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----------------------------------------- DDR起始地址.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="linux" scheme="http://gngshn.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://gngshn.github.io/tags/linux/"/>
    
      <category term="arm64" scheme="http://gngshn.github.io/tags/arm64/"/>
    
  </entry>
  
  <entry>
    <title>arm64_linux启动流程分析03_设定当前core的启动状态</title>
    <link href="http://gngshn.github.io/2017/11/30/arm64-linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%9003-%E8%AE%BE%E5%AE%9A%E5%BD%93%E5%89%8Dcore%E7%9A%84%E5%90%AF%E5%8A%A8%E7%8A%B6%E6%80%81/"/>
    <id>http://gngshn.github.io/2017/11/30/arm64-linux启动流程分析03-设定当前core的启动状态/</id>
    <published>2017-11-30T04:00:11.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>接下来看<code>el2_setup</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(el2_setup)</span><br><span class="line">msrSPsel, #<span class="number">1</span><span class="comment">// We want to use SP_EL&#123;1,2&#125;</span></span><br><span class="line">mrsx0, CurrentEL</span><br><span class="line">cmpx0, #CurrentEL_EL2</span><br><span class="line">b.eq<span class="number">1f</span></span><br><span class="line">mrsx0, sctlr_el1</span><br><span class="line">CPU_BE(orrx0, x0, #(<span class="number">3</span> &lt;&lt; <span class="number">24</span>))<span class="comment">// Set the EE and E0E bits for EL1</span></span><br><span class="line">CPU_LE(bicx0, x0, #(<span class="number">3</span> &lt;&lt; <span class="number">24</span>))<span class="comment">// Clear the EE and E0E bits for EL1</span></span><br><span class="line">msrsctlr_el1, x0</span><br><span class="line">movw0, #BOOT_CPU_MODE_EL1<span class="comment">// This cpu booted in EL1</span></span><br><span class="line">isb</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:mrsx0, sctlr_el2</span><br><span class="line">......省略......</span><br></pre></td></tr></table></figure><a id="more"></a><p>判断当前core的EL, 如果是EL1, 就设定使用little endian, <code>CPU_BE</code>和<code>CPU_LE</code>只有一条会编译进code. 之后返回<code>BOOT_CPU_MODE_EL1</code>, 如果EL2, 会初始化虚拟化相关的东西, 比较复杂, 先搁着.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adrpx23, __PHYS_OFFSET</span><br><span class="line"><span class="keyword">and</span>x23, x23, MIN_KIMG_ALIGN - <span class="number">1</span><span class="comment">// KASLR offset, defaults to 0</span></span><br></pre></td></tr></table></figure><p>这段code跟kaslr有关, 我们下篇文章来着重讲这个. 先接着往下看<code>set_cpu_boot_mode_flag</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set_cpu_boot_mode_flag:</span><br><span class="line">adr_lx1, __boot_cpu_mode</span><br><span class="line">cmpw0, #BOOT_CPU_MODE_EL2</span><br><span class="line">b.ne<span class="number">1f</span></span><br><span class="line">addx1, x1, #<span class="number">4</span></span><br><span class="line"><span class="number">1</span>:strw0, [x1]<span class="comment">// This CPU has booted in EL1</span></span><br><span class="line">dmbsy</span><br><span class="line">dcivac, x1<span class="comment">// Invalidate potentially stale cache line</span></span><br><span class="line">ret</span><br><span class="line">ENDPROC(set_cpu_boot_mode_flag)</span><br></pre></td></tr></table></figure><p>在<code>__boot_cpu_mode</code>标签下保存了两个值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(__boot_cpu_mode)</span><br><span class="line">.<span class="keyword">long</span>BOOT_CPU_MODE_EL2</span><br><span class="line">.<span class="keyword">long</span>BOOT_CPU_MODE_EL1</span><br></pre></td></tr></table></figure><p>这段code的作用就是把保存的这两个值修改为一致, 且为当前CORE的启动EL, 其他CORE启动时也会运行这段code, 这样如果后面的CORE启动到了不同的EL就又会把这两个值修改为不一致, 从而可以判断出CPU的启动状态时不对的.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接下来看&lt;code&gt;el2_setup&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ENTRY(el2_setup)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	msr	SPsel, #&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;			&lt;span class=&quot;comment&quot;&gt;// We want to use SP_EL&amp;#123;1,2&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	mrs	x0, CurrentEL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cmp	x0, #CurrentEL_EL2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	b.eq	&lt;span class=&quot;number&quot;&gt;1f&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	mrs	x0, sctlr_el1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPU_BE(	orr	x0, x0, #(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;)	)	&lt;span class=&quot;comment&quot;&gt;// Set the EE and E0E bits for EL1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPU_LE(	bic	x0, x0, #(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;)	)	&lt;span class=&quot;comment&quot;&gt;// Clear the EE and E0E bits for EL1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	msr	sctlr_el1, x0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	mov	w0, #BOOT_CPU_MODE_EL1		&lt;span class=&quot;comment&quot;&gt;// This cpu booted in EL1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	isb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:	mrs	x0, sctlr_el2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;......省略......&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="linux" scheme="http://gngshn.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://gngshn.github.io/tags/linux/"/>
    
      <category term="arm64" scheme="http://gngshn.github.io/tags/arm64/"/>
    
  </entry>
  
  <entry>
    <title>arm64_linux启动流程分析02_保存启动信息</title>
    <link href="http://gngshn.github.io/2017/11/30/arm64-linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%9002-%E4%BF%9D%E5%AD%98%E5%90%AF%E5%8A%A8%E4%BF%A1%E6%81%AF/"/>
    <id>http://gngshn.github.io/2017/11/30/arm64-linux启动流程分析02-保存启动信息/</id>
    <published>2017-11-30T04:00:01.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>解上节, 我们先来看看<code>bl    preserve_boot_args</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">preserve_boot_args:</span><br><span class="line">movx21, x0// x21=FDT</span><br><span class="line"></span><br><span class="line">adr_lx0, boot_args// record the contents of</span><br><span class="line">stpx21, x1, [x0]// x0 .. x3 at kernel entry</span><br><span class="line">stpx2, x3, [x0, #16]</span><br><span class="line"></span><br><span class="line">dmbsy// needed before dc ivac with</span><br><span class="line">// MMU off</span><br><span class="line"></span><br><span class="line">movx1, #0x20// 4 x 8 bytes</span><br><span class="line">b__inval_dcache_area// tail call</span><br><span class="line">ENDPROC(preserve_boot_args)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>代码的含义一目了然, 把存fdt内存地址的x0保存到x21寄存器. 然后把启动参数x0, x1, x2, x3全部保存到boot_args数组中.</p><p>arm64 linux规定:</p><blockquote><p> Primary CPU general-purpose register settings</p></blockquote><blockquote><p> x0 = physical address of device tree blob (dtb) in system RAM.</p></blockquote><blockquote><p> x1 = 0 (reserved for future use)</p></blockquote><blockquote><p> x2 = 0 (reserved for future use)</p></blockquote><blockquote><p> x3 = 0 (reserved for future use)</p></blockquote><p>这里值得注意的有几点</p><ol><li>这里有用到<code>adr_l</code>, arm64并没有这个指令, 这是一个宏</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.macroadr_l, dst, sym</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MODULE</span></span><br><span class="line">adrp\dst, \sym</span><br><span class="line">add\dst, \dst, :lo12:\sym</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">movz\dst, #:abs_g3:\sym</span><br><span class="line">movk\dst, #:abs_g2_nc:\sym</span><br><span class="line">movk\dst, #:abs_g1_nc:\sym</span><br><span class="line">movk\dst, #:abs_g0_nc:\sym</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p>可以看到, 这里的<code>adr_l</code>拆分成了两条指令, adrp + add, adrp指令最大寻址空间时+-4GB, 但是所寻址的地址是4KB对齐的. 所以这里在加了一个add指令来修正地址的低12bit, 从而实现了这个加载+-4GB任意位置的运行时地址的宏.</p><ol start="2"><li><code>__inval_dcache_area</code>函数用来invalidate指定区域的dcache, 具体如下</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(__inval_dcache_area)</span><br><span class="line"><span class="comment">/* FALLTHROUGH */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *__dma_inv_area(start, size)</span></span><br><span class="line"><span class="comment"> *- start   - virtual start address of region</span></span><br><span class="line"><span class="comment"> *- size    - size in question</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__dma_inv_area:</span><br><span class="line">addx1, x1, x0</span><br><span class="line">dcache_line_size x2, x3</span><br><span class="line">subx3, x2, #<span class="number">1</span></span><br><span class="line">tstx1, x3<span class="comment">// end cache line aligned?</span></span><br><span class="line">bicx1, x1, x3</span><br><span class="line">b.eq<span class="number">1f</span></span><br><span class="line">dccivac, x1<span class="comment">// clean &amp; invalidate D / U line</span></span><br><span class="line"><span class="number">1</span>:tstx0, x3<span class="comment">// start cache line aligned?</span></span><br><span class="line">bicx0, x0, x3</span><br><span class="line">b.eq<span class="number">2f</span></span><br><span class="line">dccivac, x0<span class="comment">// clean &amp; invalidate D / U line</span></span><br><span class="line">b<span class="number">3f</span></span><br><span class="line"><span class="number">2</span>:dcivac, x0<span class="comment">// invalidate D / U line</span></span><br><span class="line"><span class="number">3</span>:addx0, x0, x2</span><br><span class="line">cmpx0, x1</span><br><span class="line">b.lo<span class="number">2b</span></span><br><span class="line">dsbsy</span><br><span class="line">ret</span><br><span class="line">ENDPIPROC(__inval_dcache_area)</span><br></pre></td></tr></table></figure><p>可以看到如果指定内存区域有跨越cacheline, 那么对两边跨越了cacheline的地址使用的clean + invalidate, 对于中间区域可以直接invalidate不用写回内存, 从而加快invalidate速度.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解上节, 我们先来看看&lt;code&gt;bl    preserve_boot_args&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;preserve_boot_args:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	mov	x21, x0				// x21=FDT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	adr_l	x0, boot_args			// record the contents of&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	stp	x21, x1, [x0]			// x0 .. x3 at kernel entry&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	stp	x2, x3, [x0, #16]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dmb	sy				// needed before dc ivac with&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;						// MMU off&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	mov	x1, #0x20			// 4 x 8 bytes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	b	__inval_dcache_area		// tail call&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ENDPROC(preserve_boot_args)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://gngshn.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://gngshn.github.io/tags/linux/"/>
    
      <category term="arm64" scheme="http://gngshn.github.io/tags/arm64/"/>
    
  </entry>
  
  <entry>
    <title>arm64_linux启动流程分析01_内核的入口</title>
    <link href="http://gngshn.github.io/2017/11/30/arm64-linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%9001-%E5%86%85%E6%A0%B8%E7%9A%84%E5%85%A5%E5%8F%A3/"/>
    <id>http://gngshn.github.io/2017/11/30/arm64-linux启动流程分析01-内核的入口/</id>
    <published>2017-11-30T03:54:27.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>本次分析使用的linux内核的版本时 4.14.2, 读者可以自己下载了对照分析</p><p>首先看链接文件如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_text)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">.....省略部分无关内容....</span><br><span class="line"></span><br><span class="line">. = KIMAGE_VADDR + TEXT_OFFSET;</span><br><span class="line"></span><br><span class="line">.head.text : &#123;</span><br><span class="line">_text = .;</span><br><span class="line">HEAD_TEXT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>可以看到入口点在<code>_text</code>. 而<code>_text</code>是指向<code>.head.text</code>段的起始位置. 所以内核是从<code>.head.text</code>开始运行的. 那么这个段是写什么内容呢?</p><p><code>HEAD_TEXT</code>是一个宏<code>#define HEAD_TEXT  *(.head.text)</code></p><p>在<code>arch/arm64/kernel/head.S</code>中有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__HEAD</span><br><span class="line">_head:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DO NOT MODIFY. Image header expected by Linux boot-loaders.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EFI</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This add instruction has no meaningful effect except that</span></span><br><span class="line"><span class="comment"> * its opcode forms the magic "MZ" signature required by UEFI.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addx13, x18, #<span class="number">0x16</span></span><br><span class="line">bstext</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">bstext<span class="comment">// branch to kernel start, magic</span></span><br><span class="line">.<span class="keyword">long</span><span class="number">0</span><span class="comment">// reserved</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">...省略后面的内容...</span><br></pre></td></tr></table></figure><p>所以对应到code, 内核是从<code>_head</code>开始运行的. 这个开始点放置了一个arm64 linux的header:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">u32 code0;<span class="comment">/* Executable code */</span></span><br><span class="line">u32 code1;<span class="comment">/* Executable code */</span></span><br><span class="line">u64 text_offset;<span class="comment">/* Image load offset, little endian */</span></span><br><span class="line">u64 image_size;<span class="comment">/* Effective Image size, little endian */</span></span><br><span class="line">u64 flags;<span class="comment">/* kernel flags, little endian */</span></span><br><span class="line">u64 res2= <span class="number">0</span>;<span class="comment">/* reserved */</span></span><br><span class="line">u64 res3= <span class="number">0</span>;<span class="comment">/* reserved */</span></span><br><span class="line">u64 res4= <span class="number">0</span>;<span class="comment">/* reserved */</span></span><br><span class="line">u32 magic= <span class="number">0x644d5241</span>;<span class="comment">/* Magic number, little endian, "ARM\x64" */</span></span><br><span class="line">u32 res5;<span class="comment">/* reserved (used for PE COFF offset) */</span></span><br></pre></td></tr></table></figure><p>这个头的前两个位置放置的是可执行code</p><p>在开启UEFI支持时, <code>add    x13, x18, #0x16</code>这个code实际上是为了满足EFI格式的”MZ”头. 如果使用UEFI来启动kernel, 会识别出来并走UEFI启动的流程, 如果是普通的启动过程如使用uboot的booti进行引导, 那么第一条指令就是一条dummy指令. 第二条就跳转到<code>stext</code>运行了.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(stext)</span><br><span class="line">blpreserve_boot_args</span><br><span class="line">blel2_setup<span class="comment">// Drop to EL1, w0=cpu_boot_mode</span></span><br><span class="line">adrpx23, __PHYS_OFFSET</span><br><span class="line"><span class="keyword">and</span>x23, x23, MIN_KIMG_ALIGN - <span class="number">1</span><span class="comment">// KASLR offset, defaults to 0</span></span><br><span class="line">blset_cpu_boot_mode_flag</span><br><span class="line">bl__create_page_tables</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following calls CPU setup code, see arch/arm64/mm/proc.S for</span></span><br><span class="line"><span class="comment"> * details.</span></span><br><span class="line"><span class="comment"> * On return, the CPU will be ready for the MMU to be turned on and</span></span><br><span class="line"><span class="comment"> * the TCR will have been set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">bl__cpu_setup<span class="comment">// initialise processor</span></span><br><span class="line">b__primary_switch</span><br><span class="line">ENDPROC(stext)</span><br></pre></td></tr></table></figure><p>这段代码就是内核启动是运行的初始化代码. 后面会分章节来详细描述.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次分析使用的linux内核的版本时 4.14.2, 读者可以自己下载了对照分析&lt;/p&gt;
&lt;p&gt;首先看链接文件如下:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ENTRY(_text)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SECTIONS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	.....省略部分无关内容....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	. = KIMAGE_VADDR + TEXT_OFFSET;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	.head.text : &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_text = .;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		HEAD_TEXT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="linux" scheme="http://gngshn.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://gngshn.github.io/tags/linux/"/>
    
      <category term="arm64" scheme="http://gngshn.github.io/tags/arm64/"/>
    
  </entry>
  
  <entry>
    <title>libuv 源码分析(5) - 文件操作流程</title>
    <link href="http://gngshn.github.io/2017/09/01/libuv-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>http://gngshn.github.io/2017/09/01/libuv-源码分析-5-文件操作流程/</id>
    <published>2017-09-01T04:02:01.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>by gngshn <a href="mailto:&#103;&#110;&#x67;&#115;&#x68;&#110;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#103;&#110;&#x67;&#115;&#x68;&#110;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;</a></p><p>上一篇, 我们讲到了libuv的工作队列, 这一篇我们讲到的文件操作刚好就用到了工作队列. 刚好复习一下.<br>先来看一段libuv文件操作的代码<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_read</span><span class="params">(<span class="keyword">uv_fs_t</span> *req)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uv_fs_t</span> open_req;</span><br><span class="line"><span class="keyword">uv_fs_t</span> read_req;</span><br><span class="line"><span class="keyword">uv_fs_t</span> write_req;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uv_buf_t</span> iov;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_write</span><span class="params">(<span class="keyword">uv_fs_t</span> *req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Write error: %s\n"</span>, uv_strerror((<span class="keyword">int</span>)req-&gt;result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        uv_fs_read(uv_default_loop(), &amp;read_req, open_req.result, &amp;iov, <span class="number">1</span>, <span class="number">-1</span>, on_read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_read</span><span class="params">(<span class="keyword">uv_fs_t</span> *req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read error: %s\n"</span>, uv_strerror(req-&gt;result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req-&gt;result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">uv_fs_t</span> close_req;</span><br><span class="line">        <span class="comment">// synchronous</span></span><br><span class="line">        uv_fs_close(uv_default_loop(), &amp;close_req, open_req.result, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req-&gt;result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        iov.len = req-&gt;result;</span><br><span class="line">        uv_fs_write(uv_default_loop(), &amp;write_req, <span class="number">1</span>, &amp;iov, <span class="number">1</span>, <span class="number">-1</span>, on_write);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_open</span><span class="params">(<span class="keyword">uv_fs_t</span> *req)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The request passed to the callback is the same as the one the call setup</span></span><br><span class="line">    <span class="comment">// function was passed.</span></span><br><span class="line">    assert(req == &amp;open_req);</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        iov = uv_buf_init(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        uv_fs_read(uv_default_loop(), &amp;read_req, req-&gt;result,</span><br><span class="line">                   &amp;iov, <span class="number">1</span>, <span class="number">-1</span>, on_read);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"error opening file: %s\n"</span>, uv_strerror((<span class="keyword">int</span>)req-&gt;result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    uv_fs_open(uv_default_loop(), &amp;open_req, argv[<span class="number">1</span>], O_RDONLY, <span class="number">0</span>, on_open);</span><br><span class="line">    uv_run(uv_default_loop(), UV_RUN_DEFAULT);</span><br><span class="line"></span><br><span class="line">    uv_fs_req_cleanup(&amp;open_req);</span><br><span class="line">    uv_fs_req_cleanup(&amp;read_req);</span><br><span class="line">    uv_fs_req_cleanup(&amp;write_req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到, 首先调用<code>uv_fs_open</code>, 然后在open的回调函数<code>on_open</code>中调用<code>uv_fs_read</code>读取文件, 之后在read的回调函数<code>on_read</code>中调用<code>uv_fs_close</code>(同步)或<code>uv_fs_write</code>(异步), 在write的回调函数中继续调用<code>uv_fs_read</code>从事时间将文件全部都出来然后写入到标准输出(1)中.</p><p>下面我们就一步一步跟踪libuv的api来看看libuv是如何处理文件操作的.</p><h3 id="uv-fs-open"><a href="#uv-fs-open" class="headerlink" title="uv_fs_open"></a>uv_fs_open</h3><p><code>uv_fs_open</code>的定义如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_fs_open</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">uv_fs_t</span>* req,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> <span class="keyword">char</span>* path,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">               uv_fs_cb cb)</span> </span>&#123;</span><br><span class="line">  INIT(OPEN);</span><br><span class="line">  PATH;</span><br><span class="line">  req-&gt;flags = flags;</span><br><span class="line">  req-&gt;mode = mode;</span><br><span class="line">  POST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>INIT</code>, <code>PATH</code>, <code>POST</code>宏是为了减少重复代码, 后面将看见它在多个地方都有用到<br>先来看看<code>INIT</code>宏:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT(subtype)                                                         \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    req-&gt;type = UV_FS;                                                        \</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">NULL</span>)                                                           \</span><br><span class="line">      uv__req_init(loop, req, UV_FS);                                         \</span><br><span class="line">    req-&gt;fs_type = UV_FS_ ## subtype;                                         \</span><br><span class="line">    req-&gt;result = <span class="number">0</span>;                                                          \</span><br><span class="line">    req-&gt;ptr = <span class="literal">NULL</span>;                                                          \</span><br><span class="line">    req-&gt;loop = loop;                                                         \</span><br><span class="line">    req-&gt;path = <span class="literal">NULL</span>;                                                         \</span><br><span class="line">    req-&gt;new_path = <span class="literal">NULL</span>;                                                     \</span><br><span class="line">    req-&gt;cb = cb;                                                             \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>初始化req的属性, 值得注意的是, 当cb不为NULL(表示异步操作时), 需要调用<code>uv__req_init</code>把req注册到loop中.<br><code>PATH</code>宏主要是处理<code>path</code>变量是否需要复制一份, 因为如果在异步回调时, path是否在存在都不知道了.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH                                                                  \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    assert(path != <span class="literal">NULL</span>);                                                     \</span><br><span class="line">    <span class="keyword">if</span> (cb == <span class="literal">NULL</span>) &#123;                                                         \</span><br><span class="line">      req-&gt;path = path;                                                       \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                  \</span><br><span class="line">      req-&gt;path = uv__strdup(path);                                           \</span><br><span class="line">      <span class="keyword">if</span> (req-&gt;path == <span class="literal">NULL</span>) &#123;                                                \</span><br><span class="line">        uv__req_unregister(loop, req);                                        \</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;                                                       \</span><br><span class="line">      &#125;                                                                       \</span><br><span class="line">    &#125;                                                                         \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>POST宏也是根据同步和异步操作来进行不同的处理, 如果是同步操作, 直接调用<code>uv__fs_work</code>并返回结果. 如果是异步操作, 那么调用<code>uv__work_submit</code>将任务<code>uv__fs_work</code>交给工作队列(线程池)来做. 根据上一篇所讲, 工作队列完成工作后, 最终会调用<code>uv__fs_done</code>回调.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POST                                                                  \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">NULL</span>) &#123;                                                         \</span><br><span class="line">      uv__work_submit(loop, &amp;req-&gt;work_req, uv__fs_work, uv__fs_done);        \</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;                                                               \</span><br><span class="line">    &#125;                                                                         \</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                    \</span><br><span class="line">      uv__fs_work(&amp;req-&gt;work_req);                                            \</span><br><span class="line">      <span class="keyword">return</span> req-&gt;result;                                                     \</span><br><span class="line">    &#125;                                                                         \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p><code>uv_fs_open</code>就是上面的这些操作.<br>我们再来看看<code>uv_fs_read</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_fs_read</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv_fs_t</span>* req,</span></span></span><br><span class="line"><span class="function"><span class="params">               uv_file file,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> bufs[],</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">unsigned</span> <span class="keyword">int</span> nbufs,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int64_t</span> off,</span></span></span><br><span class="line"><span class="function"><span class="params">               uv_fs_cb cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bufs == <span class="literal">NULL</span> || nbufs == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  INIT(READ);</span><br><span class="line">  req-&gt;file = file;</span><br><span class="line"></span><br><span class="line">  req-&gt;nbufs = nbufs;</span><br><span class="line">  req-&gt;bufs = req-&gt;bufsml;</span><br><span class="line">  <span class="keyword">if</span> (nbufs &gt; ARRAY_SIZE(req-&gt;bufsml))</span><br><span class="line">    req-&gt;bufs = uv__malloc(nbufs * <span class="keyword">sizeof</span>(*bufs));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (req-&gt;bufs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">NULL</span>)</span><br><span class="line">      uv__req_unregister(loop, req);</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(req-&gt;bufs, bufs, nbufs * <span class="keyword">sizeof</span>(*bufs));</span><br><span class="line"></span><br><span class="line">  req-&gt;off = off;</span><br><span class="line">  POST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到, 又一次用到了<code>INIT</code>和<code>POST</code>宏, 我们关注一下中间的部分. 这段代码就是调整一下bufs的大小并将bufs描述信息复制到req中. 如果调整失败就取消这个read请求. 后面的操作就跟open类似了, 根据是否有回调来决定用线程或同步的调用read相关的系统调用来处理以此read请求.<br><br>对于write跟read类似, 我们就不说了<br><br>除了用直接的request来处理文件的操作, 我们还可以用stream来处理, 接下来, 我们就来讲讲这部份.</p><p>先来直接看一段使用stream的代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uv_write_t</span> req;</span><br><span class="line">    <span class="keyword">uv_buf_t</span> buf;</span><br><span class="line">&#125; <span class="keyword">write_req_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uv_loop_t</span> *loop;</span><br><span class="line"><span class="keyword">uv_pipe_t</span> stdin_pipe;</span><br><span class="line"><span class="keyword">uv_pipe_t</span> stdout_pipe;</span><br><span class="line"><span class="keyword">uv_pipe_t</span> file_pipe;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc_buffer</span><span class="params">(<span class="keyword">uv_handle_t</span> *handle, <span class="keyword">size_t</span> suggested_size, <span class="keyword">uv_buf_t</span> *buf)</span> </span>&#123;</span><br><span class="line">    *buf = uv_buf_init((<span class="keyword">char</span>*) <span class="built_in">malloc</span>(suggested_size), suggested_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_write_req</span><span class="params">(<span class="keyword">uv_write_t</span> *req)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">write_req_t</span> *wr = (<span class="keyword">write_req_t</span>*) req;</span><br><span class="line">    <span class="built_in">free</span>(wr-&gt;buf.base);</span><br><span class="line">    <span class="built_in">free</span>(wr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_stdout_write</span><span class="params">(<span class="keyword">uv_write_t</span> *req, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    free_write_req(req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_file_write</span><span class="params">(<span class="keyword">uv_write_t</span> *req, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    free_write_req(req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_data</span><span class="params">(<span class="keyword">uv_stream_t</span> *dest, <span class="keyword">size_t</span> size, <span class="keyword">uv_buf_t</span> buf, uv_write_cb cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">write_req_t</span> *req = (<span class="keyword">write_req_t</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">write_req_t</span>));</span><br><span class="line">    req-&gt;buf = uv_buf_init((<span class="keyword">char</span>*) <span class="built_in">malloc</span>(size), size);</span><br><span class="line">    <span class="built_in">memcpy</span>(req-&gt;buf.base, buf.base, size);</span><br><span class="line">    uv_write((<span class="keyword">uv_write_t</span>*) req, (<span class="keyword">uv_stream_t</span>*)dest, &amp;req-&gt;buf, <span class="number">1</span>, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_stdin</span><span class="params">(<span class="keyword">uv_stream_t</span> *stream, <span class="keyword">ssize_t</span> nread, <span class="keyword">const</span> <span class="keyword">uv_buf_t</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nread &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nread == UV_EOF)&#123;</span><br><span class="line">            <span class="comment">// end of file</span></span><br><span class="line">            uv_close((<span class="keyword">uv_handle_t</span> *)&amp;stdin_pipe, <span class="literal">NULL</span>);</span><br><span class="line">            uv_close((<span class="keyword">uv_handle_t</span> *)&amp;stdout_pipe, <span class="literal">NULL</span>);</span><br><span class="line">            uv_close((<span class="keyword">uv_handle_t</span> *)&amp;file_pipe, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write_data((<span class="keyword">uv_stream_t</span> *)&amp;stdout_pipe, nread, *buf, on_stdout_write);</span><br><span class="line">        write_data((<span class="keyword">uv_stream_t</span> *)&amp;file_pipe, nread, *buf, on_file_write);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OK to free buffer as write_data copies it.</span></span><br><span class="line">    <span class="keyword">if</span> (buf-&gt;base)</span><br><span class="line">        <span class="built_in">free</span>(buf-&gt;base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    loop = uv_default_loop();</span><br><span class="line"></span><br><span class="line">    uv_pipe_init(loop, &amp;stdin_pipe, <span class="number">0</span>);</span><br><span class="line">    uv_pipe_open(&amp;stdin_pipe, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    uv_pipe_init(loop, &amp;stdout_pipe, <span class="number">0</span>);</span><br><span class="line">    uv_pipe_open(&amp;stdout_pipe, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uv_fs_t</span> file_req;</span><br><span class="line">    <span class="keyword">int</span> fd = uv_fs_open(loop, &amp;file_req, argv[<span class="number">1</span>], O_CREAT | O_RDWR, <span class="number">0644</span>, <span class="literal">NULL</span>);</span><br><span class="line">    uv_pipe_init(loop, &amp;file_pipe, <span class="number">0</span>);</span><br><span class="line">    uv_pipe_open(&amp;file_pipe, fd);</span><br><span class="line"></span><br><span class="line">    uv_read_start((<span class="keyword">uv_stream_t</span>*)&amp;stdin_pipe, alloc_buffer, read_stdin);</span><br><span class="line"></span><br><span class="line">    uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到程序首先初始化三个uv pipe, 分别打开标准输入, 标准输出和参数表中的文件. 然后调用<code>uv_read_start</code>注册读事件, 会有两个回调函数: <code>alloc_buffer</code>(从而允许用户自己进行内存管理)和<code>read_stdin</code>(读完成后的回调). 然后调用<code>uv_run</code>启动event loop, 后面会在<code>read_stdin</code>中注册其他事件来完成输入的显示和保存.<br>我们先来看看<code>uv_pipe_init</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_pipe_init</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv_pipe_t</span>* handle, <span class="keyword">int</span> ipc)</span> </span>&#123;</span><br><span class="line">  uv__stream_init(loop, (<span class="keyword">uv_stream_t</span>*)handle, UV_NAMED_PIPE);</span><br><span class="line">  handle-&gt;shutdown_req = <span class="literal">NULL</span>;</span><br><span class="line">  handle-&gt;connect_req = <span class="literal">NULL</span>;</span><br><span class="line">  handle-&gt;pipe_fname = <span class="literal">NULL</span>;</span><br><span class="line">  handle-&gt;ipc = ipc;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__stream_init</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">uv_stream_t</span>* stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                     uv_handle_type type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  uv__handle_init(loop, (<span class="keyword">uv_handle_t</span>*)stream, type);</span><br><span class="line">  stream-&gt;read_cb = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;alloc_cb = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;close_cb = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;connection_cb = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;connect_req = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;shutdown_req = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;accepted_fd = <span class="number">-1</span>;</span><br><span class="line">  stream-&gt;queued_fds = <span class="literal">NULL</span>;</span><br><span class="line">  stream-&gt;delayed_error = <span class="number">0</span>;</span><br><span class="line">  QUEUE_INIT(&amp;stream-&gt;write_queue);</span><br><span class="line">  QUEUE_INIT(&amp;stream-&gt;write_completed_queue);</span><br><span class="line">  stream-&gt;write_queue_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;emfile_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    err = uv__open_cloexec(<span class="string">"/dev/null"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">/* In the rare case that "/dev/null" isn't mounted open "/"</span></span><br><span class="line"><span class="comment">         * instead.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        err = uv__open_cloexec(<span class="string">"/"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (err &gt;= <span class="number">0</span>)</span><br><span class="line">      loop-&gt;emfile_fd = err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__)</span></span><br><span class="line">  stream-&gt;select = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* defined(__APPLE_) */</span></span></span><br><span class="line"></span><br><span class="line">  uv__io_init(&amp;stream-&gt;io_watcher, uv__stream_io, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init部分还是比较简单的, 主要有<code>uv__handle_init</code>和<code>uv__io_init</code>. 前面说过了<br>然后<code>uv_pipe_open</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_pipe_open</span><span class="params">(<span class="keyword">uv_pipe_t</span>* handle, uv_file fd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  err = uv__nonblock(fd, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__)</span></span><br><span class="line">  err = uv__stream_try_select((<span class="keyword">uv_stream_t</span>*) handle, &amp;fd);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* defined(__APPLE__) */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uv__stream_open((<span class="keyword">uv_stream_t</span>*)handle,</span><br><span class="line">                         fd,</span><br><span class="line">                         UV_STREAM_READABLE | UV_STREAM_WRITABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv__stream_open</span><span class="params">(<span class="keyword">uv_stream_t</span>* stream, <span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__)</span></span><br><span class="line">  <span class="keyword">int</span> enable;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(stream-&gt;io_watcher.fd == <span class="number">-1</span> || stream-&gt;io_watcher.fd == fd))</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">  assert(fd &gt;= <span class="number">0</span>);</span><br><span class="line">  stream-&gt;flags |= flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stream-&gt;type == UV_TCP) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((stream-&gt;flags &amp; UV_TCP_NODELAY) &amp;&amp; uv__tcp_nodelay(fd, <span class="number">1</span>))</span><br><span class="line">      <span class="keyword">return</span> -errno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TODO Use delay the user passed in. */</span></span><br><span class="line">    <span class="keyword">if</span> ((stream-&gt;flags &amp; UV_TCP_KEEPALIVE) &amp;&amp; uv__tcp_keepalive(fd, <span class="number">1</span>, <span class="number">60</span>))</span><br><span class="line">      <span class="keyword">return</span> -errno;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__)</span></span><br><span class="line">  enable = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_OOBINLINE, &amp;enable, <span class="keyword">sizeof</span>(enable)) &amp;&amp;</span><br><span class="line">      errno != ENOTSOCK &amp;&amp;</span><br><span class="line">      errno != EINVAL) &#123;</span><br><span class="line">    <span class="keyword">return</span> -errno;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  stream-&gt;io_watcher.fd = fd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单, 除了对TCP进行特殊处理就是把fd保存到io_watcher中.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_read_start</span><span class="params">(<span class="keyword">uv_stream_t</span>* stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                  uv_alloc_cb alloc_cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                  uv_read_cb read_cb)</span> </span>&#123;</span><br><span class="line">  assert(stream-&gt;type == UV_TCP || stream-&gt;type == UV_NAMED_PIPE ||</span><br><span class="line">      stream-&gt;type == UV_TTY);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stream-&gt;flags &amp; UV_CLOSING)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The UV_STREAM_READING flag is irrelevant of the state of the tcp - it just</span></span><br><span class="line"><span class="comment">   * expresses the desired state of the user.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  stream-&gt;flags |= UV_STREAM_READING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> try to do the read inline? */</span></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> keep track of tcp state. If we've gotten a EOF then we should</span></span><br><span class="line"><span class="comment">   * not start the IO watcher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  assert(uv__stream_fd(stream) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(alloc_cb);</span><br><span class="line"></span><br><span class="line">  stream-&gt;read_cb = read_cb;</span><br><span class="line">  stream-&gt;alloc_cb = alloc_cb;</span><br><span class="line"></span><br><span class="line">  uv__io_start(stream-&gt;loop, &amp;stream-&gt;io_watcher, POLLIN);</span><br><span class="line">  uv__handle_start(stream);</span><br><span class="line">  uv__stream_osx_interrupt_select(stream);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要是<code>uv__io_start</code>和<code>uv__handle_start</code>, 前者把事件放到watcher_queue, 这里要注意event是先放在pevents中的, 后面poll的时候才放到events中, 后者启动handle(stream)</p><p>那么<code>alloc_cb</code>和<code>read_cb</code>是如何调用到的呢?<br>在<code>uv__pipe_init</code>被调用时, 调用了<code>uv__stream_init</code>, 进而调用<code>uv__io_init(&amp;stream-&gt;io_watcher, uv__stream_io, -1)</code>, 这里设定了poll事件的回调为<code>io__stream_io</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv__stream_io</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv__io_t</span>* w, <span class="keyword">unsigned</span> <span class="keyword">int</span> events)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uv_stream_t</span>* stream;</span><br><span class="line"></span><br><span class="line">  stream = container_of(w, <span class="keyword">uv_stream_t</span>, io_watcher);</span><br><span class="line"></span><br><span class="line">  assert(stream-&gt;type == UV_TCP ||</span><br><span class="line">         stream-&gt;type == UV_NAMED_PIPE ||</span><br><span class="line">         stream-&gt;type == UV_TTY);</span><br><span class="line">  assert(!(stream-&gt;flags &amp; UV_CLOSING));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stream-&gt;connect_req) &#123;</span><br><span class="line">    uv__stream_connect(stream);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(uv__stream_fd(stream) &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ignore POLLHUP here. Even it it's set, there may still be data to read. */</span></span><br><span class="line">  <span class="keyword">if</span> (events &amp; (POLLIN | POLLERR | POLLHUP))</span><br><span class="line">    uv__read(stream);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uv__stream_fd(stream) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">/* read_cb closed stream. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Short-circuit iff POLLHUP is set, the user is still interested in read</span></span><br><span class="line"><span class="comment">   * events and uv__read() reported a partial read but not EOF. If the EOF</span></span><br><span class="line"><span class="comment">   * flag is set, uv__read() called read_cb with err=UV_EOF and we don't</span></span><br><span class="line"><span class="comment">   * have to do anything. If the partial read flag is not set, we can't</span></span><br><span class="line"><span class="comment">   * report the EOF yet because there is still data to read.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ((events &amp; POLLHUP) &amp;&amp;</span><br><span class="line">      (stream-&gt;flags &amp; UV_STREAM_READING) &amp;&amp;</span><br><span class="line">      (stream-&gt;flags &amp; UV_STREAM_READ_PARTIAL) &amp;&amp;</span><br><span class="line">      !(stream-&gt;flags &amp; UV_STREAM_READ_EOF)) &#123;</span><br><span class="line">    <span class="keyword">uv_buf_t</span> buf = &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    uv__stream_eof(stream, &amp;buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uv__stream_fd(stream) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">/* read_cb closed stream. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (events &amp; (POLLOUT | POLLERR | POLLHUP)) &#123;</span><br><span class="line">    uv__write(stream);</span><br><span class="line">    uv__write_callbacks(stream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write queue drained. */</span></span><br><span class="line">    <span class="keyword">if</span> (QUEUE_EMPTY(&amp;stream-&gt;write_queue))</span><br><span class="line">      uv__drain(stream);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>connect_req等到tcp再说. 这里会调用<code>uv__read</code>, 在这里面会调用<code>alloc_cb</code>分配内存, 对于ipc用<code>uv__recvmsg</code>读数据, 否则用<code>read</code>来读数据.可以看到stream根据不同的结果(如需要重读, 读出错, 读完成, 正常读)来用不同的方式处理并调用<code>read_cb</code>, 对于数据没有读到要求那么多是会置起<code>UV_STREAM_READ_PARTIAL</code>.</p><p>write部分我就不分析了, 其实也比较类似.</p><p>后面就会进入libuv网络部分的分析了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;by gngshn &lt;a href=&quot;mailto:&amp;#103;&amp;#110;&amp;#x67;&amp;#115;&amp;#x68;&amp;#110;&amp;#x40;&amp;#x67;&amp;#x6d;&amp;#97;&amp;#105;&amp;#x6c;&amp;#46;&amp;#99;&amp;#111;&amp;#x6d;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&amp;#103;&amp;#110;&amp;#x67;&amp;#115;&amp;#x68;&amp;#110;&amp;#x40;&amp;#x67;&amp;#x6d;&amp;#97;&amp;#105;&amp;#x6c;&amp;#46;&amp;#99;&amp;#111;&amp;#x6d;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇, 我们讲到了libuv的工作队列, 这一篇我们讲到的文件操作刚好就用到了工作队列. 刚好复习一下.&lt;br&gt;先来看一段libuv文件操作的代码&lt;br&gt;
    
    </summary>
    
      <category term="libuv" scheme="http://gngshn.github.io/categories/libuv/"/>
    
    
      <category term="libuv" scheme="http://gngshn.github.io/tags/libuv/"/>
    
  </entry>
  
  <entry>
    <title>libuv 源码分析(4) - libuv的工作队列(线程池)</title>
    <link href="http://gngshn.github.io/2017/09/01/libuv-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-libuv%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://gngshn.github.io/2017/09/01/libuv-源码分析-4-libuv的工作队列-线程池/</id>
    <published>2017-09-01T03:59:03.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>by gngshn <a href="mailto:&#x67;&#110;&#103;&#115;&#104;&#x6e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#x67;&#110;&#103;&#115;&#104;&#x6e;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;</a></p><p>libuv通过<code>uv_work_queue</code>来交付任务给工作队列的, 这个api也是libuv实现文件异步操作的基础:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UV_EXTERN <span class="keyword">int</span> <span class="title">uv_queue_work</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">uv_work_t</span>* req,</span></span></span><br><span class="line"><span class="function"><span class="params">                            uv_work_cb work_cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                            uv_after_work_cb after_work_cb)</span></span>;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这个工作队列实现方式就是把任务(work_cb)交给线程池来处理, 并且任务完成后, 调用相应的回调函数(after_work_cb).<br><br>我们先来看看这个函数的实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_queue_work</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">uv_work_t</span>* req,</span></span></span><br><span class="line"><span class="function"><span class="params">                  uv_work_cb work_cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                  uv_after_work_cb after_work_cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (work_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  uv__req_init(loop, req, UV_WORK);</span><br><span class="line">  req-&gt;loop = loop;</span><br><span class="line">  req-&gt;work_cb = work_cb;</span><br><span class="line">  req-&gt;after_work_cb = after_work_cb;</span><br><span class="line">  uv__work_submit(loop, &amp;req-&gt;work_req, uv__queue_work, uv__queue_done);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到函数首先初始化这个请求(req), 然后就调用<code>uv__work_submit</code>完成剩余的工作.<br><br>下面我们主要就来分析一下<code>uv__work_submit</code>的操作过程. 看看libuv是如何调用<code>work_cb</code>来完成任务并调用到<code>after_work_cb</code>回调函数的.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__work_submit</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,</span></span></span><br><span class="line"><span class="function"><span class="params">                     struct uv__work* w,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">void</span> (*work)(struct uv__work* w),</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">void</span> (*done)(struct uv__work* w, <span class="keyword">int</span> status))</span> </span>&#123;</span><br><span class="line">  uv_once(&amp;once, init_once);</span><br><span class="line">  w-&gt;loop = loop;</span><br><span class="line">  w-&gt;work = work;</span><br><span class="line">  w-&gt;done = done;</span><br><span class="line">  post(&amp;w-&gt;wq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>uv_once(&amp;once, init_once);</code>用来初始化libuv的线程池, 只会被调用一次. 线程池中的线程都是执行这样一个函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__work</span>* <span class="title">w</span>;</span></span><br><span class="line">  QUEUE* q;</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) arg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    uv_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (QUEUE_EMPTY(&amp;wq)) &#123;</span><br><span class="line">      idle_threads += <span class="number">1</span>;</span><br><span class="line">      uv_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">      idle_threads -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到每个线程都是等待在<code>uv_cond_wait(&amp;cond, &amp;mutex);</code>.<br><br>初始化完成后, 会调用<code>post(&amp;w-&gt;wq)</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(QUEUE* q)</span> </span>&#123;</span><br><span class="line">  uv_mutex_lock(&amp;mutex);</span><br><span class="line">  QUEUE_INSERT_TAIL(&amp;wq, q);</span><br><span class="line">  <span class="keyword">if</span> (idle_threads &gt; <span class="number">0</span>)</span><br><span class="line">    uv_cond_signal(&amp;cond);</span><br><span class="line">  uv_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到<code>post(&amp;w-&gt;wq)</code>就是把<code>w</code>挂到全局的<code>wq</code>上面, 然后调用<code>uv_cond_signal</code>, 这就会唤醒一个前面的正在等待的线程来处理这个任务, 一个线程唤醒后, 就会执行work函数的后续部分.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__work</span>* <span class="title">w</span>;</span></span><br><span class="line">  QUEUE* q;</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) arg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    uv_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (QUEUE_EMPTY(&amp;wq)) &#123;</span><br><span class="line">      idle_threads += <span class="number">1</span>;</span><br><span class="line">      uv_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">      idle_threads -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q = QUEUE_HEAD(&amp;wq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q == &amp;exit_message)</span><br><span class="line">      uv_cond_signal(&amp;cond);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      QUEUE_REMOVE(q);</span><br><span class="line">      QUEUE_INIT(q);  <span class="comment">/* Signal uv_cancel() that the work req is</span></span><br><span class="line"><span class="comment">                             executing. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uv_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q == &amp;exit_message)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    w = QUEUE_DATA(q, struct uv__work, wq);</span><br><span class="line">    w-&gt;work(w);</span><br><span class="line"></span><br><span class="line">    uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br><span class="line">    w-&gt;work = <span class="literal">NULL</span>;  <span class="comment">/* Signal uv_cancel() that the work req is done</span></span><br><span class="line"><span class="comment">                        executing. */</span></span><br><span class="line">    QUEUE_INSERT_TAIL(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq);</span><br><span class="line">    uv_async_send(&amp;w-&gt;loop-&gt;wq_async);</span><br><span class="line">    uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线程先取出一个链表的元素q.<br><br><code>exit_message</code>相关的操作是用来退出所有线程的, 在libuv退出时, <code>post(&amp;exit_message);</code>被调用, 这会让libuv的所有线程都退出.<br><br>如果没有<code>exit_message</code>, 线程正常往后执行. 先把<code>q</code>从<code>wq</code>链表中删除, 然后调用<code>w-&gt;work</code>(就是最开始的<code>work_cb</code>, 相当于执行工作), 然后把w放到<code>loop-&gt;wq</code>中并调用<code>uv_async_send</code>向event loop发送信号. event loop会注意这个信号并作出相应的处理.<br><br>为了弄清楚event loop是如何注意到这个信号的, 我们先来看看<code>uv_async_send</code>都干了什么<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_async_send</span><span class="params">(<span class="keyword">uv_async_t</span>* handle)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Do a cheap read first. */</span></span><br><span class="line">  <span class="keyword">if</span> (ACCESS_ONCE(<span class="keyword">int</span>, handle-&gt;pending) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cmpxchgi(&amp;handle-&gt;pending, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    uv__async_send(handle-&gt;loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里async事件在还没有被处理时(penging=1)多次发送也只有一次生效<br><br>判断<code>handle-&gt;pending</code>如果是1, 表示已经发送过并且还没处理, 所以直接返回.<br><br>如果是0就表明没有pending事件, 原子的设置<code>pending</code>为1, 并调用<code>uv__async_send</code>, 这个函数会往<code>loop-&gt;async_io_watcher.fd</code>(一个eventfd)里面写入’\n’, 从而event_loop会在epoll中发现. 发现后会调用相应的回调函数, 那么回调函数是什么呢?<br><br>在<code>uv_loop_init</code>中会调用<code>uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done)</code>来指定回调函数是<code>uv__work_done</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_async_init</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv_async_t</span>* handle, uv_async_cb async_cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  err = uv__async_start(loop);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  uv__handle_init(loop, (<span class="keyword">uv_handle_t</span>*)handle, UV_ASYNC);</span><br><span class="line">  handle-&gt;async_cb = async_cb;</span><br><span class="line">  handle-&gt;pending = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, &amp;handle-&gt;<span class="built_in">queue</span>);</span><br><span class="line">  uv__handle_start(handle);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>uv__async_start</code>中创建eventfd, 并将其POLLIN事件加入event loop, 事件发生时会调用<code>uv__async_io</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uv__io_init(&amp;loop-&gt;async_io_watcher, uv__async_io, pipefd[<span class="number">0</span>]);</span><br><span class="line">uv__io_start(loop, &amp;loop-&gt;async_io_watcher, POLLIN);</span><br></pre></td></tr></table></figure></p><p>然后把handle初始化并配置async_cb和pending加入到event loop的async_handles中, 并启动handle.<br><br>事件发生后调用<code>uv__async_io</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv__async_io</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv__io_t</span>* w, <span class="keyword">unsigned</span> <span class="keyword">int</span> events)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">ssize_t</span> r;</span><br><span class="line">  QUEUE <span class="built_in">queue</span>;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  <span class="keyword">uv_async_t</span>* h;</span><br><span class="line"></span><br><span class="line">  assert(w == &amp;loop-&gt;async_io_watcher);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    r = read(w-&gt;fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">sizeof</span>(buf))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;async_handles, &amp;<span class="built_in">queue</span>);</span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;<span class="built_in">queue</span>)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    h = QUEUE_DATA(q, <span class="keyword">uv_async_t</span>, <span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmpxchgi(&amp;h-&gt;pending, <span class="number">1</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;async_cb == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    h-&gt;async_cb(h);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这个函数先把eventfd的内容读空, 然后一次对async_handles中的元素判断其pending, 如果为1就原子的将其至0, 这也表示handle有待处理的异步通知, 因此就会调用<code>h-&gt;async_cb(h)</code><br><br>前面说过(<code>uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done)</code>)对于我们的线程池来说这个回调是<code>uv__work_done</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__work_done</span><span class="params">(<span class="keyword">uv_async_t</span>* handle)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__work</span>* <span class="title">w</span>;</span></span><br><span class="line">  <span class="keyword">uv_loop_t</span>* loop;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE wq;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  loop = container_of(handle, <span class="keyword">uv_loop_t</span>, wq_async);</span><br><span class="line">  uv_mutex_lock(&amp;loop-&gt;wq_mutex);</span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;wq, &amp;wq);</span><br><span class="line">  uv_mutex_unlock(&amp;loop-&gt;wq_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;wq)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;wq);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line"></span><br><span class="line">    w = container_of(q, struct uv__work, wq);</span><br><span class="line">    err = (w-&gt;work == uv__cancelled) ? UV_ECANCELED : <span class="number">0</span>;</span><br><span class="line">    w-&gt;done(w, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数把<code>loop-&gt;wq</code>的元素挨个删除并调用<code>done</code>回调函数. 这个<code>done</code>回调函数就是我们前面说的<code>after_work_cb</code>回调.<br>至此, libuv的工作队列的实现就说完了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;by gngshn &lt;a href=&quot;mailto:&amp;#x67;&amp;#110;&amp;#103;&amp;#115;&amp;#104;&amp;#x6e;&amp;#64;&amp;#103;&amp;#x6d;&amp;#97;&amp;#105;&amp;#x6c;&amp;#46;&amp;#99;&amp;#111;&amp;#x6d;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&amp;#x67;&amp;#110;&amp;#103;&amp;#115;&amp;#104;&amp;#x6e;&amp;#64;&amp;#103;&amp;#x6d;&amp;#97;&amp;#105;&amp;#x6c;&amp;#46;&amp;#99;&amp;#111;&amp;#x6d;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;libuv通过&lt;code&gt;uv_work_queue&lt;/code&gt;来交付任务给工作队列的, 这个api也是libuv实现文件异步操作的基础:&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;UV_EXTERN &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;uv_queue_work&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;uv_loop_t&lt;/span&gt;* loop,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;uv_work_t&lt;/span&gt;* req,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                            uv_work_cb work_cb,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                            uv_after_work_cb after_work_cb)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="libuv" scheme="http://gngshn.github.io/categories/libuv/"/>
    
    
      <category term="libuv" scheme="http://gngshn.github.io/tags/libuv/"/>
    
  </entry>
  
  <entry>
    <title>libuv 源码阅读(3) - poll过程</title>
    <link href="http://gngshn.github.io/2017/09/01/libuv-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-poll%E8%BF%87%E7%A8%8B/"/>
    <id>http://gngshn.github.io/2017/09/01/libuv-源码分析-3-poll过程/</id>
    <published>2017-09-01T03:54:55.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>by gngshn <a href="mailto:&#x67;&#x6e;&#x67;&#x73;&#x68;&#110;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x67;&#x6e;&#x67;&#x73;&#x68;&#110;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;</a></p><p>上一篇, 我们将到libuv的event loop过程, 其中留了个悬念, 下面我们来解除这个悬念, 直接上函数, 这个函数特别长, 我们依旧直接在函数里面写注释把~<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__io_poll</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* A bug in kernels &lt; 2.6.37 makes timeouts larger than ~30 minutes</span></span><br><span class="line"><span class="comment">   * effectively infinite on 32 bits architectures.  To avoid blocking</span></span><br><span class="line"><span class="comment">   * indefinitely, we cap the timeout and poll again if necessary.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Note that "30 minutes" is a simplification because it depends on</span></span><br><span class="line"><span class="comment">   * the value of CONFIG_HZ.  The magic constant assumes CONFIG_HZ=1200,</span></span><br><span class="line"><span class="comment">   * that being the largest value I have seen in the wild (and only once.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> max_safe_timeout = <span class="number">1789569</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> no_epoll_pwait;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> no_epoll_wait;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__epoll_event</span> <span class="title">events</span>[1024];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__epoll_event</span>* <span class="title">pe</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uv__epoll_event</span> <span class="title">e</span>;</span></span><br><span class="line">  <span class="keyword">int</span> real_timeout;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  <span class="keyword">uv__io_t</span>* w;</span><br><span class="line">  <span class="keyword">sigset_t</span> sigset;</span><br><span class="line">  <span class="keyword">uint64_t</span> sigmask;</span><br><span class="line">  <span class="keyword">uint64_t</span> base;</span><br><span class="line">  <span class="keyword">int</span> have_signals;</span><br><span class="line">  <span class="keyword">int</span> nevents;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">int</span> nfds;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">int</span> op;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果watcher_queue是空, 表明没有时间要等待, 可以直接返回 */</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;nfds == <span class="number">0</span>) &#123;</span><br><span class="line">    assert(QUEUE_EMPTY(&amp;loop-&gt;watcher_queue));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 以此在`watcher_queue`中取出事件 */</span></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;loop-&gt;watcher_queue)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;loop-&gt;watcher_queue);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line"></span><br><span class="line">    w = QUEUE_DATA(q, <span class="keyword">uv__io_t</span>, watcher_queue);</span><br><span class="line">    assert(w-&gt;pevents != <span class="number">0</span>);</span><br><span class="line">    assert(w-&gt;fd &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(w-&gt;fd &lt; (<span class="keyword">int</span>) loop-&gt;nwatchers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把需要监听的文件的事件加入/修改到epoll中 */</span></span><br><span class="line">    e.events = w-&gt;pevents;</span><br><span class="line">    e.data = w-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w-&gt;events == <span class="number">0</span>)</span><br><span class="line">      op = UV__EPOLL_CTL_ADD;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      op = UV__EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX Future optimization: do EPOLL_CTL_MOD lazily if we stop watching</span></span><br><span class="line"><span class="comment">     * events, skip the syscall and squelch the events after epoll_wait().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (uv__epoll_ctl(loop-&gt;backend_fd, op, w-&gt;fd, &amp;e)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno != EEXIST)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">      assert(op == UV__EPOLL_CTL_ADD);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We've reactivated a file descriptor that's been watched before. */</span></span><br><span class="line">      <span class="keyword">if</span> (uv__epoll_ctl(loop-&gt;backend_fd, UV__EPOLL_CTL_MOD, w-&gt;fd, &amp;e))</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w-&gt;events = w-&gt;pevents;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 对SIGPROF的屏蔽处理, 注意这里用到了两种方式, 取决于系统的支持程度epoll_pwait/pthread_sigmask */</span></span><br><span class="line">  sigmask = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;flags &amp; UV_LOOP_BLOCK_SIGPROF) &#123;</span><br><span class="line">    sigemptyset(&amp;sigset);</span><br><span class="line">    sigaddset(&amp;sigset, SIGPROF);</span><br><span class="line">    sigmask |= <span class="number">1</span> &lt;&lt; (SIGPROF - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(timeout &gt;= <span class="number">-1</span>);</span><br><span class="line">  base = loop-&gt;time;</span><br><span class="line">  count = <span class="number">48</span>; <span class="comment">/* Benchmarks suggest this gives the best throughput. */</span></span><br><span class="line">  real_timeout = timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">/* See the comment for max_safe_timeout for an explanation of why</span></span><br><span class="line"><span class="comment">     * this is necessary.  Executive summary: kernel bug workaround.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 见上面的英文注释 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>) == <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &amp;&amp; timeout &gt;= max_safe_timeout)</span><br><span class="line">      timeout = max_safe_timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigmask != <span class="number">0</span> &amp;&amp; no_epoll_pwait != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> (pthread_sigmask(SIG_BLOCK, &amp;sigset, <span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进行epoll调用, 等待事件 */</span></span><br><span class="line">    <span class="keyword">if</span> (no_epoll_wait != <span class="number">0</span> || (sigmask != <span class="number">0</span> &amp;&amp; no_epoll_pwait == <span class="number">0</span>)) &#123;</span><br><span class="line">      nfds = uv__epoll_pwait(loop-&gt;backend_fd,</span><br><span class="line">                             events,</span><br><span class="line">                             ARRAY_SIZE(events),</span><br><span class="line">                             timeout,</span><br><span class="line">                             sigmask);</span><br><span class="line">      <span class="keyword">if</span> (nfds == <span class="number">-1</span> &amp;&amp; errno == ENOSYS)</span><br><span class="line">        no_epoll_pwait = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nfds = uv__epoll_wait(loop-&gt;backend_fd,</span><br><span class="line">                            events,</span><br><span class="line">                            ARRAY_SIZE(events),</span><br><span class="line">                            timeout);</span><br><span class="line">      <span class="keyword">if</span> (nfds == <span class="number">-1</span> &amp;&amp; errno == ENOSYS)</span><br><span class="line">        no_epoll_wait = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigmask != <span class="number">0</span> &amp;&amp; no_epoll_pwait != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> (pthread_sigmask(SIG_UNBLOCK, &amp;sigset, <span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update loop-&gt;time unconditionally. It's tempting to skip the update when</span></span><br><span class="line"><span class="comment">     * timeout == 0 (i.e. non-blocking poll) but there is no guarantee that the</span></span><br><span class="line"><span class="comment">     * operating system didn't reschedule our process while in the syscall.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 见上面英文注释 */</span></span><br><span class="line">    SAVE_ERRNO(uv__update_time(loop));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">0</span>) &#123;</span><br><span class="line">      assert(timeout != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We may have been inside the system call for longer than |timeout|</span></span><br><span class="line"><span class="comment">       * milliseconds so we need to update the timestamp to avoid drift.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">goto</span> update_timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == ENOSYS) &#123;</span><br><span class="line">        <span class="comment">/* epoll_wait() or epoll_pwait() failed, try the other system call. */</span></span><br><span class="line">        assert(no_epoll_wait == <span class="number">0</span> || no_epoll_pwait == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeout == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Interrupted by a signal. Update timeout and poll again. */</span></span><br><span class="line">      <span class="keyword">goto</span> update_timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    have_signals = <span class="number">0</span>;</span><br><span class="line">    nevents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把所有poll到的事件描述信息放在数组的最后两个元素 */</span></span><br><span class="line">    assert(loop-&gt;watchers != <span class="literal">NULL</span>);</span><br><span class="line">    loop-&gt;watchers[loop-&gt;nwatchers] = (<span class="keyword">void</span>*) events;</span><br><span class="line">    loop-&gt;watchers[loop-&gt;nwatchers + <span class="number">1</span>] = (<span class="keyword">void</span>*) (<span class="keyword">uintptr_t</span>) nfds;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">      pe = events + i;</span><br><span class="line">      fd = pe-&gt;data;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip invalidated events, see uv__platform_invalidate_fd */</span></span><br><span class="line">      <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      assert(fd &gt;= <span class="number">0</span>);</span><br><span class="line">      assert((<span class="keyword">unsigned</span>) fd &lt; loop-&gt;nwatchers);</span><br><span class="line"></span><br><span class="line">      w = loop-&gt;watchers[fd];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (w == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* File descriptor that we've stopped watching, disarm it.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Ignore all errors because we may be racing with another thread</span></span><br><span class="line"><span class="comment">         * when the file descriptor is closed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        uv__epoll_ctl(loop-&gt;backend_fd, UV__EPOLL_CTL_DEL, fd, pe);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Give users only events they're interested in. Prevents spurious</span></span><br><span class="line"><span class="comment">       * callbacks when previous callback invocation in this loop has stopped</span></span><br><span class="line"><span class="comment">       * the current watcher. Also, filters out events that users has not</span></span><br><span class="line"><span class="comment">       * requested us to watch.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      pe-&gt;events &amp;= w-&gt;pevents | POLLERR | POLLHUP;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Work around an epoll quirk where it sometimes reports just the</span></span><br><span class="line"><span class="comment">       * EPOLLERR or EPOLLHUP event.  In order to force the event loop to</span></span><br><span class="line"><span class="comment">       * move forward, we merge in the read/write events that the watcher</span></span><br><span class="line"><span class="comment">       * is interested in; uv__read() and uv__write() will then deal with</span></span><br><span class="line"><span class="comment">       * the error or hangup in the usual fashion.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * Note to self: happens when epoll reports EPOLLIN|EPOLLHUP, the user</span></span><br><span class="line"><span class="comment">       * reads the available data, calls uv_read_stop(), then sometime later</span></span><br><span class="line"><span class="comment">       * calls uv_read_start() again.  By then, libuv has forgotten about the</span></span><br><span class="line"><span class="comment">       * hangup and the kernel won't report EPOLLIN again because there's</span></span><br><span class="line"><span class="comment">       * nothing left to read.  If anything, libuv is to blame here.  The</span></span><br><span class="line"><span class="comment">       * current hack is just a quick bandaid; to properly fix it, libuv</span></span><br><span class="line"><span class="comment">       * needs to remember the error/hangup event.  We should get that for</span></span><br><span class="line"><span class="comment">       * free when we switch over to edge-triggered I/O.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (pe-&gt;events == POLLERR || pe-&gt;events == POLLHUP)</span><br><span class="line">        pe-&gt;events |= w-&gt;pevents &amp; (POLLIN | POLLOUT | UV__POLLPRI);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (pe-&gt;events != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Run signal watchers last.  This also affects child process watchers</span></span><br><span class="line"><span class="comment">         * because those are implemented in terms of signal watchers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/* 调用回调, 对于信号处理放在后面统一执行 */</span></span><br><span class="line">        <span class="keyword">if</span> (w == &amp;loop-&gt;signal_io_watcher)</span><br><span class="line">          have_signals = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          w-&gt;cb(loop, w, pe-&gt;events);</span><br><span class="line"></span><br><span class="line">        nevents++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行信号处理程序 根据uv_loop_init看出, 这个程序是uv__signal_event, 由uv__io_init(&amp;loop-&gt;signal_io_watcher, uv__signal_event, loop-&gt;signal_pipefd[0]) 指定, 后面我们再来看这个函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (have_signals != <span class="number">0</span>)</span><br><span class="line">      loop-&gt;signal_io_watcher.cb(loop, &amp;loop-&gt;signal_io_watcher, POLLIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除两个描述符 */</span></span><br><span class="line">    loop-&gt;watchers[loop-&gt;nwatchers] = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;watchers[loop-&gt;nwatchers + <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_signals != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;  <span class="comment">/* Event loop should cycle now so don't poll again. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nevents != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nfds == ARRAY_SIZE(events) &amp;&amp; --count != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Poll for more events but don't block this time. */</span></span><br><span class="line">        timeout = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">update_timeout:</span><br><span class="line">    assert(timeout &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    real_timeout -= (loop-&gt;time - base);</span><br><span class="line">    <span class="keyword">if</span> (real_timeout &lt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    timeout = real_timeout;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过看libuv source code中的注释, 可以很快的理解这段代码到底做了写什么. 主要是加入待处理的事件到epoll, 然后poll, 发生事件就调用相关的回调函数. 另外, 为了规避BUG, 引入<code>max_safe_timeout</code>, 为了吞吐量, 引入poll的count.<br><br>我们最后来看看信号处理函数干了写啥:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv__signal_event</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uv__io_t</span>* w,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">unsigned</span> <span class="keyword">int</span> events)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uv__signal_msg_t</span>* msg;</span><br><span class="line">  <span class="keyword">uv_signal_t</span>* handle;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(<span class="keyword">uv__signal_msg_t</span>) * <span class="number">32</span>];</span><br><span class="line">  <span class="keyword">size_t</span> bytes, end, i;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">  bytes = <span class="number">0</span>;</span><br><span class="line">  end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    r = read(loop-&gt;signal_pipefd[<span class="number">0</span>], buf + bytes, <span class="keyword">sizeof</span>(buf) - bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">-1</span> &amp;&amp; errno == EINTR)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">-1</span> &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)) &#123;</span><br><span class="line">      <span class="comment">/* If there are bytes in the buffer already (which really is extremely</span></span><br><span class="line"><span class="comment">       * unlikely if possible at all) we can't exit the function here. We'll</span></span><br><span class="line"><span class="comment">       * spin until more bytes are read instead.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (bytes &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Otherwise, there was nothing there. */</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Other errors really should never happen. */</span></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">-1</span>)</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    bytes += r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* `end` is rounded down to a multiple of sizeof(uv__signal_msg_t). */</span></span><br><span class="line">    end = (bytes / <span class="keyword">sizeof</span>(<span class="keyword">uv__signal_msg_t</span>)) * <span class="keyword">sizeof</span>(<span class="keyword">uv__signal_msg_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; end; i += <span class="keyword">sizeof</span>(<span class="keyword">uv__signal_msg_t</span>)) &#123;</span><br><span class="line">      msg = (<span class="keyword">uv__signal_msg_t</span>*) (buf + i);</span><br><span class="line">      handle = msg-&gt;handle;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (msg-&gt;signum == handle-&gt;signum) &#123;</span><br><span class="line">        assert(!(handle-&gt;flags &amp; UV_CLOSING));</span><br><span class="line">        handle-&gt;signal_cb(handle, handle-&gt;signum);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      handle-&gt;dispatched_signals++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (handle-&gt;flags &amp; UV__SIGNAL_ONE_SHOT)</span><br><span class="line">        uv__signal_stop(handle);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If uv_close was called while there were caught signals that were not</span></span><br><span class="line"><span class="comment">       * yet dispatched, the uv__finish_close was deferred. Make close pending</span></span><br><span class="line"><span class="comment">       * now if this has happened.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> ((handle-&gt;flags &amp; UV_CLOSING) &amp;&amp;</span><br><span class="line">          (handle-&gt;caught_signals == handle-&gt;dispatched_signals)) &#123;</span><br><span class="line">        uv__make_close_pending((<span class="keyword">uv_handle_t</span>*) handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes -= end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If there are any "partial" messages left, move them to the start of the</span></span><br><span class="line"><span class="comment">     * the buffer, and spin. This should not happen.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (bytes) &#123;</span><br><span class="line">      memmove(buf, buf + end, bytes);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (end == <span class="keyword">sizeof</span> buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数从之前讲过的的<code>signal_pipefd[0]</code>读取异常处理程序(<code>uv__signal_handler</code>)发送过来的消息(<code>uv__signal_msg_t</code>), 这个消息包括相应的handle的signum, 调用handle的回调函数, 并进行一些回收的处理. 具体细节可以追踪函数来看, 这里就不去细说了.<br><br>到此我们就看完了libuv的event loop.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;by gngshn &lt;a href=&quot;mailto:&amp;#x67;&amp;#x6e;&amp;#x67;&amp;#x73;&amp;#x68;&amp;#110;&amp;#64;&amp;#103;&amp;#x6d;&amp;#97;&amp;#105;&amp;#108;&amp;#x2e;&amp;#x63;&amp;#111;&amp;#x6d;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&amp;#x67;&amp;#x6e;&amp;#x67;&amp;#x73;&amp;#x68;&amp;#110;&amp;#64;&amp;#103;&amp;#x6d;&amp;#97;&amp;#105;&amp;#108;&amp;#x2e;&amp;#x63;&amp;#111;&amp;#x6d;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇, 我们将到libuv的event loop过程, 其中留了个悬念, 下面我们来解除这个悬念, 直接上函数, 这个函数特别长, 我们依旧直接在函数里面写注释把~&lt;br&gt;
    
    </summary>
    
      <category term="libuv" scheme="http://gngshn.github.io/categories/libuv/"/>
    
    
      <category term="libuv" scheme="http://gngshn.github.io/tags/libuv/"/>
    
  </entry>
  
  <entry>
    <title>libuv 源码分析(2) - event loop的运转</title>
    <link href="http://gngshn.github.io/2017/09/01/libuv-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-event-loop%E7%9A%84%E8%BF%90%E8%BD%AC/"/>
    <id>http://gngshn.github.io/2017/09/01/libuv-源码分析-2-event-loop的运转/</id>
    <published>2017-09-01T03:36:11.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>by gngshn <a href="mailto:&#103;&#110;&#103;&#115;&#x68;&#x6e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#103;&#110;&#103;&#115;&#x68;&#x6e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;</a></p><p>上一篇文章我们讲到了 libuv的初始化, 现在乘热打铁, 我们接着看看 libuv的 event loop是如何运转的.<br>对于 event loop的运转在其官方的文档中有详细的描述<br><br><a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">libuv design overview</a><br>event loop的流程图如下<br><a id="more"></a><br><img src="http://docs.libuv.org/en/v1.x/_images/loop_iteration.png" alt="libuv event loop"><br>下面我们就从源码的角度来看看整个过程.<br>先看看一个最简单的 libuv程序:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uv_loop_t</span> *loop = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">uv_loop_t</span>));</span><br><span class="line">    uv_loop_init(loop);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now quitting.\n"</span>);</span><br><span class="line">    uv_run(loop, UV_RUN_DEFAULT);</span><br><span class="line"></span><br><span class="line">    uv_loop_close(loop);</span><br><span class="line">    <span class="built_in">free</span>(loop);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到 libuv的 event loop过程在 <code>uv_run</code>中实现的. 我们下面来看看其过程.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_run</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> timeout;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> ran_pending;</span><br><span class="line"></span><br><span class="line">  r = uv__loop_alive(loop);</span><br><span class="line">  <span class="keyword">if</span> (!r)</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line">    uv__run_timers(loop);</span><br><span class="line">    ran_pending = uv__run_pending(loop);</span><br><span class="line">    uv__run_idle(loop);</span><br><span class="line">    uv__run_prepare(loop);</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br><span class="line"></span><br><span class="line">    uv__io_poll(loop, timeout);</span><br><span class="line">    uv__run_check(loop);</span><br><span class="line">    uv__run_closing_handles(loop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      <span class="comment">/* UV_RUN_ONCE implies forward progress: at least one callback must have</span></span><br><span class="line"><span class="comment">       * been invoked when it returns. uv__io_poll() can return without doing</span></span><br><span class="line"><span class="comment">       * I/O (meaning: no callbacks) when its timeout expires - which means we</span></span><br><span class="line"><span class="comment">       * have pending timers that satisfy the forward progress constraint.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from</span></span><br><span class="line"><span class="comment">       * the check.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The if statement lets gcc compile it to a conditional store. Avoids</span></span><br><span class="line"><span class="comment">   * dirtying a cache line.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数首先判断 event loop是否是 alive的, 如果不是, 更新 loop时间然后就退出了. 这里判断 alive的函数为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__loop_alive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uv__has_active_handles(loop) ||</span><br><span class="line">         uv__has_active_reqs(loop) ||</span><br><span class="line">         loop-&gt;closing_handles != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到, libuv判定 event loop存活(继续循环)的逻辑为有活动的 handle, request或者待关闭的 handle.<br>当 <code>uv__loop_alive</code>返回 false时, 就不进行循环, 直接退出. 如果返回 true, 就进行循环.<br>下面我们来分析一下这个循环的过程.</p><h3 id="uv-update-time-loop"><a href="#uv-update-time-loop" class="headerlink" title="uv__update_time(loop)"></a><code>uv__update_time(loop)</code></h3><p>细心的你们在阅读代码时, 可能会发现, libuv为了性能(效率)尽可能的再优化每一个细节, 比如 time更新这个地方<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> uv__hrtime(<span class="keyword">uv_clocktype_t</span> type) &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">clock_t</span> fast_clock_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span></span><br><span class="line">  <span class="keyword">clock_t</span> clock_id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Prefer CLOCK_MONOTONIC_COARSE if available but only when it has</span></span><br><span class="line"><span class="comment">   * millisecond granularity or better.  CLOCK_MONOTONIC_COARSE is</span></span><br><span class="line"><span class="comment">   * serviced entirely from the vDSO, whereas CLOCK_MONOTONIC may</span></span><br><span class="line"><span class="comment">   * decide to make a costly system call.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/* TODO(bnoordhuis) Use CLOCK_MONOTONIC_COARSE for UV_CLOCK_PRECISE</span></span><br><span class="line"><span class="comment">   * when it has microsecond granularity or better (unlikely).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (type == UV_CLOCK_FAST &amp;&amp; fast_clock_id == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clock_getres(CLOCK_MONOTONIC_COARSE, &amp;t) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        t.tv_nsec &lt;= <span class="number">1</span> * <span class="number">1000</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">      fast_clock_id = CLOCK_MONOTONIC_COARSE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fast_clock_id = CLOCK_MONOTONIC;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clock_id = CLOCK_MONOTONIC;</span><br><span class="line">  <span class="keyword">if</span> (type == UV_CLOCK_FAST)</span><br><span class="line">    clock_id = fast_clock_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (clock_gettime(clock_id, &amp;t))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* Not really possible. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> t.tv_sec * (<span class="keyword">uint64_t</span>) <span class="number">1e9</span> + t.tv_nsec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CLOCK_MONOTONIC_COARSE</code>这种类型的 clock精度足够就会用这种类型, 因为这种类型的 clock使用 vDSO, 可以降低系统调用的开销.</p><h3 id="uv-run-timers-loop"><a href="#uv-run-timers-loop" class="headerlink" title="uv__run_timers(loop)"></a><code>uv__run_timers(loop)</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__run_timers</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">heap_node</span>* <span class="title">heap_node</span>;</span></span><br><span class="line">  <span class="keyword">uv_timer_t</span>* handle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    heap_node = heap_min((struct heap*) &amp;loop-&gt;timer_heap);</span><br><span class="line">    <span class="keyword">if</span> (heap_node == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    handle = container_of(heap_node, <span class="keyword">uv_timer_t</span>, heap_node);</span><br><span class="line">    <span class="keyword">if</span> (handle-&gt;timeout &gt; loop-&gt;time)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    uv_timer_stop(handle);</span><br><span class="line">    uv_timer_again(handle);</span><br><span class="line">    handle-&gt;timer_cb(handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的timer handles都是用 <code>uv_timer_start</code>调用来注册生效的. <code>uv__run_timers</code>就是把注册的 timers中到期的 timer去掉并注册回调, 具体过程为:<br><br>具体流程为, 从 <code>timer_heap</code>(最小堆)取 timer, 这是最小的 timer, 如果 timer比现在的时间大, 表明没超时, 就可以退出了, 如果比现在的时间小, 表明已经超时, 就将 timer从 heap中删除, 然后调用 <code>uv__handle_stop</code>停止 handle. 再调用 <code>uv_timer_again</code>(会调用<code>uv_timer_start</code>)再次开启有 repeat值的 timer, 这次 timer的时间是按照 timer的 repeat时间来设定, 也就是 timer可以周期性触发. 最后调用 timer的 <code>timer_cb</code>回调.<br><br>回到开启继续处理后面的 timer.</p><p>这里刚好遇到了 handle的操作, 之前没细说, 这里细说下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__handle_start(h)                                                   \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    assert(((h)-&gt;flags &amp; UV__HANDLE_CLOSING) == <span class="number">0</span>);                           \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_ACTIVE) != <span class="number">0</span>) <span class="keyword">break</span>;                         \</span><br><span class="line">    (h)-&gt;flags |= UV__HANDLE_ACTIVE;                                          \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_REF) != <span class="number">0</span>) uv__active_handle_add(h);         \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__handle_stop(h)                                                    \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    assert(((h)-&gt;flags &amp; UV__HANDLE_CLOSING) == <span class="number">0</span>);                           \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_ACTIVE) == <span class="number">0</span>) <span class="keyword">break</span>;                         \</span><br><span class="line">    (h)-&gt;flags &amp;= ~UV__HANDLE_ACTIVE;                                         \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_REF) != <span class="number">0</span>) uv__active_handle_rm(h);          \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__handle_ref(h)                                                     \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_REF) != <span class="number">0</span>) <span class="keyword">break</span>;                            \</span><br><span class="line">    (h)-&gt;flags |= UV__HANDLE_REF;                                             \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_CLOSING) != <span class="number">0</span>) <span class="keyword">break</span>;                        \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_ACTIVE) != <span class="number">0</span>) uv__active_handle_add(h);      \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__handle_unref(h)                                                   \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_REF) == <span class="number">0</span>) <span class="keyword">break</span>;                            \</span><br><span class="line">    (h)-&gt;flags &amp;= ~UV__HANDLE_REF;                                            \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_CLOSING) != <span class="number">0</span>) <span class="keyword">break</span>;                        \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV__HANDLE_ACTIVE) != <span class="number">0</span>) uv__active_handle_rm(h);       \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>上面这四个宏用来开启, 关闭, 引用, 解除引用handle, 这里要注意到几点:</p><ol><li>在开启 handle时, 当 <code>UV__HANDLE_ACTIVE</code>已经置起来时(handle已经开启了), 就不进行后面的操作了, 所以可以重复调用 <code>uv__handle_start</code>不会产生问题. 关闭 handle时同理.</li><li>在引用 handle时, 当 <code>UV__HANDLE_REF</code>已经置起来时(handle已经引用过了), 就不再增加引用计数了, 所以重复调用, handle也只会增加一次引用计数, 解除引用 handle时同理.</li><li><code>uv__active_handle_add</code>和<code>uv__active_handle_rm</code>增加/减少的引用计数是loop的(而不是handle本身)引用计数, 字段为<code>active_handles</code>, 因此一个handle可以通过ref或unref来让一个handle是否影响到loop的active, 比如libuv的async_handle就通过<code>uv__handle_unref</code>来防止event loop无法退出.</li></ol><h3 id="uv-run-pending"><a href="#uv-run-pending" class="headerlink" title="uv__run_pending"></a>uv__run_pending</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__run_pending</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE pq;</span><br><span class="line">  <span class="keyword">uv__io_t</span>* w;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;pq)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;pq);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line">    w = QUEUE_DATA(q, <span class="keyword">uv__io_t</span>, pending_queue);</span><br><span class="line">    w-&gt;cb(loop, w, POLLOUT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单, 就是把<code>pending_queue</code>所有io事件取出来, 并调用相关回调. pending queue的加入等以后再说.</p><h3 id="uv-run-idle-uv-run-prepare以及后面的uv-run-check"><a href="#uv-run-idle-uv-run-prepare以及后面的uv-run-check" class="headerlink" title="uv__run_idle,  uv__run_prepare以及后面的uv__run_check"></a>uv__run_idle,  uv__run_prepare以及后面的uv__run_check</h3><p>这三个调用分别操作idle_handles, prepare_handles以及check_handles. 这三种handle都是用下面的宏来操作:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> uv_#<span class="meta">#name##_start(uv_##name##_t* handle, uv_##name##_cb cb) &#123;           \</span></span><br><span class="line">  <span class="keyword">if</span> (uv__is_active(handle)) <span class="keyword">return</span> <span class="number">0</span>;                                      \</span><br><span class="line">  <span class="keyword">if</span> (cb == <span class="literal">NULL</span>) <span class="keyword">return</span> -EINVAL;                                           \</span><br><span class="line">  QUEUE_INSERT_HEAD(&amp;handle-&gt;loop-&gt;name##_handles, &amp;handle-&gt;<span class="built_in">queue</span>);         \</span><br><span class="line">  handle-&gt;name##_cb = cb;                                                   \</span><br><span class="line">  uv__handle_start(handle);                                                 \</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">&#125;                                                                           \</span><br><span class="line">                                                                            \</span><br><span class="line"><span class="keyword">int</span> uv_#<span class="meta">#name##_stop(uv_##name##_t* handle) &#123;                               \</span></span><br><span class="line">  <span class="keyword">if</span> (!uv__is_active(handle)) <span class="keyword">return</span> <span class="number">0</span>;                                     \</span><br><span class="line">  QUEUE_REMOVE(&amp;handle-&gt;<span class="built_in">queue</span>);                                             \</span><br><span class="line">  uv__handle_stop(handle);                                                  \</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">&#125;                                                                           \</span><br><span class="line">                                                                            \</span><br><span class="line"><span class="keyword">void</span> uv__run_#<span class="meta">#name(uv_loop_t* loop) &#123;                                      \</span></span><br><span class="line">  uv_#<span class="meta">#name##_t* h;                                                         \</span></span><br><span class="line">  QUEUE <span class="built_in">queue</span>;                                                              \</span><br><span class="line">  QUEUE* q;                                                                 \</span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;<span class="built_in">queue</span>);                                \</span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;<span class="built_in">queue</span>)) &#123;                                            \</span><br><span class="line">    q = QUEUE_HEAD(&amp;<span class="built_in">queue</span>);                                                 \</span><br><span class="line">    h = QUEUE_DATA(q, uv_##name##<span class="keyword">_t</span>, <span class="built_in">queue</span>);                                \</span><br><span class="line">    QUEUE_REMOVE(q);                                                        \</span><br><span class="line">    QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q);                            \</span><br><span class="line">    h-&gt;name##_cb(h);                                                        \</span><br><span class="line">  &#125;                                                                         \</span><br><span class="line">&#125;                                                                           \</span><br><span class="line">                                                                            \</span><br><span class="line"><span class="keyword">void</span> uv__#<span class="meta">#name##_close(uv_##name##_t* handle) &#123;                            \</span></span><br><span class="line">  uv_#<span class="meta">#name##_stop(handle);                                                 \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出这三种操作很简单.start就是把 handle加入到相应的queue, 然后调用<code>uv__handle_start</code>, stop就是将handle移动出来然后调用<code>uv__handle_stop</code>, run就是就是依次执行queue上面所有handle的回调.</p><h3 id="uv-backend-timeout"><a href="#uv-backend-timeout" class="headerlink" title="uv_backend_timeout"></a>uv_backend_timeout</h3><p>这个函数比较简单, 就是计算下一次poll的超时时间. 当然, 这个函数只在pending队列被执行前是空的(这样就保证<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_backend_timeout</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!uv__has_active_handles(loop) &amp;&amp; !uv__has_active_reqs(loop))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;loop-&gt;idle_handles))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;closing_handles)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uv__next_timeout(loop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到, 当 event loop确认自己还有事情要做的时候, 就会返回0, 表示下次poll是非阻塞的.<br><code>uv__next_timeout</code>比较简单, 就是从 <code>timer_heap</code>中得到最小超时的时间, 从而计算出下一次的超时时间, 如果 <code>timer_heap</code>是空, 表示下一次poll可以无限制的等待.</p><h3 id="uv-io-poll"><a href="#uv-io-poll" class="headerlink" title="uv__io_poll"></a>uv__io_poll</h3><p><code>uv__io_poll</code>是整个 event loop中的最关键, 这部份内容较多, 我们下一篇来讲.</p><h3 id="uv-run-closing-handles"><a href="#uv-run-closing-handles" class="headerlink" title="uv__run_closing_handles"></a>uv__run_closing_handles</h3><p>这个函数用来关闭所有的待关闭的 handles, 通过调用 <code>uv__finish_close</code>来实现. 这个函数会关闭 handle并调用对应的回调函数, 这部份比较杂, 如果后面有机会再讲讲.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uv__run_closing_handles</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uv_handle_t</span>* p;</span><br><span class="line">  <span class="keyword">uv_handle_t</span>* q;</span><br><span class="line"></span><br><span class="line">  p = loop-&gt;closing_handles;</span><br><span class="line">  loop-&gt;closing_handles = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p) &#123;</span><br><span class="line">    q = p-&gt;next_closing;</span><br><span class="line">    uv__finish_close(p);</span><br><span class="line">    p = q;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个 event loop后续部分就比较简单了, 就不再说了. 至此我们就看完了. 如果你把代码和官方的文档中的流程图对应一下, 就会发现是一致的.<br>下一篇, 我们会来看看 libuv是如何进行 poll操作的.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;by gngshn &lt;a href=&quot;mailto:&amp;#103;&amp;#110;&amp;#103;&amp;#115;&amp;#x68;&amp;#x6e;&amp;#x40;&amp;#x67;&amp;#109;&amp;#x61;&amp;#x69;&amp;#x6c;&amp;#46;&amp;#x63;&amp;#111;&amp;#x6d;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&amp;#103;&amp;#110;&amp;#103;&amp;#115;&amp;#x68;&amp;#x6e;&amp;#x40;&amp;#x67;&amp;#109;&amp;#x61;&amp;#x69;&amp;#x6c;&amp;#46;&amp;#x63;&amp;#111;&amp;#x6d;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇文章我们讲到了 libuv的初始化, 现在乘热打铁, 我们接着看看 libuv的 event loop是如何运转的.&lt;br&gt;对于 event loop的运转在其官方的文档中有详细的描述&lt;br&gt;&lt;br&gt;&lt;a href=&quot;http://docs.libuv.org/en/v1.x/design.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;libuv design overview&lt;/a&gt;&lt;br&gt;event loop的流程图如下&lt;br&gt;
    
    </summary>
    
      <category term="libuv" scheme="http://gngshn.github.io/categories/libuv/"/>
    
    
      <category term="libuv" scheme="http://gngshn.github.io/tags/libuv/"/>
    
  </entry>
  
  <entry>
    <title>libuv 源码分析(1) - event loop的初始化</title>
    <link href="http://gngshn.github.io/2017/09/01/libuv-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-event-loop%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://gngshn.github.io/2017/09/01/libuv-源码分析-1-event-loop的初始化/</id>
    <published>2017-09-01T03:22:46.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>by gngshn <a href="mailto:&#103;&#110;&#103;&#115;&#x68;&#110;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#103;&#110;&#103;&#115;&#x68;&#110;&#64;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a></p><p>从这里开始我将从linux的角度来看看libuv的工作原理, 如果您希望看到libuv跨平台的实现方式, 那你可能要失望了. 因为这一系列文章都将从linux的角度来写.</p><p>我们知道如果需要使用libuv的event loop需要通过<code>uv_default_loop</code>或者<code>uv_loop_init</code>来获得一个loop, 前者也是会调用后者的. 所以我们来看看<code>uv_loop_init</code>到底做了些什么, 我将在source code中进行直接写注释来描述相关字段的含义.<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_loop_init</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span>* saved_data;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建一ipe, 往其中一端写能解锁读端, 这与信号处理有关 */</span></span><br><span class="line">  uv__signal_global_once_init();</span><br><span class="line"></span><br><span class="line">  saved_data = loop-&gt;data;</span><br><span class="line">  <span class="built_in">memset</span>(loop, <span class="number">0</span>, <span class="keyword">sizeof</span>(*loop));</span><br><span class="line">  loop-&gt;data = saved_data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 保存libuv中timer的堆, 用来计算下次poll的超时时间 */</span></span><br><span class="line">  heap_init((struct heap*) &amp;loop-&gt;timer_heap);</span><br><span class="line">  <span class="comment">/* libuv线程池完成工作以后, 会把相关的request(uv_work_t)放在这个链表上, 从而libuv可以通过他来调用after_work_done回调 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;wq);</span><br><span class="line">  <span class="comment">/* event loop中的所有的request */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;active_reqs);</span><br><span class="line">  <span class="comment">/* event loop中的idle handles, 这个handle每次loop都会调用一次 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;idle_handles);</span><br><span class="line">  <span class="comment">/* event loop中的async_handles, 这个handle主要用来管理多线程的异步通知, 如libuv的工作队列的完成通知 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;async_handles);</span><br><span class="line">  <span class="comment">/* event loop中的prepare handles, 这个handle每次loop都会调用一次 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;check_handles);</span><br><span class="line">  <span class="comment">/* event loop中的check handles, 这个handle每次loop都会调用一次, 和prepare是一对, 分别在poll前后调用 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;prepare_handles);</span><br><span class="line">  <span class="comment">/* event loop中所有的handle */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;handle_queue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* event loop监听的描述符数量 */</span></span><br><span class="line">  loop-&gt;nfds = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* event loop监听的事件的表(数组, 但不一定充满, 用fd来索引), 最后两个元素是特殊的 */</span></span><br><span class="line">  loop-&gt;watchers = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">/* watchers数组的大小 - 2 */</span></span><br><span class="line">  loop-&gt;nwatchers = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* TODO */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;pending_queue);</span><br><span class="line">  <span class="comment">/* 所有待加入poll的事ueue, libuv通过它来确定需要往epoll中加入哪些描述符和事件 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;watcher_queue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 需要关闭的handles链表 */</span></span><br><span class="line">  loop-&gt;closing_handles = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">/* 更新时间 */</span></span><br><span class="line">  uv__update_time(loop);</span><br><span class="line">  <span class="comment">/* 这里存放异步通知所用的eventfd或者pipe的描述符 */</span></span><br><span class="line">  loop-&gt;async_io_watcher.fd = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* 和上面一样, 存放pipe对的另一个描述符, 如果是eventfd, 就是-1 */</span></span><br><span class="line">  loop-&gt;async_wfd = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* uv信号处理回调所用的pipe, 信号处理函数往[1]写, event loop poll [0], 从而获取msg来处理信号 */</span></span><br><span class="line">  loop-&gt;signal_pipefd[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  loop-&gt;signal_pipefd[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* event loop的epoll描述符 */</span></span><br><span class="line">  loop-&gt;backend_fd = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* TODO */</span></span><br><span class="line">  loop-&gt;emfile_fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* timer id的counter, 为了给timer一个唯一的id, 每次创建timer, 这个值都加1 */</span></span><br><span class="line">  loop-&gt;timer_counter = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* event loop的停止标志*/</span></span><br><span class="line">  loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将backend_fd设为创建的epoll的描述符, 并初始化了inotify为-1 */</span></span><br><span class="line">  err = uv__platform_loop_init(loop);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  <span class="comment">/* 这里会初始化前面的signal_pipefd为一对pipe并将signal_pipefd[0]的POLLIN事件加入监听列表, 用来处理信号 */</span></span><br><span class="line">  <span class="comment">/* 这里的child_watcher是用来处理子进程的退出的, 会在创建进程(uv_spam)时添加SIG_CHILD的处理 */</span></span><br><span class="line">  err = uv_signal_init(loop, &amp;loop-&gt;child_watcher);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> fail_signal_init;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* unref是为了不让event loop停不下来, 也就是event loop判定alive的条件去除这个handle, 后面文章会说 */</span></span><br><span class="line">  uv__handle_unref(&amp;loop-&gt;child_watcher);</span><br><span class="line">  <span class="comment">/* 标记为UV__HANDLE_INTERNAL, 从而handle不会被关闭, 也不会被uv_walk影响 */</span></span><br><span class="line">  loop-&gt;child_watcher.flags |= UV__HANDLE_INTERNAL;</span><br><span class="line">  <span class="comment">/* 所有子进程的队列 */</span></span><br><span class="line">  QUEUE_INIT(&amp;loop-&gt;process_handles);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* TODO */</span></span><br><span class="line">  err = uv_rwlock_init(&amp;loop-&gt;cloexec_lock);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> fail_rwlock_init;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 用来保护loop-&gt;wq的保护锁 */</span></span><br><span class="line">  err = uv_mutex_init(&amp;loop-&gt;wq_mutex);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> fail_mutex_init;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 创建eventfd放在async_io_watcher.fd(前面说过), 并把其POLLIN加入到监听事件中, 用来处理进程发来的异步通知 */</span></span><br><span class="line">  err = uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> fail_async_init;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 前面讲过 */</span></span><br><span class="line">  uv__handle_unref(&amp;loop-&gt;wq_async);</span><br><span class="line">  loop-&gt;wq_async.flags |= UV__HANDLE_INTERNAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_async_init:</span><br><span class="line">  uv_mutex_destroy(&amp;loop-&gt;wq_mutex);</span><br><span class="line"></span><br><span class="line">fail_mutex_init:</span><br><span class="line">  uv_rwlock_destroy(&amp;loop-&gt;cloexec_lock);</span><br><span class="line"></span><br><span class="line">fail_rwlock_init:</span><br><span class="line">  uv__signal_loop_cleanup(loop);</span><br><span class="line"></span><br><span class="line">fail_signal_init:</span><br><span class="line">  uv__platform_loop_delete(loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是libuv的event loop的初始化流程, 后续我将分模块来讲解libuv各个功能模块的实现原理.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;by gngshn &lt;a href=&quot;mailto:&amp;#103;&amp;#110;&amp;#103;&amp;#115;&amp;#x68;&amp;#110;&amp;#64;&amp;#x67;&amp;#109;&amp;#x61;&amp;#105;&amp;#x6c;&amp;#x2e;&amp;#x63;&amp;#x6f;&amp;#x6d;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&amp;#103;&amp;#110;&amp;#103;&amp;#115;&amp;#x68;&amp;#110;&amp;#64;&amp;#x67;&amp;#109;&amp;#x61;&amp;#105;&amp;#x6c;&amp;#x2e;&amp;#x63;&amp;#x6f;&amp;#x6d;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从这里开始我将从linux的角度来看看libuv的工作原理, 如果您希望看到libuv跨平台的实现方式, 那你可能要失望了. 因为这一系列文章都将从linux的角度来写.&lt;/p&gt;
&lt;p&gt;我们知道如果需要使用libuv的event loop需要通过&lt;code&gt;uv_default_loop&lt;/code&gt;或者&lt;code&gt;uv_loop_init&lt;/code&gt;来获得一个loop, 前者也是会调用后者的. 所以我们来看看&lt;code&gt;uv_loop_init&lt;/code&gt;到底做了些什么, 我将在source code中进行直接写注释来描述相关字段的含义.&lt;br&gt;
    
    </summary>
    
      <category term="libuv" scheme="http://gngshn.github.io/categories/libuv/"/>
    
    
      <category term="libuv" scheme="http://gngshn.github.io/tags/libuv/"/>
    
  </entry>
  
  <entry>
    <title>正式开始书写自己的博客</title>
    <link href="http://gngshn.github.io/2017/04/15/%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%A7%8B%E4%B9%A6%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://gngshn.github.io/2017/04/15/正式开始书写自己的博客/</id>
    <published>2017-04-15T12:47:14.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直不喜欢类似csdn一类的网站来写博客, 自己搭wordpress有太麻烦, 现在使用github page正式开启自己的博客之旅.<br>这里主要会记录一些自己遇到的坑和一些学习的见解, 希望自己能坚持下去.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一直不喜欢类似csdn一类的网站来写博客, 自己搭wordpress有太麻烦, 现在使用github page正式开启自己的博客之旅.&lt;br&gt;这里主要会记录一些自己遇到的坑和一些学习的见解, 希望自己能坚持下去.&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随笔" scheme="http://gngshn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>mmap读写寄存器应注意不要越界</title>
    <link href="http://gngshn.github.io/2017/04/15/mmap%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8%E5%BA%94%E6%B3%A8%E6%84%8F%E4%B8%8D%E8%A6%81%E8%B6%8A%E7%95%8C/"/>
    <id>http://gngshn.github.io/2017/04/15/mmap读写寄存器应注意不要越界/</id>
    <published>2017-04-15T08:56:12.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>前两天使用/dev/mem来修改寄存器时遇到了一个问题. 当时的情况是这样的:<br>我有8K的寄存器空间需要访问, 但是当时我将mmap的空间大小写小了, 只写了1K, 相当于只映射了4K的空间. 但是当我操作到4K-8K的空间的时候, 读写看起来都没有问题, 读回来的数据和写入的数据是一致的. 但是实际寄存器上好像没有感受到一样(没有写入寄存器应有的现象), 刚开始一致怀疑是fpga的bitfile有问题. 后来无意发现了mmap指定的size不对, 改好了就可以了.<br>那么这里有一个问题, 为什么访问4K-8K的空间没有发生segment fault呢?<br><a id="more"></a><br>我做了一个实验, 下面有两个程序:<br>program 0 - have mmap:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"a.txt"</span>, O_RDWR | O_DSYNC);</span><br><span class="line"><span class="keyword">void</span> *ptr = mmap(<span class="number">0</span>, <span class="number">1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%016lx\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr);</span><br><span class="line">pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>program 1 - don’t have mmap:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先将程序运行起来, 然后通过/proc/[pid]/maps查看他们的线性地址分布情况:<br>对于program 0:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">00400000-00401000 r-xp 00000000 fd:02 1051271                            /home/gngshn/b</span><br><span class="line">00600000-00601000 r--p 00000000 fd:02 1051271                            /home/gngshn/b</span><br><span class="line">00601000-00602000 rw-p 00001000 fd:02 1051271                            /home/gngshn/b</span><br><span class="line">02293000-022b4000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7f17bd677000-7f17bd834000 r-xp 00000000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7f17bd834000-7f17bda33000 ---p 001bd000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7f17bda33000-7f17bda37000 r--p 001bc000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7f17bda37000-7f17bda39000 rw-p 001c0000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7f17bda39000-7f17bda3d000 rw-p 00000000 00:00 0</span><br><span class="line">7f17bda3d000-7f17bda62000 r-xp 00000000 fd:00 924461                     /usr/lib64/ld-2.24.so</span><br><span class="line">7f17bdc3f000-7f17bdc41000 rw-p 00000000 00:00 0</span><br><span class="line">7f17bdc5f000-7f17bdc60000 rw-s 00000000 fd:02 1066614                    /home/gngshn/a.txt</span><br><span class="line">7f17bdc60000-7f17bdc62000 rw-p 00000000 00:00 0</span><br><span class="line">7f17bdc62000-7f17bdc63000 r--p 00025000 fd:00 924461                     /usr/lib64/ld-2.24.so</span><br><span class="line">7f17bdc63000-7f17bdc64000 rw-p 00026000 fd:00 924461                     /usr/lib64/ld-2.24.so</span><br><span class="line">7f17bdc64000-7f17bdc65000 rw-p 00000000 00:00 0</span><br><span class="line">7fff75117000-7fff75138000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7fff75151000-7fff75153000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7fff75153000-7fff75155000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure></p><p>对于program 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00400000-00401000 r-xp 00000000 fd:02 1051230                            /home/gngshn/a</span><br><span class="line">00600000-00601000 r--p 00000000 fd:02 1051230                            /home/gngshn/a</span><br><span class="line">00601000-00602000 rw-p 00001000 fd:02 1051230                            /home/gngshn/a</span><br><span class="line">7fb99a57a000-7fb99a737000 r-xp 00000000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7fb99a737000-7fb99a936000 ---p 001bd000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7fb99a936000-7fb99a93a000 r--p 001bc000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7fb99a93a000-7fb99a93c000 rw-p 001c0000 fd:00 924939                     /usr/lib64/libc-2.24.so</span><br><span class="line">7fb99a93c000-7fb99a940000 rw-p 00000000 00:00 0</span><br><span class="line">7fb99a940000-7fb99a965000 r-xp 00000000 fd:00 924461                     /usr/lib64/ld-2.24.so</span><br><span class="line">7fb99ab42000-7fb99ab44000 rw-p 00000000 00:00 0</span><br><span class="line">7fb99ab63000-7fb99ab65000 rw-p 00000000 00:00 0</span><br><span class="line">7fb99ab65000-7fb99ab66000 r--p 00025000 fd:00 924461                     /usr/lib64/ld-2.24.so</span><br><span class="line">7fb99ab66000-7fb99ab67000 rw-p 00026000 fd:00 924461                     /usr/lib64/ld-2.24.so</span><br><span class="line">7fb99ab67000-7fb99ab68000 rw-p 00000000 00:00 0</span><br><span class="line">7ffdbcd07000-7ffdbcd28000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffdbcd31000-7ffdbcd33000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffdbcd33000-7ffdbcd35000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure></p><p>可以看到program 0比program 1多了两段地址空间</p><ol><li>heap空间</li><li>a.txt的mmap空间<br>heap空间是引入标准io时, 内部使用引入的; a.txt的mmap空间是程序里面调用mmap产生的.<br>这里可以看见mmap访问后面的地址没有出错的原因了, 在mmap后面刚好有一段mmap空间<code>7f17bdc60000-7f17bdc62000 rw-p 00000000 00:00 0</code>, size为8K, 权限为读写, 这段空间是匿名映射空间, 当时我的读写都操作到这里了.<br>因此在使用mmap操作的时候, 一定要注意操作内存不要过界, 程序很可能不会因为你的操作过界而发生segment fault, 但是却会和你期望的相差甚远.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天使用/dev/mem来修改寄存器时遇到了一个问题. 当时的情况是这样的:&lt;br&gt;我有8K的寄存器空间需要访问, 但是当时我将mmap的空间大小写小了, 只写了1K, 相当于只映射了4K的空间. 但是当我操作到4K-8K的空间的时候, 读写看起来都没有问题, 读回来的数据和写入的数据是一致的. 但是实际寄存器上好像没有感受到一样(没有写入寄存器应有的现象), 刚开始一致怀疑是fpga的bitfile有问题. 后来无意发现了mmap指定的size不对, 改好了就可以了.&lt;br&gt;那么这里有一个问题, 为什么访问4K-8K的空间没有发生segment fault呢?&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://gngshn.github.io/categories/linux/"/>
    
    
      <category term="mmap" scheme="http://gngshn.github.io/tags/mmap/"/>
    
      <category term="driver" scheme="http://gngshn.github.io/tags/driver/"/>
    
      <category term="linux" scheme="http://gngshn.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>kernel中的IS_ENABLED</title>
    <link href="http://gngshn.github.io/2017/04/15/kernel%E4%B8%AD%E7%9A%84IS-ENABLED/"/>
    <id>http://gngshn.github.io/2017/04/15/kernel中的IS-ENABLED/</id>
    <published>2017-04-15T08:55:11.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>在kernel的代码中, 有时候会看见<code>IS_ENABLED(CONFIG_XXXX)</code>来测试某个Kconfig选项是否开启(即选中为<code>y</code>或者<code>m</code>). 如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_TIME_LOW_RES) &amp;&amp; timer-&gt;is_rel)</span><br><span class="line">rem -= hrtimer_resolution;</span><br></pre></td></tr></table></figure></p><p>这里当TIME_LOW_RES这个Kconfig选项配置为<code>y</code>或<code>m</code>, 并且<code>timer-&gt;is_rel</code>不为0时调用<code>rem -= hrtimer_resolution</code>.<br>那么这个是怎样实现的呢?<br><a id="more"></a><br>首先在Kconfig中选中某个选项为<code>y</code>或<code>m</code>时, 在<code>.config</code>文件中就会由一个<code>CONFIG_XXXXX=y</code>或<code>CONFIG_XXXXX=m</code>, 并且会自动生成一个头文件<code>autoconfig.h</code>. 当选中为<code>y</code>时, 头文件中包含<code>#define CONFIG_XXXXX 1</code>, 当选中为<code>m</code>时, 头文件中包含<code>#define CONFIG_XXXXX_MODULE 1</code>, 当不选中是, 头文件中不包含相关语句.<br><code>IS_ENABLED</code>定义为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ENABLED(option) __or(IS_BUILTIN(option), IS_MODULE(option))</span></span><br></pre></td></tr></table></figure></p><p><code>IS_BUILTIN</code>, <code>IS_MODULE</code>和<code>__or</code>分别定义为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_BUILTIN(option) __is_defined(option)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MODULE(option) __is_defined(option##_MODULE)</span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __or(x, y)___or(x, y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___or(x, y)____or(__ARG_PLACEHOLDER_##x, y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ____or(arg1_or_junk, y)__take_second_arg(arg1_or_junk 1, y)</span></span><br></pre></td></tr></table></figure><p><code>__is_defined</code>定义为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __is_defined(x)___is_defined(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___is_defined(val)____is_defined(__ARG_PLACEHOLDER_##val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ____is_defined(arg1_or_junk)__take_second_arg(arg1_or_junk 1, 0)</span></span><br></pre></td></tr></table></figure></p><p>在这之前定义了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ARG_PLACEHOLDER_1 0,</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __take_second_arg(__ignored, val, ...) val</span></span><br></pre></td></tr></table></figure></p><p>当<code>#define CONFIG_XXXXX 1</code>时<code>__is_defined(1)</code>展开为<code>____is_defined(0,)</code>, 即<code>__take_second_arg(0, 1, 0)</code>, 最终为<code>1</code><br>当<code>CONFIG_XXXXX</code>没有定义时<code>__is_defined()</code>展开为<code>____is_defined()</code>(因为没有定义<strong>ARG_PLACEHOLDER_), 即`</strong>take_second_arg(1, 0)<code>, 最终为</code>0<code>同样的方法可以理解</code>__or<code>.因此</code>IS_ENABLED<code>主要是将没有定义的</code>CONFIG_XXXXX`映射到0.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在kernel的代码中, 有时候会看见&lt;code&gt;IS_ENABLED(CONFIG_XXXX)&lt;/code&gt;来测试某个Kconfig选项是否开启(即选中为&lt;code&gt;y&lt;/code&gt;或者&lt;code&gt;m&lt;/code&gt;). 如&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (IS_ENABLED(CONFIG_TIME_LOW_RES) &amp;amp;&amp;amp; timer-&amp;gt;is_rel)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	rem -= hrtimer_resolution;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里当TIME_LOW_RES这个Kconfig选项配置为&lt;code&gt;y&lt;/code&gt;或&lt;code&gt;m&lt;/code&gt;, 并且&lt;code&gt;timer-&amp;gt;is_rel&lt;/code&gt;不为0时调用&lt;code&gt;rem -= hrtimer_resolution&lt;/code&gt;.&lt;br&gt;那么这个是怎样实现的呢?&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://gngshn.github.io/categories/linux/"/>
    
    
      <category term="driver" scheme="http://gngshn.github.io/tags/driver/"/>
    
      <category term="linux" scheme="http://gngshn.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>使用docker来构建嵌入式开发环境</title>
    <link href="http://gngshn.github.io/2017/04/15/%E4%BD%BF%E7%94%A8docker%E6%9D%A5%E6%9E%84%E5%BB%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://gngshn.github.io/2017/04/15/使用docker来构建嵌入式开发环境/</id>
    <published>2017-04-15T08:54:11.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>我目前使用的一套嵌入式开发SDK是在ubuntu 14.04上构建的, 对于较新的ubuntu发行版或其他linux发行版是不能兼容的.<br>比如目前我使用的是Fedora 25作为自己的系统, 那么要编译SDK会发生错误. 主要是libtools, autoconf等工具的兼容性问题. 为了解决这个问题可以使用docker来构建一套基于ubuntu14.04文件系统的编译系统, 从而实现在Fedora 25上编译SDK.<br><a id="more"></a><br>首先贴上自己的Dockerfile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># rsdk builder docker</span><br><span class="line"># creater by gngshn</span><br><span class="line"># Jan 20 2017</span><br><span class="line">FROM ubuntu:14.04</span><br><span class="line">ENV TERM=xterm</span><br><span class="line">RUN echo &quot;dash dash/sh boolean false&quot; | debconf-set-selections \</span><br><span class="line">    &amp;&amp; dpkg-reconfigure -p critical dash \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y bc python dpkg lzma pkg-config libncurses5-dev \</span><br><span class="line">       autoconf automake cmake libtool gettext texinfo gawk \</span><br><span class="line">    &amp;&amp; dpkg --add-architecture i386 \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y gcc-multilib lib32z1-dev lib32ncurses5-dev \</span><br><span class="line">    &amp;&amp; apt-get clean \</span><br><span class="line">    &amp;&amp; groupadd -g 1000 gngshn \</span><br><span class="line">    &amp;&amp; useradd -u 1000 -g 1000 -G sudo -m gngshn \</span><br><span class="line">    &amp;&amp; mkdir /home/gngshn/ipcam \</span><br><span class="line">    &amp;&amp; chown gngshn:gngshn /home/gngshn/ipcam \</span><br><span class="line">    &amp;&amp; echo &quot;root:xx&quot; | chpasswd \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</span><br><span class="line">USER gngshn</span><br><span class="line">WORKDIR /home/gngshn</span><br><span class="line">ENV TERM=xterm-256color \</span><br><span class="line">    TERMINFO=/lib/terminfo</span><br></pre></td></tr></table></figure></p><p>在Dockerfile中需要安装的包都是在ubuntu 14.04 docker中根据需要一步一步安装, 并最终确定需要的安装的所有的包.<br>在上面的Dockerfile目录下执行<code>sudo docker build -t ipcam_build .</code>, docker就会从docker.io上下载ubuntu 14.04(也可以配置一些国内的docker加速器加速), 然后开始一层一层构建整个开发环境<br>等<code>ipcam_build</code>构建完成后, 执行<code>sudo docker run -it --name ipcam_build -v ~/ipcam:/home/gngshn/ipcam ipcam_build</code>, 就可以进入到本开发环境的命令行了, 同时在docker 用户目录的ipcam下挂载了宿主机上的SDK(宿主机SDK的目录在~/ipcam).<br>后续就可以在docker中直接编译SDK了.<br>在docker命令行下按<code>Ctrl+D</code>就退出docker了, 当需要再次进入SDK编译环境时执行<code>sudo docker start -ai ipcam_build</code>就可以了.<br>对于其他的嵌入式开发环境配置也是类似的. 这里就是一个简单的引导.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我目前使用的一套嵌入式开发SDK是在ubuntu 14.04上构建的, 对于较新的ubuntu发行版或其他linux发行版是不能兼容的.&lt;br&gt;比如目前我使用的是Fedora 25作为自己的系统, 那么要编译SDK会发生错误. 主要是libtools, autoconf等工具的兼容性问题. 为了解决这个问题可以使用docker来构建一套基于ubuntu14.04文件系统的编译系统, 从而实现在Fedora 25上编译SDK.&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://gngshn.github.io/categories/linux/"/>
    
    
      <category term="docker" scheme="http://gngshn.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>dev_mem的mmap分析</title>
    <link href="http://gngshn.github.io/2017/04/15/dev-mem%E7%9A%84mmap%E5%88%86%E6%9E%90/"/>
    <id>http://gngshn.github.io/2017/04/15/dev-mem的mmap分析/</id>
    <published>2017-04-15T08:52:24.000Z</published>
    <updated>2022-04-26T03:37:48.380Z</updated>
    
    <content type="html"><![CDATA[<p>当用户空间需要实现驱动程序时, 需要操作底层的寄存器. 使用<code>/dev/mem</code>映射io内存空间就是一种常用的方式. <code>/dev/mem</code> 一般都是使用其 <code>mmap</code> 函数. 将底层的寄存器映射到用户空间地址. 下面对 <code>/dev/mem</code>的<code>mmap</code>函数进行一下简单的分析.<br><code>/dev/mem</code>设备文件是由<code>drivers/char/mem.c</code>驱动创建. 该设备文件的<code>file_operations</code>为<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> __<span class="title">maybe_unused</span> <span class="title">mem_fops</span> = &#123;</span></span><br><span class="line">.llseek= memory_lseek,</span><br><span class="line">.read= read_mem,</span><br><span class="line">.write= write_mem,</span><br><span class="line">.mmap= mmap_mem,</span><br><span class="line">.open= open_mem,</span><br><span class="line">#ifndef CONFIG_MMU</span><br><span class="line">.get_unmapped_area = get_unmapped_area_mem,</span><br><span class="line">.mmap_capabilities = memory_mmap_capabilities,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>mmap_mem</code>定义为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mmap_mem</span><span class="params">(struct file *file, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!valid_mmap_phys_addr_range(vma-&gt;vm_pgoff, size))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!private_mapping_ok(vma))</span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!range_is_allowed(vma-&gt;vm_pgoff, size))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!phys_mem_access_prot_allowed(file, vma-&gt;vm_pgoff, size,</span><br><span class="line">&amp;vma-&gt;vm_page_prot))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">vma-&gt;vm_page_prot = phys_mem_access_prot(file, vma-&gt;vm_pgoff,</span><br><span class="line"> size,</span><br><span class="line"> vma-&gt;vm_page_prot);</span><br><span class="line"></span><br><span class="line">vma-&gt;vm_ops = &amp;mmap_mem_ops;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remap-pfn-range will mark the range VM_IO */</span></span><br><span class="line"><span class="keyword">if</span> (remap_pfn_range(vma,</span><br><span class="line">    vma-&gt;vm_start,</span><br><span class="line">    vma-&gt;vm_pgoff,</span><br><span class="line">    size,</span><br><span class="line">    vma-&gt;vm_page_prot)) &#123;</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>valid_mmap_phys_addr_range</code>函数始终返回1.<br><code>private_mapping_ok</code>函数在由MMU的情况下始终返回1.<br><code>range_is_allowed</code>函数不配置<code>CONFIG_STRICT_DEVMEM</code>时始终返回1, 在配置<code>CONFIG_STRICT_DEVMEM</code>时, 齐定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">range_is_allowed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> pfn, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u64 from = ((u64)pfn) &lt;&lt; PAGE_SHIFT;</span><br><span class="line">u64 to = from + size;</span><br><span class="line">u64 cursor = from;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cursor &lt; to) &#123;</span><br><span class="line"><span class="keyword">if</span> (!devmem_is_allowed(pfn))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">cursor += PAGE_SIZE;</span><br><span class="line">pfn++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个函数中, 会对需要映射的地址段进行检查, 在x86平台上, <code>devmem_is_allowed</code>定义为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">devmem_is_allowed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> pagenr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pagenr &lt; <span class="number">256</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (iomem_is_exclusive(pagenr &lt;&lt; PAGE_SHIFT))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!page_is_ram(pagenr))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在arm平台上, <code>dev_mem_allowed</code>定义为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">devmem_is_allowed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> pfn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (iomem_is_exclusive(pfn &lt;&lt; PAGE_SHIFT))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!page_is_ram(pfn))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在x86上, 前1M空间是预留给BIOS和一些其他X等应用使用的空间, 这段空间是允许映射的.<br><code>iomem_is_exclusive</code>定义为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * check if an address is reserved in the iomem resource tree</span></span><br><span class="line"><span class="comment"> * returns 1 if reserved, 0 if not reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iomem_is_exclusive</span><span class="params">(u64 addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">p</span> = &amp;<span class="title">iomem_resource</span>;</span></span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">loff_t</span> l;</span><br><span class="line"><span class="keyword">int</span> size = PAGE_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!strict_iomem_checks)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">addr = addr &amp; PAGE_MASK;</span><br><span class="line"></span><br><span class="line">read_lock(&amp;resource_lock);</span><br><span class="line"><span class="keyword">for</span> (p = p-&gt;child; p ; p = r_next(<span class="literal">NULL</span>, p, &amp;l)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can probably skip the resources without</span></span><br><span class="line"><span class="comment"> * IORESOURCE_IO attribute?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;start &gt;= addr + size)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;end &lt; addr)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A resource is exclusive if IORESOURCE_EXCLUSIVE is set</span></span><br><span class="line"><span class="comment"> * or CONFIG_IO_STRICT_DEVMEM is enabled and the</span></span><br><span class="line"><span class="comment"> * resource is busy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((p-&gt;flags &amp; IORESOURCE_BUSY) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_IO_STRICT_DEVMEM)</span><br><span class="line">|| p-&gt;flags &amp; IORESOURCE_EXCLUSIVE) &#123;</span><br><span class="line">err = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">read_unlock(&amp;resource_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果这段地址对应的resource标记为<code>IORESOURCE_BUSY</code>, 那么将映射失败.<br>如果这段地址在ram中, 同样不允许映射.<br>可以看出在不配置<code>CONFIG_STRICT_DEVMEM</code>时, /dev/mem的限制是最小的.<br><code>phys_mem_access_prot_allowed</code>函数返回1<br>检查各种限制条件通过后, 接着调用<code>phys_mem_access_prot(file, vma-&gt;vm_pgoff, size, vma-&gt;vm_page_prot);</code>来改变被映射的内存区的的页面属性.<br>对于arm64, 定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pgprot_t</span> phys_mem_access_prot(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn,</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">long</span> size, <span class="keyword">pgprot_t</span> vma_prot)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!pfn_valid(pfn))</span><br><span class="line"><span class="keyword">return</span> pgprot_noncached(vma_prot);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (file-&gt;f_flags &amp; O_SYNC)</span><br><span class="line"><span class="keyword">return</span> pgprot_writecombine(vma_prot);</span><br><span class="line"><span class="keyword">return</span> vma_prot;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(phys_mem_access_prot);</span><br></pre></td></tr></table></figure></p><p>对于非内存空间, 使用<code>nocached</code>, 对于内存空间如果file打开了<code>O_SYNC</code>标志就使用<code>write_combine</code>.<br>最后调用<code>remap_pfn_range</code>来分配页表, 讲用户空间的一段线性地址空间指向映射的区域.<br>!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当用户空间需要实现驱动程序时, 需要操作底层的寄存器. 使用&lt;code&gt;/dev/mem&lt;/code&gt;映射io内存空间就是一种常用的方式. &lt;code&gt;/dev/mem&lt;/code&gt; 一般都是使用其 &lt;code&gt;mmap&lt;/code&gt; 函数. 将底层的寄存器映射到用户空间地址. 下面对 &lt;code&gt;/dev/mem&lt;/code&gt;的&lt;code&gt;mmap&lt;/code&gt;函数进行一下简单的分析.&lt;br&gt;&lt;code&gt;/dev/mem&lt;/code&gt;设备文件是由&lt;code&gt;drivers/char/mem.c&lt;/code&gt;驱动创建. 该设备文件的&lt;code&gt;file_operations&lt;/code&gt;为&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://gngshn.github.io/categories/linux/"/>
    
    
      <category term="mmap" scheme="http://gngshn.github.io/tags/mmap/"/>
    
  </entry>
  
</feed>
